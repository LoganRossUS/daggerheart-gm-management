<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daggerheart - Player Display</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Cinzel+Decorative:wght@700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: 
        radial-gradient(ellipse at 30% 20%, rgba(123, 45, 142, 0.3) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 80%, rgba(75, 0, 130, 0.4) 0%, transparent 50%),
        linear-gradient(180deg, #12061a 0%, #1a0d24 50%, #0d0610 100%);
      font-family: 'Cinzel', serif;
      cursor: none;
    }
    
    /* Fear Tracker - Bottom of screen */
    #fearTracker {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 1200px;
    }
    
    .pike-container {
      position: relative;
      height: 120px;
      display: flex;
      align-items: center;
    }
    
    .pike-labels {
      position: absolute;
      width: 100%;
      display: flex;
      justify-content: space-between;
      top: -25px;
      padding: 0 30px;
    }
    
    .pike-labels span {
      font-size: 0.9rem;
      letter-spacing: 3px;
    }
    
    .pike-labels .hope {
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .pike-labels .fear-label {
      color: #b388ff;
      text-shadow: 0 0 10px rgba(179, 136, 255, 0.5);
    }
    
    .pike {
      position: absolute;
      left: 30px;
      right: 30px;
      top: 50%;
      transform: translateY(-50%);
      height: 14px;
      background: linear-gradient(180deg, #8B5A2B 0%, #6B4423 15%, #5D3A1A 30%, #4A2F15 50%, #5D3A1A 70%, #6B4423 85%, #8B5A2B 100%);
      border-radius: 7px;
      box-shadow: inset 0 2px 3px rgba(255,255,255,0.15), inset 0 -2px 3px rgba(0,0,0,0.4), 0 4px 12px rgba(0,0,0,0.6);
    }
    
    .pike::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(90deg, transparent 0px, rgba(0,0,0,0.08) 1px, transparent 2px, transparent 8px);
      border-radius: 7px;
    }
    
    .pike-point-left {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 0;
      height: 0;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-right: 22px solid #b8860b;
      filter: drop-shadow(-2px 0 3px rgba(0,0,0,0.5));
    }
    
    .pike-point-right {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 0;
      height: 0;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-left: 22px solid #4a0e4e;
      filter: drop-shadow(2px 0 5px rgba(75, 0, 130, 0.8));
    }
    
    .skull {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 50px;
      height: 65px;
      transition: left 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 10;
    }
    
    /* Fear Counter */
    #fearCounter {
      position: absolute;
      top: 20px;
      right: 30px;
      text-align: right;
    }
    
    #fearCounter .label {
      font-size: 1rem;
      color: #888;
      letter-spacing: 2px;
    }
    
    #fearCounter .value {
      font-family: 'Cinzel Decorative', serif;
      font-size: 4rem;
      font-weight: 900;
      transition: all 0.3s ease;
    }
    
    /* Dice Animation Area */
    #diceArea {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      perspective: 1200px;
    }

    /* 3D Dice Container */
    .die-container {
      position: absolute;
      transform-style: preserve-3d;
      filter: drop-shadow(0 20px 30px rgba(0,0,0,0.6));
    }

    .die {
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.1s linear;
    }

    .die-face {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Cinzel Decorative', serif;
      font-weight: 900;
      backface-visibility: visible;
      border: 2px solid rgba(0,0,0,0.3);
    }

    /* D6 Cube Dice */
    .die.d6 {
      width: 80px;
      height: 80px;
    }

    .die.d6 .die-face {
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
      border-radius: 12px;
      box-shadow: inset 0 0 15px rgba(0,0,0,0.1);
    }

    .die.d6 .die-face.front  { transform: translateZ(40px); }
    .die.d6 .die-face.back   { transform: rotateY(180deg) translateZ(40px); }
    .die.d6 .die-face.right  { transform: rotateY(90deg) translateZ(40px); }
    .die.d6 .die-face.left   { transform: rotateY(-90deg) translateZ(40px); }
    .die.d6 .die-face.top    { transform: rotateX(90deg) translateZ(40px); }
    .die.d6 .die-face.bottom { transform: rotateX(-90deg) translateZ(40px); }

    /* D6 Pips */
    .pip-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      width: 60px;
      height: 60px;
      gap: 2px;
    }

    .pip {
      width: 14px;
      height: 14px;
      background: radial-gradient(circle at 30% 30%, #333, #111);
      border-radius: 50%;
      margin: auto;
      box-shadow: inset 0 2px 3px rgba(255,255,255,0.2), 0 2px 4px rgba(0,0,0,0.3);
    }

    .pip.hidden { visibility: hidden; }

    /* D20 Icosahedron (simplified as larger die with number) */
    .die.d20 {
      width: 100px;
      height: 100px;
    }

    .die.d20 .die-face {
      width: 100px;
      height: 100px;
      font-size: 2.5rem;
      color: #1a1a1a;
      background: linear-gradient(145deg, #ffd700, #b8860b);
      clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
      border: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    .die.d20 .die-face.front  { transform: translateZ(50px); }
    .die.d20 .die-face.back   { transform: rotateY(180deg) translateZ(50px); }
    .die.d20 .die-face.right  { transform: rotateY(72deg) translateZ(50px); }
    .die.d20 .die-face.left   { transform: rotateY(-72deg) translateZ(50px); }
    .die.d20 .die-face.top    { transform: rotateX(72deg) translateZ(50px); }
    .die.d20 .die-face.bottom { transform: rotateX(-72deg) translateZ(50px); }

    /* D12 Dodecahedron */
    .die.d12 {
      width: 90px;
      height: 90px;
    }

    .die.d12 .die-face {
      width: 90px;
      height: 90px;
      font-size: 2rem;
      color: #1a1a1a;
      background: linear-gradient(145deg, #e8d5ff, #9c7cc4);
      clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
      border: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .die.d12 .die-face.front  { transform: translateZ(45px); }
    .die.d12 .die-face.back   { transform: rotateY(180deg) translateZ(45px); }
    .die.d12 .die-face.right  { transform: rotateY(72deg) translateZ(45px); }
    .die.d12 .die-face.left   { transform: rotateY(-72deg) translateZ(45px); }
    .die.d12 .die-face.top    { transform: rotateX(72deg) translateZ(45px); }
    .die.d12 .die-face.bottom { transform: rotateX(-72deg) translateZ(45px); }

    /* D12 Hope (Gold) */
    .die.d12.hope .die-face {
      background: linear-gradient(145deg, #ffd700, #b8860b);
    }

    /* D12 Fear (Purple) */
    .die.d12.fear .die-face {
      background: linear-gradient(145deg, #b388ff, #7c4dff);
    }

    /* D10 */
    .die.d10 {
      width: 75px;
      height: 75px;
    }

    .die.d10 .die-face {
      width: 75px;
      height: 75px;
      font-size: 1.8rem;
      color: #1a1a1a;
      background: linear-gradient(145deg, #90caf9, #42a5f5);
      clip-path: polygon(50% 0%, 95% 35%, 80% 100%, 20% 100%, 5% 35%);
      border: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .die.d10 .die-face.front  { transform: translateZ(38px); }
    .die.d10 .die-face.back   { transform: rotateY(180deg) translateZ(38px); }
    .die.d10 .die-face.right  { transform: rotateY(72deg) translateZ(38px); }
    .die.d10 .die-face.left   { transform: rotateY(-72deg) translateZ(38px); }
    .die.d10 .die-face.top    { transform: rotateX(72deg) translateZ(38px); }
    .die.d10 .die-face.bottom { transform: rotateX(-72deg) translateZ(38px); }

    /* D8 Octahedron */
    .die.d8 {
      width: 70px;
      height: 70px;
    }

    .die.d8 .die-face {
      width: 70px;
      height: 70px;
      font-size: 1.6rem;
      color: #1a1a1a;
      background: linear-gradient(145deg, #a5d6a7, #66bb6a);
      clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
      border: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .die.d8 .die-face.front  { transform: translateZ(35px); }
    .die.d8 .die-face.back   { transform: rotateY(180deg) translateZ(35px); }
    .die.d8 .die-face.right  { transform: rotateY(90deg) translateZ(35px); }
    .die.d8 .die-face.left   { transform: rotateY(-90deg) translateZ(35px); }
    .die.d8 .die-face.top    { transform: rotateX(90deg) translateZ(35px); }
    .die.d8 .die-face.bottom { transform: rotateX(-90deg) translateZ(35px); }

    /* D4 Tetrahedron */
    .die.d4 {
      width: 70px;
      height: 70px;
    }

    .die.d4 .die-face {
      width: 70px;
      height: 70px;
      font-size: 1.5rem;
      color: #1a1a1a;
      background: linear-gradient(145deg, #ffcc80, #ff9800);
      clip-path: polygon(50% 0%, 100% 100%, 0% 100%);
      border: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .die.d4 .die-face.front  { transform: translateZ(35px) rotateX(19.5deg); }
    .die.d4 .die-face.back   { transform: rotateY(180deg) translateZ(35px) rotateX(19.5deg); }
    .die.d4 .die-face.right  { transform: rotateY(120deg) translateZ(35px) rotateX(19.5deg); }
    .die.d4 .die-face.left   { transform: rotateY(-120deg) translateZ(35px) rotateX(19.5deg); }

    /* Rolling glow effect */
    .die-container.rolling {
      filter: drop-shadow(0 20px 30px rgba(0,0,0,0.6)) drop-shadow(0 0 20px rgba(255,215,0,0.3));
    }

    /* Settled state */
    .die-container.settled .die {
      transition: transform 0.3s ease-out;
    }
    
    /* Result Display */
    #resultDisplay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }
    
    #resultDisplay.visible {
      opacity: 1;
    }
    
    #resultDisplay .result-value {
      font-family: 'Cinzel Decorative', serif;
      font-size: 12rem;
      font-weight: 900;
      color: #ffd700;
      text-shadow: 0 0 60px rgba(255, 215, 0, 0.8), 0 0 120px rgba(255, 215, 0, 0.4);
    }
    
    #resultDisplay .result-detail {
      font-size: 2rem;
      color: #b388ff;
      margin-top: -20px;
    }
    
    /* Hope/Fear Specific */
    #resultDisplay.hope .result-value {
      color: #ffd700;
      text-shadow: 0 0 60px rgba(255, 215, 0, 0.8);
    }
    
    #resultDisplay.fear .result-value {
      color: #b388ff;
      text-shadow: 0 0 60px rgba(179, 136, 255, 0.8);
    }

    #resultDisplay.critical .result-value {
      color: #00ff88;
      font-size: 5rem;
      text-shadow: 0 0 60px rgba(0, 255, 136, 0.8), 0 0 120px rgba(0, 255, 136, 0.4);
      animation: criticalPulse 0.5s ease-in-out infinite alternate;
    }

    @keyframes criticalPulse {
      from { transform: scale(1); }
      to { transform: scale(1.05); }
    }

    /* Title */
    #title {
      position: absolute;
      top: 20px;
      left: 30px;
    }
    
    #title h1 {
      font-family: 'Cinzel Decorative', serif;
      font-size: 2rem;
      background: linear-gradient(180deg, #ffd700, #b8860b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    /* NPC Portrait Display */
    #npcPortrait {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.6s ease, visibility 0.6s ease;
      z-index: 100;
      pointer-events: none;
    }

    #npcPortrait.visible {
      opacity: 1;
      visibility: visible;
    }

    .npc-frame {
      position: relative;
      padding: 12px;
      background: linear-gradient(145deg, #2a1a35, #1a0d24);
      border-radius: 16px;
      box-shadow:
        0 0 40px rgba(123, 45, 142, 0.4),
        0 0 80px rgba(75, 0, 130, 0.2),
        inset 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .npc-frame::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 16px;
      padding: 3px;
      background: linear-gradient(145deg, #ffd700, #b8860b, #7c4dff, #b388ff);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
    }

    .npc-frame::after {
      content: '';
      position: absolute;
      inset: 6px;
      border-radius: 12px;
      padding: 2px;
      background: linear-gradient(145deg, rgba(255, 215, 0, 0.3), rgba(179, 136, 255, 0.3));
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
    }

    .npc-inner-frame {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      background: #0d0610;
    }

    #npcImage {
      display: block;
      max-width: 70vw;
      max-height: 65vh;
      min-width: 300px;
      min-height: 300px;
      width: auto;
      height: auto;
      object-fit: contain;
      border-radius: 6px;
    }

    /* Ensure SVG/default images scale properly */
    #npcImage[src^="data:image/svg"] {
      width: 50vw;
      height: 50vh;
      min-width: 400px;
      min-height: 400px;
    }

    /* Corner decorations */
    .npc-corner {
      position: absolute;
      width: 24px;
      height: 24px;
      z-index: 10;
    }

    .npc-corner svg {
      width: 100%;
      height: 100%;
      fill: #ffd700;
      filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.6));
    }

    .npc-corner.top-left { top: -4px; left: -4px; }
    .npc-corner.top-right { top: -4px; right: -4px; transform: rotate(90deg); }
    .npc-corner.bottom-right { bottom: -4px; right: -4px; transform: rotate(180deg); }
    .npc-corner.bottom-left { bottom: -4px; left: -4px; transform: rotate(270deg); }

    /* Glow effect animation */
    @keyframes portraitGlow {
      0%, 100% { box-shadow: 0 0 40px rgba(123, 45, 142, 0.4), 0 0 80px rgba(75, 0, 130, 0.2), inset 0 0 30px rgba(0, 0, 0, 0.5); }
      50% { box-shadow: 0 0 50px rgba(123, 45, 142, 0.5), 0 0 100px rgba(75, 0, 130, 0.3), inset 0 0 30px rgba(0, 0, 0, 0.5); }
    }

    #npcPortrait.visible .npc-frame {
      animation: portraitGlow 3s ease-in-out infinite;
    }

    /* Defeated Stamp Overlay */
    .defeated-stamp {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-15deg);
      padding: 15px 40px;
      border: 6px solid #cc0000;
      border-radius: 12px;
      background: rgba(180, 0, 0, 0.15);
      color: #cc0000;
      font-family: 'Cinzel', serif;
      font-size: 3.5rem;
      font-weight: 900;
      letter-spacing: 8px;
      text-transform: uppercase;
      text-shadow:
        2px 2px 0 rgba(0, 0, 0, 0.5),
        -1px -1px 0 rgba(0, 0, 0, 0.3);
      box-shadow:
        0 0 20px rgba(200, 0, 0, 0.4),
        inset 0 0 20px rgba(200, 0, 0, 0.2);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.4s ease, visibility 0.4s ease;
      z-index: 200;
      pointer-events: none;
      white-space: nowrap;
    }

    .defeated-stamp.visible {
      opacity: 1;
      visibility: visible;
      animation: stampAppear 0.3s ease-out;
    }

    @keyframes stampAppear {
      0% {
        transform: translate(-50%, -50%) rotate(-15deg) scale(1.5);
        opacity: 0;
      }
      50% {
        transform: translate(-50%, -50%) rotate(-15deg) scale(0.95);
      }
      100% {
        transform: translate(-50%, -50%) rotate(-15deg) scale(1);
        opacity: 1;
      }
    }

    /* Red tint on defeated portrait */
    #npcPortrait.defeated .npc-inner-frame::after {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(100, 0, 0, 0.3);
      pointer-events: none;
      border-radius: 6px;
    }

    #npcPortrait.defeated .npc-frame {
      animation: none;
      box-shadow:
        0 0 40px rgba(150, 0, 0, 0.5),
        0 0 80px rgba(100, 0, 0, 0.3),
        inset 0 0 30px rgba(0, 0, 0, 0.5);
    }

    #npcPortrait.defeated .npc-frame::before {
      background: linear-gradient(145deg, #cc0000, #800000, #4a0000, #800000);
    }

    /* Condition Stamps */
    .condition-stamps {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 150;
      pointer-events: none;
    }

    .condition-stamp {
      padding: 8px 20px;
      border: 4px solid;
      border-radius: 8px;
      font-family: 'Cinzel', serif;
      font-size: 1.5rem;
      font-weight: 900;
      letter-spacing: 4px;
      text-transform: uppercase;
      text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      white-space: nowrap;
    }

    .condition-stamp.visible {
      opacity: 1;
      visibility: visible;
      animation: conditionAppear 0.3s ease-out;
    }

    @keyframes conditionAppear {
      0% {
        transform: scale(1.3);
        opacity: 0;
      }
      60% {
        transform: scale(0.95);
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Hidden Condition - Shadowy purple/blue */
    .condition-stamp.hidden-condition {
      border-color: #6a5acd;
      background: rgba(106, 90, 205, 0.2);
      color: #9370db;
      box-shadow: 0 0 15px rgba(106, 90, 205, 0.4), inset 0 0 15px rgba(106, 90, 205, 0.15);
    }

    /* Restrained Condition - Iron/chain gray */
    .condition-stamp.restrained-condition {
      border-color: #708090;
      background: rgba(112, 128, 144, 0.2);
      color: #b0c4de;
      box-shadow: 0 0 15px rgba(112, 128, 144, 0.4), inset 0 0 15px rgba(112, 128, 144, 0.15);
    }

    /* Vulnerable Condition - Warning yellow/gold */
    .condition-stamp.vulnerable-condition {
      border-color: #daa520;
      background: rgba(218, 165, 32, 0.2);
      color: #ffd700;
      box-shadow: 0 0 15px rgba(218, 165, 32, 0.4), inset 0 0 15px rgba(218, 165, 32, 0.15);
    }

    /* Condition Tint Overlays on Portrait */
    #npcPortrait.has-hidden .npc-inner-frame::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(106, 90, 205, 0.15);
      pointer-events: none;
      border-radius: 6px;
      z-index: 1;
    }

    #npcPortrait.has-restrained .npc-inner-frame::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(112, 128, 144, 0.15);
      pointer-events: none;
      border-radius: 6px;
      z-index: 1;
    }

    #npcPortrait.has-vulnerable .npc-inner-frame::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(218, 165, 32, 0.15);
      pointer-events: none;
      border-radius: 6px;
      z-index: 1;
    }

    /* Multiple conditions - combine effects */
    #npcPortrait.has-hidden.has-vulnerable .npc-inner-frame::before {
      background: linear-gradient(135deg, rgba(106, 90, 205, 0.15), rgba(218, 165, 32, 0.15));
    }

    #npcPortrait.has-hidden.has-restrained .npc-inner-frame::before {
      background: linear-gradient(135deg, rgba(106, 90, 205, 0.15), rgba(112, 128, 144, 0.15));
    }

    #npcPortrait.has-restrained.has-vulnerable .npc-inner-frame::before {
      background: linear-gradient(135deg, rgba(112, 128, 144, 0.15), rgba(218, 165, 32, 0.15));
    }

    /* Connection Status UI */
    #connectionStatus {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid rgba(179, 136, 255, 0.4);
      border-radius: 12px;
      padding: 16px 20px;
      z-index: 1000;
      font-family: 'Cinzel', serif;
      cursor: default;
      transition: all 0.3s ease;
    }

    #connectionStatus.connected {
      border-color: rgba(76, 175, 80, 0.6);
      background: rgba(0, 30, 0, 0.85);
    }

    #connectionStatus.minimized {
      padding: 8px 12px;
    }

    #connectionStatus.minimized .connection-details {
      display: none;
    }

    .connection-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    #connectionStatus.minimized .connection-header {
      margin-bottom: 0;
    }

    .connection-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff9800;
      animation: pulse 2s infinite;
    }

    #connectionStatus.connected .connection-indicator {
      background: #4caf50;
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .connection-title {
      font-size: 0.85rem;
      color: #b388ff;
    }

    #connectionStatus.connected .connection-title {
      color: #81c784;
    }

    .connection-details {
      margin-top: 8px;
    }

    .room-code-input {
      width: 100%;
      padding: 10px;
      margin: 8px 0;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.4);
      color: #ffd700;
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      font-weight: 700;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .room-code-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .room-code-input::placeholder {
      color: #555;
      font-weight: 400;
    }

    .connect-btn {
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .connect-btn:hover:not(:disabled) {
      transform: scale(1.02);
      filter: brightness(1.1);
    }

    .connect-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .connect-btn.connecting {
      background: linear-gradient(135deg, #ff9800, #e65100);
    }

    .room-code-label {
      font-size: 0.7rem;
      color: #888;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }

    .connected-info {
      font-size: 0.8rem;
      color: #81c784;
      text-align: center;
      padding: 10px 0;
    }

    .minimize-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      color: #888;
      cursor: pointer;
      font-size: 1rem;
      padding: 4px;
      line-height: 1;
    }

    .minimize-btn:hover {
      color: #b388ff;
    }
  </style>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <script>
    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyA6GYyYWlW1ybQ07-K13u4YUaNFcV66Zj0",
      authDomain: "daggerheart-8bdc1.firebaseapp.com",
      databaseURL: "https://daggerheart-8bdc1-default-rtdb.firebaseio.com",
      projectId: "daggerheart-8bdc1",
      storageBucket: "daggerheart-8bdc1.firebasestorage.app",
      messagingSenderId: "885297626381",
      appId: "1:885297626381:web:9caf2af85fb793f819c444"
    };

    // Initialize Firebase
    let firebaseApp = null;
    let database = null;

    try {
      firebaseApp = firebase.initializeApp(firebaseConfig);
      database = firebase.database();
      console.log('Firebase initialized successfully');
    } catch (e) {
      console.error('Firebase initialization error:', e);
    }
  </script>
</head>
<body>
  <!-- Connection Status -->
  <div id="connectionStatus">
    <button class="minimize-btn" onclick="toggleConnectionMinimize()">−</button>
    <div class="connection-header">
      <div class="connection-indicator"></div>
      <div class="connection-title">Enter GM Room Code</div>
    </div>
    <div class="connection-details">
      <div class="room-code-label">Room Code from GM Panel</div>
      <input type="text" id="roomCodeInput" class="room-code-input" placeholder="FIRE-DRAGON-00" maxlength="20" onkeyup="handleRoomCodeKeyup(event)">
      <button class="connect-btn" id="connectBtn" onclick="connectToGM()">Connect</button>
    </div>
  </div>

  <!-- Title -->
  <div id="title">
    <h1>DAGGERHEART</h1>
  </div>
  
  <!-- Fear Counter -->
  <div id="fearCounter">
    <div class="label">FEAR</div>
    <div class="value" id="fearValue">0</div>
  </div>
  
  <!-- Dice Animation Area -->
  <div id="diceArea"></div>
  
  <!-- Result Display -->
  <div id="resultDisplay">
    <div class="result-value" id="resultValue"></div>
    <div class="result-detail" id="resultDetail"></div>
  </div>

  <!-- NPC Portrait Display -->
  <div id="npcPortrait">
    <div class="npc-frame">
      <!-- Corner decorations -->
      <div class="npc-corner top-left">
        <svg viewBox="0 0 24 24"><path d="M2 2 L2 14 L4 14 L4 4 L14 4 L14 2 Z M6 6 L6 10 L10 10 L10 6 Z"/></svg>
      </div>
      <div class="npc-corner top-right">
        <svg viewBox="0 0 24 24"><path d="M2 2 L2 14 L4 14 L4 4 L14 4 L14 2 Z M6 6 L6 10 L10 10 L10 6 Z"/></svg>
      </div>
      <div class="npc-corner bottom-right">
        <svg viewBox="0 0 24 24"><path d="M2 2 L2 14 L4 14 L4 4 L14 4 L14 2 Z M6 6 L6 10 L10 10 L10 6 Z"/></svg>
      </div>
      <div class="npc-corner bottom-left">
        <svg viewBox="0 0 24 24"><path d="M2 2 L2 14 L4 14 L4 4 L14 4 L14 2 Z M6 6 L6 10 L10 10 L10 6 Z"/></svg>
      </div>
      <div class="npc-inner-frame">
        <img id="npcImage" src="" alt="NPC Portrait">
      </div>
    </div>
    <!-- Defeated Stamp -->
    <div id="defeatedStamp" class="defeated-stamp">DEFEATED</div>
    <!-- Condition Stamps -->
    <div class="condition-stamps">
      <div id="hiddenStamp" class="condition-stamp hidden-condition">HIDDEN</div>
      <div id="restrainedStamp" class="condition-stamp restrained-condition">RESTRAINED</div>
      <div id="vulnerableStamp" class="condition-stamp vulnerable-condition">VULNERABLE</div>
    </div>
  </div>
  
  <!-- Fear Tracker Pike -->
  <div id="fearTracker">
    <div class="pike-container">
      <div class="pike-labels">
        <span class="hope">✦ HOPE ✦</span>
        <span class="fear-label">✦ FEAR ✦</span>
      </div>
      <div class="pike-point-left"></div>
      <div class="pike"></div>
      <div class="pike-point-right"></div>
      <div id="skulls"></div>
    </div>
  </div>

  <script>
    // Skull SVG generator
    function createSkullSVG(level, isActive) {
      const baseColor = isActive ? '#e8d5ff' : '#f5f0e6';
      const shadowColor = isActive ? '#6b3d7a' : '#a09080';
      const highlightColor = isActive ? '#fff' : '#fffef8';
      const boneColor = isActive ? '#d4c4e8' : '#e8e0d4';
      
      const eyeAnger = Math.min(level * 1.5, 15);
      const jawOpen = level > 6 ? (level - 6) * 1.5 : 0;
      const teethSharpness = level > 3 ? Math.min((level - 3) * 0.5, 3) : 0;
      const crackOpacity = level > 4 ? Math.min((level - 4) * 0.12, 0.7) : 0;
      const hornLength = level > 9 ? (level - 9) * 6 : 0;
      const eyeGlow = level > 7 || isActive;
      const flameEyes = level > 10;
      
      let svg = `<svg viewBox="0 0 40 50" style="width:100%;height:100%;overflow:visible">
        <defs>
          <radialGradient id="skullMain-${level}-${isActive}" cx="40%" cy="30%" r="60%">
            <stop offset="0%" stop-color="${highlightColor}"/>
            <stop offset="60%" stop-color="${baseColor}"/>
            <stop offset="100%" stop-color="${shadowColor}"/>
          </radialGradient>
          <radialGradient id="jawGrad-${level}-${isActive}" cx="50%" cy="20%" r="70%">
            <stop offset="0%" stop-color="${baseColor}"/>
            <stop offset="100%" stop-color="${shadowColor}"/>
          </radialGradient>
          <radialGradient id="eyeGlow-${level}" cx="50%" cy="50%" r="50%">
            <stop offset="0%" stop-color="${isActive ? '#b388ff' : '#ff6b35'}"/>
            <stop offset="100%" stop-color="${isActive ? '#7c4dff' : '#d32f2f'}"/>
          </radialGradient>
        </defs>`;
      
      // Horns
      if (hornLength > 0) {
        svg += `<path d="M8,8 Q2,${4-hornLength*0.5} 4,${-hornLength}" fill="none" stroke="${isActive ? '#4a3050' : '#3d3530'}" stroke-width="4" stroke-linecap="round"/>`;
        svg += `<path d="M32,8 Q38,${4-hornLength*0.5} 36,${-hornLength}" fill="none" stroke="${isActive ? '#4a3050' : '#3d3530'}" stroke-width="4" stroke-linecap="round"/>`;
      }
      
      // Cranium
      svg += `<ellipse cx="20" cy="18" rx="16" ry="17" fill="url(#skullMain-${level}-${isActive})" stroke="${shadowColor}" stroke-width="0.5"/>`;
      
      // Cheekbones
      svg += `<ellipse cx="8" cy="26" rx="5" ry="4" fill="${boneColor}" opacity="0.5"/>`;
      svg += `<ellipse cx="32" cy="26" rx="5" ry="4" fill="${boneColor}" opacity="0.5"/>`;
      
      // Brow ridge
      svg += `<path d="M6,14 Q12,${12-eyeAnger*0.3} 20,14 Q28,${12-eyeAnger*0.3} 34,14" fill="none" stroke="${shadowColor}" stroke-width="2" stroke-linecap="round" opacity="0.6"/>`;
      
      // Eye sockets
      svg += `<ellipse cx="12" cy="20" rx="5" ry="6" fill="#1a1015" transform="rotate(${-eyeAnger}, 12, 20)"/>`;
      svg += `<ellipse cx="28" cy="20" rx="5" ry="6" fill="#1a1015" transform="rotate(${eyeAnger}, 28, 20)"/>`;
      
      // Eye glow
      if (eyeGlow && !flameEyes) {
        svg += `<ellipse cx="12" cy="20" rx="3" ry="4" fill="url(#eyeGlow-${level})" opacity="0.8"><animate attributeName="opacity" values="0.6;0.9;0.6" dur="2s" repeatCount="indefinite"/></ellipse>`;
        svg += `<ellipse cx="28" cy="20" rx="3" ry="4" fill="url(#eyeGlow-${level})" opacity="0.8"><animate attributeName="opacity" values="0.6;0.9;0.6" dur="2s" repeatCount="indefinite"/></ellipse>`;
      }
      
      // Flame eyes
      if (flameEyes) {
        svg += `<ellipse cx="12" cy="18" rx="4" ry="7" fill="#ff4500" opacity="0.9"><animate attributeName="ry" values="6;8;6" dur="0.2s" repeatCount="indefinite"/></ellipse>`;
        svg += `<ellipse cx="12" cy="18" rx="2" ry="5" fill="#ffff00" opacity="0.8"><animate attributeName="ry" values="4;6;4" dur="0.15s" repeatCount="indefinite"/></ellipse>`;
        svg += `<ellipse cx="28" cy="18" rx="4" ry="7" fill="#ff4500" opacity="0.9"><animate attributeName="ry" values="6;8;6" dur="0.2s" repeatCount="indefinite"/></ellipse>`;
        svg += `<ellipse cx="28" cy="18" rx="2" ry="5" fill="#ffff00" opacity="0.8"><animate attributeName="ry" values="4;6;4" dur="0.15s" repeatCount="indefinite"/></ellipse>`;
      }
      
      // Nose
      svg += `<path d="M20,26 L17,32 L20,31 L23,32 Z" fill="#1a1015"/>`;
      
      // Jaws
      svg += `<path d="M8,30 Q20,${34+jawOpen*0.3} 32,30 L32,36 Q20,38 8,36 Z" fill="url(#jawGrad-${level}-${isActive})" stroke="${shadowColor}" stroke-width="0.5"/>`;
      svg += `<path d="M10,${36+jawOpen} Q20,${42+jawOpen*1.2} 30,${36+jawOpen} L28,${40+jawOpen} Q20,${44+jawOpen*1.3} 12,${40+jawOpen} Z" fill="url(#jawGrad-${level}-${isActive})" stroke="${shadowColor}" stroke-width="0.5"/>`;
      
      // Teeth
      for (let i = 0; i < 6; i++) {
        const x = 11 + i * 3;
        const height = 3 + teethSharpness + ((i === 1 || i === 4) ? teethSharpness * 0.5 : 0);
        svg += `<path d="M${x},35 L${x + 1.5},${35 + height} L${x + 3},35" fill="${highlightColor}" stroke="${shadowColor}" stroke-width="0.3"/>`;
      }
      for (let i = 0; i < 5; i++) {
        const x = 12.5 + i * 3;
        const height = 2 + teethSharpness * 0.7;
        svg += `<path d="M${x},${37+jawOpen} L${x + 1.5},${37+jawOpen - height} L${x + 3},${37+jawOpen}" fill="${highlightColor}" stroke="${shadowColor}" stroke-width="0.3"/>`;
      }
      
      // Cracks
      if (crackOpacity > 0) {
        svg += `<path d="M14,6 L16,12 L14,15" fill="none" stroke="#2a2020" stroke-width="0.8" opacity="${crackOpacity}"/>`;
        svg += `<path d="M16,12 L18,14" fill="none" stroke="#2a2020" stroke-width="0.5" opacity="${crackOpacity}"/>`;
        svg += `<path d="M26,8 L24,13 L26,16" fill="none" stroke="#2a2020" stroke-width="0.8" opacity="${crackOpacity * 0.8}"/>`;
      }
      
      // Pike hole
      svg += `<ellipse cx="20" cy="24" rx="2.5" ry="1.5" fill="#1a1015"/>`;
      svg += `<ellipse cx="20" cy="24" rx="2" ry="1" fill="#0d0a0a"/>`;
      
      // Smile for friendly skulls
      if (level <= 2) {
        svg += `<path d="M14,${38+jawOpen} Q20,${41+jawOpen} 26,${38+jawOpen}" fill="none" stroke="${shadowColor}" stroke-width="1" stroke-linecap="round" opacity="0.5"/>`;
      }
      
      svg += `</svg>`;
      return svg;
    }
    
    // Initialize skulls
    function initSkulls() {
      const container = document.getElementById('skulls');
      container.innerHTML = '';
      
      for (let i = 0; i < 12; i++) {
        const skull = document.createElement('div');
        skull.className = 'skull';
        skull.id = `skull-${i}`;
        skull.innerHTML = createSkullSVG(12 - i, false);
        skull.style.left = `${(30 + (i * 4))}px`;
        skull.style.filter = `drop-shadow(0 0 6px rgba(255, 215, 0, 0.3))`;
        container.appendChild(skull);
      }
    }
    
    // Update fear display
    function updateFear(fearCount) {
      console.log('updateFear called with:', fearCount);
      // Update counter
      const counter = document.getElementById('fearValue');
      console.log('fearValue element:', counter);
      counter.textContent = fearCount;
      counter.style.color = fearCount > 8 ? '#ff4444' : fearCount > 4 ? '#b388ff' : '#ffd700';
      counter.style.textShadow = `0 0 30px ${fearCount > 8 ? 'rgba(255,68,68,0.6)' : fearCount > 4 ? 'rgba(179,136,255,0.6)' : 'rgba(255,215,0,0.5)'}`;

      // Update skulls
      const pikeContainer = document.querySelector('.pike-container');
      const pikeWidth = pikeContainer.offsetWidth - 80; // Account for points

      for (let i = 0; i < 12; i++) {
        const skull = document.getElementById(`skull-${i}`);
        // Rightmost skull (index 11) moves first, then 10, 9, etc.
        // When fearCount=1, skull 11 is active
        // When fearCount=2, skulls 11 and 10 are active
        const isActive = i >= (12 - fearCount);
        const spacing = pikeWidth / 24;

        // Hope side: left half, Fear side: right half
        const hopePos = 40 + (i * spacing);
        const fearPos = (pikeWidth / 2) + 40 + (i * spacing);

        skull.style.left = `${isActive ? fearPos : hopePos}px`;
        skull.innerHTML = createSkullSVG(12 - i, isActive);
        skull.style.filter = `drop-shadow(0 0 ${isActive ? 12 : 6}px ${isActive ? 'rgba(179, 136, 255, 0.6)' : 'rgba(255, 215, 0, 0.3)'})`;
      }
    }
    
    // Create 3D die HTML with all faces
    function create3DDie(sides, extraClass = '') {
      const container = document.createElement('div');
      container.className = 'die-container rolling';

      const die = document.createElement('div');
      die.className = `die d${sides} ${extraClass}`;

      if (sides === 6) {
        // D6 with pips
        const faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];
        const faceValues = [1, 6, 3, 4, 2, 5]; // Opposite faces sum to 7

        faces.forEach((faceName, idx) => {
          const face = document.createElement('div');
          face.className = `die-face ${faceName}`;
          face.appendChild(createPips(faceValues[idx]));
          face.dataset.value = faceValues[idx];
          die.appendChild(face);
        });
      } else {
        // Other dice with numbers on faces
        const faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];
        const faceCount = sides === 4 ? 4 : 6;

        for (let i = 0; i < faceCount; i++) {
          const face = document.createElement('div');
          face.className = `die-face ${faces[i] || 'extra'}`;
          face.textContent = '?';
          face.dataset.value = (i % sides) + 1;
          die.appendChild(face);
        }
      }

      container.appendChild(die);
      return container;
    }

    // Create pip pattern for d6 faces
    function createPips(value) {
      const container = document.createElement('div');
      container.className = 'pip-container';

      // Grid positions: 0-8 for 3x3 grid
      const patterns = {
        1: [4],
        2: [0, 8],
        3: [0, 4, 8],
        4: [0, 2, 6, 8],
        5: [0, 2, 4, 6, 8],
        6: [0, 2, 3, 5, 6, 8]
      };

      const positions = patterns[value] || [];

      for (let i = 0; i < 9; i++) {
        const pip = document.createElement('div');
        pip.className = positions.includes(i) ? 'pip' : 'pip hidden';
        container.appendChild(pip);
      }

      return container;
    }

    // Update die faces with random or final values
    function updateDieFaces(die, value, sides, isRolling = false) {
      const faces = die.querySelectorAll('.die-face');

      if (sides === 6) {
        // D6 uses pips, no text update needed during rolling
        return;
      }

      faces.forEach((face, idx) => {
        if (isRolling) {
          face.textContent = Math.floor(Math.random() * sides) + 1;
        } else {
          // Show value on front face, complementary values on others
          if (idx === 0) {
            face.textContent = value;
          } else {
            face.textContent = ((value + idx - 1) % sides) + 1;
          }
        }
      });
    }

    // Get final rotation to show result
    function getFinalRotation(result, sides) {
      // Calculate rotation to show the result on top
      if (sides === 6) {
        // For d6 with pips, map result to correct face orientation
        const rotations = {
          1: { x: 0, y: 0 },
          2: { x: -90, y: 0 },
          3: { x: 0, y: -90 },
          4: { x: 0, y: 90 },
          5: { x: 90, y: 0 },
          6: { x: 180, y: 0 }
        };
        return rotations[result] || { x: 0, y: 0 };
      }

      // For other dice, use front face (rotateX and Y to 0)
      return { x: 0, y: 0 };
    }

    // Animate dice roll
    function animateDiceRoll(diceData) {
      const area = document.getElementById('diceArea');
      const resultDisplay = document.getElementById('resultDisplay');
      const resultValue = document.getElementById('resultValue');
      const resultDetail = document.getElementById('resultDetail');

      // Clear previous
      area.innerHTML = '';
      resultDisplay.classList.remove('visible', 'hope', 'fear');

      if (diceData.type === 'hopefear') {
        // Hope/Fear roll - two dice
        animateHopeFearRoll(diceData);
        return;
      }

      // Handle both legacy 'standard' format and new 'notation' format
      let allResults = [];
      let allSides = [];

      if (diceData.type === 'notation' && diceData.diceRolls) {
        // New notation format with multiple dice types
        diceData.diceRolls.forEach(roll => {
          roll.results.forEach(result => {
            allResults.push(result);
            allSides.push(roll.sides);
          });
        });
      } else if (diceData.results) {
        // Legacy standard format
        allResults = diceData.results;
        allSides = diceData.results.map(() => diceData.sides);
      }

      if (allResults.length === 0) return;

      const dice = [];

      for (let i = 0; i < allResults.length; i++) {
        const container = create3DDie(allSides[i]);
        const dieEl = container.querySelector('.die');

        // Random starting position (off screen)
        const startSide = Math.random() > 0.5 ? -1 : 1;
        container.style.left = startSide > 0 ? '-120px' : (window.innerWidth + 120) + 'px';
        container.style.top = (Math.random() * (window.innerHeight * 0.3) + 100) + 'px';

        area.appendChild(container);

        dice.push({
          container: container,
          die: dieEl,
          x: parseFloat(container.style.left),
          y: parseFloat(container.style.top),
          vx: startSide > 0 ? (12 + Math.random() * 8) : -(12 + Math.random() * 8),
          vy: -3 + Math.random() * 6,
          rotX: Math.random() * 360,
          rotY: Math.random() * 360,
          rotZ: Math.random() * 360,
          vrX: (Math.random() - 0.5) * 25,
          vrY: (Math.random() - 0.5) * 25,
          vrZ: (Math.random() - 0.5) * 15,
          result: allResults[i],
          sides: allSides[i],
          settled: false,
          settleFrame: 0
        });
      }

      const gravity = 0.4;
      const friction = 0.985;
      const bounceFactor = 0.55;
      const floor = window.innerHeight * 0.55;
      let settleTime = 0;

      function animate() {
        let allSettled = true;

        dice.forEach(d => {
          if (d.settled && d.settleFrame > 30) return;

          // Physics
          d.vy += gravity;
          d.x += d.vx;
          d.y += d.vy;

          // 3D rotation
          d.rotX += d.vrX;
          d.rotY += d.vrY;
          d.rotZ += d.vrZ;

          // Bounce off floor
          if (d.y > floor) {
            d.y = floor;
            d.vy *= -bounceFactor;
            d.vx *= friction;
            d.vrX *= 0.7;
            d.vrY *= 0.7;
            d.vrZ *= 0.7;

            // Add some random spin on bounce
            d.vrX += (Math.random() - 0.5) * 5;
            d.vrY += (Math.random() - 0.5) * 5;
          }

          // Bounce off walls
          if (d.x < 80) {
            d.x = 80;
            d.vx *= -bounceFactor;
            d.vrY += (Math.random() - 0.5) * 10;
          }
          if (d.x > window.innerWidth - 80) {
            d.x = window.innerWidth - 80;
            d.vx *= -bounceFactor;
            d.vrY += (Math.random() - 0.5) * 10;
          }

          // Apply friction
          d.vx *= friction;
          d.vrX *= 0.99;
          d.vrY *= 0.99;
          d.vrZ *= 0.99;

          // Check if settled
          const isSettling = Math.abs(d.vy) < 2 && Math.abs(d.vx) < 1 && d.y >= floor - 5;

          if (isSettling && !d.settled) {
            d.settled = true;
            d.container.classList.remove('rolling');
            d.container.classList.add('settled');

            // Calculate final rotation to show result
            const finalRot = getFinalRotation(d.result, d.sides);
            d.targetRotX = finalRot.x;
            d.targetRotY = finalRot.y;

            // Update die faces with final values
            updateDieFaces(d.die, d.result, d.sides, false);
          }

          if (d.settled) {
            d.settleFrame++;
            // Smoothly interpolate to final rotation
            d.rotX += (d.targetRotX - (d.rotX % 360)) * 0.15;
            d.rotY += (d.targetRotY - (d.rotY % 360)) * 0.15;
            d.rotZ *= 0.85;
            d.vrX = 0;
            d.vrY = 0;
            d.vrZ = 0;
          } else {
            allSettled = false;
            // Update die faces with random values while rolling
            if (Math.random() > 0.7) {
              updateDieFaces(d.die, d.result, d.sides, true);
            }
          }

          // Update position and rotation
          d.container.style.left = d.x + 'px';
          d.container.style.top = d.y + 'px';
          d.die.style.transform = `rotateX(${d.rotX}deg) rotateY(${d.rotY}deg) rotateZ(${d.rotZ}deg)`;
        });

        if (!allSettled || settleTime < 60) {
          if (allSettled) settleTime++;
          requestAnimationFrame(animate);
        } else {
          // Show final result
          setTimeout(() => {
            // Fade out dice slightly
            dice.forEach(d => d.container.style.opacity = '0.4');

            // Show result - use notation format if available
            resultValue.textContent = diceData.total;
            if (diceData.notation) {
              resultDetail.textContent = diceData.notation;
            } else if (diceData.count > 1) {
              resultDetail.textContent = `${diceData.results.join(' + ')}`;
            } else {
              resultDetail.textContent = `d${diceData.sides}`;
            }
            resultDisplay.classList.add('visible');

            // Hide after delay
            setTimeout(() => {
              resultDisplay.classList.remove('visible');
              setTimeout(() => { area.innerHTML = ''; }, 500);
            }, 3000);
          }, 300);
        }
      }

      requestAnimationFrame(animate);
    }
    
    // Hope/Fear roll animation
    function animateHopeFearRoll(data) {
      const area = document.getElementById('diceArea');
      const resultDisplay = document.getElementById('resultDisplay');
      const resultValue = document.getElementById('resultValue');
      const resultDetail = document.getElementById('resultDetail');

      // Create two 3D d12 dice - hope (gold) and fear (purple)
      const hopeContainer = create3DDie(12, 'hope');
      const fearContainer = create3DDie(12, 'fear');

      hopeContainer.style.left = '-120px';
      hopeContainer.style.top = '180px';

      fearContainer.style.left = (window.innerWidth + 120) + 'px';
      fearContainer.style.top = '180px';

      area.appendChild(hopeContainer);
      area.appendChild(fearContainer);

      const dice = [
        {
          container: hopeContainer,
          die: hopeContainer.querySelector('.die'),
          x: -120,
          y: 180,
          vx: 14,
          vy: -2,
          rotX: Math.random() * 360,
          rotY: Math.random() * 360,
          rotZ: Math.random() * 360,
          vrX: 18,
          vrY: 12,
          vrZ: 8,
          result: data.hope,
          type: 'hope',
          sides: 12,
          settled: false,
          settleFrame: 0
        },
        {
          container: fearContainer,
          die: fearContainer.querySelector('.die'),
          x: window.innerWidth + 120,
          y: 180,
          vx: -14,
          vy: -2,
          rotX: Math.random() * 360,
          rotY: Math.random() * 360,
          rotZ: Math.random() * 360,
          vrX: -18,
          vrY: -12,
          vrZ: -8,
          result: data.fear,
          type: 'fear',
          sides: 12,
          settled: false,
          settleFrame: 0
        }
      ];

      const gravity = 0.4;
      const friction = 0.985;
      const bounceFactor = 0.55;
      const floor = window.innerHeight * 0.55;
      let settleTime = 0;

      function animate() {
        let allSettled = true;

        dice.forEach(d => {
          if (d.settled && d.settleFrame > 30) return;

          // Physics
          d.vy += gravity;
          d.x += d.vx;
          d.y += d.vy;

          // 3D rotation
          d.rotX += d.vrX;
          d.rotY += d.vrY;
          d.rotZ += d.vrZ;

          // Bounce off floor
          if (d.y > floor) {
            d.y = floor;
            d.vy *= -bounceFactor;
            d.vx *= friction;
            d.vrX *= 0.7;
            d.vrY *= 0.7;
            d.vrZ *= 0.7;

            d.vrX += (Math.random() - 0.5) * 5;
            d.vrY += (Math.random() - 0.5) * 5;
          }

          // Bounce off walls
          if (d.x < 100) {
            d.x = 100;
            d.vx *= -bounceFactor;
            d.vrY += (Math.random() - 0.5) * 10;
          }
          if (d.x > window.innerWidth - 100) {
            d.x = window.innerWidth - 100;
            d.vx *= -bounceFactor;
            d.vrY += (Math.random() - 0.5) * 10;
          }

          // Apply friction
          d.vx *= friction;
          d.vrX *= 0.99;
          d.vrY *= 0.99;
          d.vrZ *= 0.99;

          // Check if settled
          const isSettling = Math.abs(d.vy) < 2 && Math.abs(d.vx) < 1 && d.y >= floor - 5;

          if (isSettling && !d.settled) {
            d.settled = true;
            d.container.classList.remove('rolling');
            d.container.classList.add('settled');

            // Calculate final rotation
            const finalRot = getFinalRotation(d.result, d.sides);
            d.targetRotX = finalRot.x;
            d.targetRotY = finalRot.y;

            // Update die faces
            updateDieFaces(d.die, d.result, d.sides, false);
          }

          if (d.settled) {
            d.settleFrame++;
            d.rotX += (d.targetRotX - (d.rotX % 360)) * 0.15;
            d.rotY += (d.targetRotY - (d.rotY % 360)) * 0.15;
            d.rotZ *= 0.85;
            d.vrX = 0;
            d.vrY = 0;
            d.vrZ = 0;
          } else {
            allSettled = false;
            if (Math.random() > 0.7) {
              updateDieFaces(d.die, d.result, d.sides, true);
            }
          }

          // Update position and rotation
          d.container.style.left = d.x + 'px';
          d.container.style.top = d.y + 'px';
          d.die.style.transform = `rotateX(${d.rotX}deg) rotateY(${d.rotY}deg) rotateZ(${d.rotZ}deg)`;
        });

        if (!allSettled || settleTime < 60) {
          if (allSettled) settleTime++;
          requestAnimationFrame(animate);
        } else {
          setTimeout(() => {
            dice.forEach(d => d.container.style.opacity = '0.4');

            if (data.critical) {
              resultValue.textContent = 'Critical Success!';
              resultDetail.textContent = `Doubles! (${data.hope} + ${data.fear})`;
              resultDisplay.classList.add('visible', 'critical');
            } else {
              resultValue.textContent = data.sum;
              resultDetail.textContent = `with ${data.winner} (${data.hope} + ${data.fear})`;
              resultDisplay.classList.add('visible', data.winner.toLowerCase());
            }

            setTimeout(() => {
              resultDisplay.classList.remove('visible', 'hope', 'fear', 'critical');
              setTimeout(() => { area.innerHTML = ''; }, 500);
            }, 4000);
          }, 300);
        }
      }

      requestAnimationFrame(animate);
    }
    
    // Listen for updates from GM panel
    // Initialize timestamps from localStorage to prevent triggering animations on page refresh
    let lastDiceTimestamp = (() => {
      const data = localStorage.getItem('daggerheart-dice');
      return data ? (JSON.parse(data).timestamp || 0) : 0;
    })();
    let lastNpcTimestamp = (() => {
      const data = localStorage.getItem('daggerheart-npc');
      return data ? (JSON.parse(data).timestamp || 0) : 0;
    })();
    let lastSpotlightTimestamp = (() => {
      const data = localStorage.getItem('daggerheart-spotlight');
      return data ? (JSON.parse(data).timestamp || 0) : 0;
    })();
    let currentNpcVisible = false;
    let currentSpotlightVisible = false;

    // Firebase connection state
    let roomRef = null;
    let clientId = 'player-' + Math.random().toString(36).substr(2, 9);
    let firebaseConnected = false;

    // Heartbeat and reconnection configuration
    const HEARTBEAT_TIMEOUT = 45000; // Consider connection dead after 45 seconds without heartbeat
    const RECONNECT_BASE_DELAY = 2000; // Base delay for exponential backoff (2 seconds)
    const MAX_RECONNECT_DELAY = 30000; // Max delay between reconnection attempts (30 seconds)
    let lastHeartbeatReceived = Date.now();
    let heartbeatCheckIntervalId = null;
    let reconnectAttempts = 0;
    let reconnectTimeoutId = null;
    let savedRoomCode = null; // Store room code for reconnection

    // Default silhouette image for fallback
    const DEFAULT_SILHOUETTE = `data:image/svg+xml,${encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
        <defs>
          <radialGradient id="shadowGrad" cx="50%" cy="40%" r="50%">
            <stop offset="0%" stop-color="#2a1a35"/>
            <stop offset="100%" stop-color="#0d0610"/>
          </radialGradient>
        </defs>
        <rect width="200" height="200" fill="url(#shadowGrad)"/>
        <circle cx="100" cy="60" r="35" fill="#15151f" opacity="0.7"/>
        <path d="M100 25 C70 25 55 50 55 80 C55 100 70 110 100 110 C130 110 145 100 145 80 C145 50 130 25 100 25" fill="#15151f" opacity="0.7"/>
        <path d="M50 200 L50 130 C50 100 70 90 100 90 C130 90 150 100 150 130 L150 200 Z" fill="#15151f" opacity="0.7"/>
        <text x="100" y="120" font-family="serif" font-size="48" fill="#6b5b95" text-anchor="middle" opacity="0.6">?</text>
      </svg>
    `)}`;

    // Track current images to avoid unnecessary updates
    let currentNpcImage = '';
    let currentSpotlightImage = '';

    // Update NPC portrait display
    function updateNpcPortrait(npcData) {
      // Don't show NPC portrait if spotlight is active
      if (currentSpotlightVisible) return;

      const portrait = document.getElementById('npcPortrait');
      const npcImage = document.getElementById('npcImage');

      if (npcData && npcData.visible && npcData.image) {
        // Show the portrait - only update if image changed
        if (currentNpcImage !== npcData.image) {
          currentNpcImage = npcData.image;
          npcImage.onerror = function() {
            console.error('Failed to load NPC image, using fallback');
            npcImage.src = DEFAULT_SILHOUETTE;
          };
          npcImage.src = npcData.image;
        }
        if (!currentNpcVisible) {
          portrait.classList.add('visible');
          currentNpcVisible = true;
        }
      } else {
        // Hide the portrait
        if (currentNpcVisible) {
          portrait.classList.remove('visible');
          currentNpcVisible = false;
          currentNpcImage = ''; // Reset so image can be shown again
        }
      }
    }

    // Update spotlight display (from encounters)
    function updateSpotlight(spotlightData) {
      const portrait = document.getElementById('npcPortrait');
      const npcImage = document.getElementById('npcImage');
      const defeatedStamp = document.getElementById('defeatedStamp');
      const hiddenStamp = document.getElementById('hiddenStamp');
      const restrainedStamp = document.getElementById('restrainedStamp');
      const vulnerableStamp = document.getElementById('vulnerableStamp');

      if (spotlightData && spotlightData.visible && spotlightData.image) {
        // Show the spotlighted adversary
        // Only update src if the image actually changed (compare by reference/content hash)
        if (currentSpotlightImage !== spotlightData.image) {
          currentSpotlightImage = spotlightData.image;
          npcImage.onerror = function() {
            // Fall back to default silhouette if image fails to load
            console.error('Failed to load spotlight image, using fallback');
            npcImage.src = DEFAULT_SILHOUETTE;
          };
          npcImage.src = spotlightData.image;
        }
        if (!currentSpotlightVisible) {
          portrait.classList.add('visible');
          currentSpotlightVisible = true;
          // Hide NPC portrait state since spotlight takes priority
          currentNpcVisible = false;
        }

        // Handle defeated state
        if (spotlightData.defeated) {
          portrait.classList.add('defeated');
          defeatedStamp.classList.add('visible');
        } else {
          portrait.classList.remove('defeated');
          defeatedStamp.classList.remove('visible');
        }

        // Handle conditions
        const conditions = spotlightData.conditions || {};

        // Hidden condition
        if (conditions.hidden) {
          portrait.classList.add('has-hidden');
          hiddenStamp.classList.add('visible');
        } else {
          portrait.classList.remove('has-hidden');
          hiddenStamp.classList.remove('visible');
        }

        // Restrained condition
        if (conditions.restrained) {
          portrait.classList.add('has-restrained');
          restrainedStamp.classList.add('visible');
        } else {
          portrait.classList.remove('has-restrained');
          restrainedStamp.classList.remove('visible');
        }

        // Vulnerable condition
        if (conditions.vulnerable) {
          portrait.classList.add('has-vulnerable');
          vulnerableStamp.classList.add('visible');
        } else {
          portrait.classList.remove('has-vulnerable');
          vulnerableStamp.classList.remove('visible');
        }
      } else {
        // Hide the spotlight
        if (currentSpotlightVisible) {
          portrait.classList.remove('visible', 'defeated', 'has-hidden', 'has-restrained', 'has-vulnerable');
          defeatedStamp.classList.remove('visible');
          hiddenStamp.classList.remove('visible');
          restrainedStamp.classList.remove('visible');
          vulnerableStamp.classList.remove('visible');
          currentSpotlightVisible = false;
          currentSpotlightImage = ''; // Reset so image can be shown again

          // Check if NPC portrait should be shown instead
          const npcData = localStorage.getItem('daggerheart-npc');
          if (npcData) {
            const parsed = JSON.parse(npcData);
            if (parsed.visible && parsed.image) {
              currentNpcImage = parsed.image;
              npcImage.onerror = function() {
                console.error('Failed to load NPC image, using fallback');
                npcImage.src = DEFAULT_SILHOUETTE;
              };
              npcImage.src = parsed.image;
              portrait.classList.add('visible');
              currentNpcVisible = true;
            }
          }
        }
      }
    }

    function checkForUpdates() {
      // Skip localStorage polling when Gun.js is actually connected and working
      // Use localStorage when in local mode or when Gun.js hasn't connected yet
      if (gunConnected && !useLocalMode) {
        return;
      }

      // Check fear
      const fear = parseInt(localStorage.getItem('daggerheart-fear')) || 0;
      updateFear(fear);

      // Check for dice roll
      const diceData = localStorage.getItem('daggerheart-dice');
      if (diceData) {
        const parsed = JSON.parse(diceData);
        if (parsed.timestamp > lastDiceTimestamp) {
          lastDiceTimestamp = parsed.timestamp;
          animateDiceRoll(parsed);
        }
      }

      // Check for spotlight updates (from encounters) - takes priority over NPC portrait
      const spotlightData = localStorage.getItem('daggerheart-spotlight');
      if (spotlightData) {
        const parsed = JSON.parse(spotlightData);
        if (parsed.timestamp > lastSpotlightTimestamp || parsed.visible !== currentSpotlightVisible) {
          lastSpotlightTimestamp = parsed.timestamp;
          updateSpotlight(parsed);
        }
      }

      // Check for NPC portrait updates (only if spotlight is not active)
      if (!currentSpotlightVisible) {
        const npcData = localStorage.getItem('daggerheart-npc');
        if (npcData) {
          const parsed = JSON.parse(npcData);
          if (parsed.timestamp > lastNpcTimestamp || parsed.visible !== currentNpcVisible) {
            lastNpcTimestamp = parsed.timestamp;
            updateNpcPortrait(parsed);
          }
        } else {
          // No NPC data, ensure portrait is hidden
          if (currentNpcVisible) {
            updateNpcPortrait(null);
          }
        }
      }
    }
    
    // ========== Gun.js Connection (Player connects to GM) ==========

    // Handle Enter key in room code input
    function handleRoomCodeKeyup(event) {
      if (event.key === 'Enter') {
        connectToGM();
      }
    }

    // Connect to GM via Gun.js
    function connectToGM() {
      const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
      if (!roomCode) {
        return;
      }

      // Save room code for automatic reconnection
      savedRoomCode = roomCode;
      reconnectAttempts = 0;

      const statusEl = document.getElementById('connectionStatus');
      const connectBtn = document.getElementById('connectBtn');
      const title = statusEl.querySelector('.connection-title');

      // Update UI to show connecting
      connectBtn.disabled = true;
      connectBtn.textContent = 'Connecting...';
      connectBtn.classList.add('connecting');
      title.textContent = 'Connecting to GM...';

      // Check if Firebase is loaded
      if (!database) {
        console.error('Firebase not initialized');
        title.textContent = 'Firebase not configured';
        connectBtn.disabled = false;
        connectBtn.textContent = 'Retry';
        connectBtn.classList.remove('connecting');
        return;
      }

      try {
        // Connect to the GM's room in Firebase
        roomRef = database.ref('rooms/' + roomCode);

        // Check if GM is active
        roomRef.child('gm').on('value', (snapshot) => {
          const gmData = snapshot.val();
          if (gmData && gmData.active && (Date.now() - gmData.timestamp) < 30000) {
            console.log('GM is active in room:', roomCode);
            lastHeartbeatReceived = Date.now();
            firebaseConnected = true;

            // Update UI to show connected
            statusEl.classList.add('connected');
            title.textContent = 'Connected to GM';
            connectBtn.classList.remove('connecting');
            connectBtn.disabled = true;
            connectBtn.textContent = 'Connected';
            statusEl.querySelector('.connection-details').innerHTML = '<div class="connected-info">Receiving data from GM panel</div>';

            // Register as connected client
            roomRef.child('clients').child(clientId).set({
              connected: true,
              timestamp: Date.now(),
              requestSync: true
            });

            // Remove client on disconnect
            roomRef.child('clients').child(clientId).onDisconnect().remove();

            // Start heartbeat monitoring
            startHeartbeatMonitoring();
          }
        });

        // Subscribe to all data updates from GM
        subscribeToGmData();

        // Timeout if GM not found within 8 seconds
        setTimeout(() => {
          if (!statusEl.classList.contains('connected')) {
            console.log('Connection timeout - GM not found or inactive');
            title.textContent = 'GM not found. Check code?';
            connectBtn.disabled = false;
            connectBtn.textContent = 'Retry';
            connectBtn.classList.remove('connecting');
          }
        }, 8000);

      } catch (e) {
        console.error('Firebase connection error:', e);
        title.textContent = 'Connection error';
        connectBtn.disabled = false;
        connectBtn.textContent = 'Retry';
        connectBtn.classList.remove('connecting');
      }
    }


    // Subscribe to GM data updates via Firebase
    function subscribeToGmData() {
      if (!roomRef) return;

      // Subscribe to fear updates
      roomRef.child('fear').on('value', (snapshot) => {
        const data = snapshot.val();
        if (data && data.timestamp) {
          lastHeartbeatReceived = Date.now();
          console.log('Received fear update:', data.value);
          updateFear(data.value);
        }
      });

      // Subscribe to dice updates
      roomRef.child('dice').on('value', (snapshot) => {
        const data = snapshot.val();
        if (data && data.timestamp && data.timestamp > lastDiceTimestamp) {
          lastHeartbeatReceived = Date.now();
          lastDiceTimestamp = data.timestamp;
          console.log('Received dice update:', data);
          animateDiceRoll(data);
        }
      });

      // Subscribe to spotlight updates
      roomRef.child('spotlight').on('value', (snapshot) => {
        const data = snapshot.val();
        if (data && data.timestamp) {
          lastHeartbeatReceived = Date.now();
          if (data.timestamp > lastSpotlightTimestamp || data.visible !== currentSpotlightVisible) {
            lastSpotlightTimestamp = data.timestamp;
            console.log('Received spotlight update:', data);
            updateSpotlight(data);
          }
        }
      });

      // Subscribe to NPC updates
      roomRef.child('npc').on('value', (snapshot) => {
        const data = snapshot.val();
        if (data && data.timestamp && !currentSpotlightVisible) {
          lastHeartbeatReceived = Date.now();
          if (data.timestamp > lastNpcTimestamp || data.visible !== currentNpcVisible) {
            lastNpcTimestamp = data.timestamp;
            console.log('Received NPC update:', data);
            updateNpcPortrait(data);
          }
        }
      });

      // Subscribe to full sync updates
      roomRef.child('sync').on('value', (snapshot) => {
        const data = snapshot.val();
        if (data && data.timestamp) {
          lastHeartbeatReceived = Date.now();
          console.log('Received sync update:', data);

          if (data.fear !== undefined) {
            updateFear(data.fear);
          }
          if (data.spotlight) {
            lastSpotlightTimestamp = data.spotlight.timestamp || Date.now();
            updateSpotlight(data.spotlight);
          }
        }
      });
    }

    // Handle incoming data from GM (legacy format handler for compatibility)
    function handleGmData(data) {
      console.log('Received from GM:', data.type, data);

      switch (data.type) {
        case 'fear':
          console.log('Calling updateFear with:', data.value);
          updateFear(data.value);
          break;
        case 'dice':
          console.log('Calling animateDiceRoll');
          if (data.timestamp > lastDiceTimestamp) {
            lastDiceTimestamp = data.timestamp;
            animateDiceRoll(data);
          }
          break;
        case 'spotlight':
          console.log('Calling updateSpotlight');
          if (data.timestamp > lastSpotlightTimestamp || data.visible !== currentSpotlightVisible) {
            lastSpotlightTimestamp = data.timestamp;
            updateSpotlight(data);
          }
          break;
        case 'npc':
          console.log('Calling updateNpcPortrait');
          if (!currentSpotlightVisible) {
            if (data.timestamp > lastNpcTimestamp || data.visible !== currentNpcVisible) {
              lastNpcTimestamp = data.timestamp;
              updateNpcPortrait(data);
            }
          }
          break;
        case 'sync':
          // Full state sync from GM
          console.log('Processing sync - fear:', data.fear);
          if (data.fear !== undefined) updateFear(data.fear);
          if (data.spotlight) {
            lastSpotlightTimestamp = data.spotlight.timestamp || Date.now();
            updateSpotlight(data.spotlight);
          }
          break;
      }
    }

    // Toggle minimize connection status
    function toggleConnectionMinimize() {
      const statusEl = document.getElementById('connectionStatus');
      const btn = statusEl.querySelector('.minimize-btn');
      statusEl.classList.toggle('minimized');
      btn.textContent = statusEl.classList.contains('minimized') ? '+' : '−';
    }

    // ========== Heartbeat Monitoring and Automatic Reconnection ==========

    function startHeartbeatMonitoring() {
      if (heartbeatCheckIntervalId) {
        clearInterval(heartbeatCheckIntervalId);
      }

      lastHeartbeatReceived = Date.now();
      heartbeatCheckIntervalId = setInterval(() => {
        checkHeartbeat();
      }, 10000); // Check every 10 seconds

      // Also send periodic client heartbeats to GM
      setInterval(() => {
        if (roomNode) {
          roomNode.get('clients').get(clientId).put({
            connected: true,
            timestamp: Date.now(),
            requestSync: false
          });
        }
      }, 15000);

      console.log('Heartbeat monitoring started');
    }

    function stopHeartbeatMonitoring() {
      if (heartbeatCheckIntervalId) {
        clearInterval(heartbeatCheckIntervalId);
        heartbeatCheckIntervalId = null;
      }
      console.log('Heartbeat monitoring stopped');
    }

    function checkHeartbeat() {
      if (!roomNode) {
        return; // Not connected, nothing to check
      }

      const now = Date.now();
      const timeSinceLastHeartbeat = now - lastHeartbeatReceived;

      if (timeSinceLastHeartbeat > HEARTBEAT_TIMEOUT) {
        console.warn('No data received for', Math.round(timeSinceLastHeartbeat / 1000), 'seconds. Connection may be stale.');
        // Trigger reconnection
        handleDisconnection();
      }
    }

    function scheduleReconnect() {
      if (reconnectTimeoutId) {
        clearTimeout(reconnectTimeoutId);
      }

      if (!savedRoomCode) {
        console.log('No room code saved, cannot reconnect');
        return;
      }

      // Exponential backoff: 2s, 4s, 8s, 16s, 30s (max)
      const delay = Math.min(RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts), MAX_RECONNECT_DELAY);
      reconnectAttempts++;

      console.log(`Scheduling reconnect attempt ${reconnectAttempts} in ${delay / 1000} seconds...`);

      const statusEl = document.getElementById('connectionStatus');
      const title = statusEl.querySelector('.connection-title');
      title.textContent = `Reconnecting in ${Math.round(delay / 1000)}s...`;

      reconnectTimeoutId = setTimeout(() => {
        console.log('Attempting to reconnect...');
        attemptReconnect();
      }, delay);
    }

    function attemptReconnect() {
      if (!savedRoomCode) {
        console.log('No room code saved, cannot reconnect');
        return;
      }

      const statusEl = document.getElementById('connectionStatus');
      const title = statusEl.querySelector('.connection-title');
      title.textContent = 'Reconnecting to GM...';

      try {
        // Reconnect to the room
        roomNode = gun.get('daggerheart-room-' + savedRoomCode);

        // Check if GM is still active
        roomNode.get('gm').once((gmData) => {
          if (gmData && gmData.active && (Date.now() - gmData.timestamp) < 30000) {
            console.log('Reconnected to GM!');
            reconnectAttempts = 0;
            lastHeartbeatReceived = Date.now();

            statusEl.classList.add('connected');
            title.textContent = 'Connected to GM';
            statusEl.querySelector('.connection-details').innerHTML = '<div class="connected-info">Receiving data from GM panel</div>';

            // Re-register as connected client and request sync
            roomNode.get('clients').get(clientId).put({
              connected: true,
              timestamp: Date.now(),
              requestSync: true
            });

            subscribeToGmData();
            startHeartbeatMonitoring();
          } else {
            console.log('GM not active, scheduling reconnect...');
            scheduleReconnect();
          }
        });

      } catch (e) {
        console.error('Reconnection error:', e);
        scheduleReconnect();
      }
    }

    function handleDisconnection() {
      roomNode = null;
      stopHeartbeatMonitoring();

      const statusEl = document.getElementById('connectionStatus');
      const title = statusEl.querySelector('.connection-title');
      statusEl.classList.remove('connected');
      title.textContent = 'Disconnected - Reconnecting...';

      // Automatically attempt to reconnect
      scheduleReconnect();
    }

    // ========== Initialization ==========

    // Initialize
    initSkulls();
    checkForUpdates();

    // Poll for updates (localStorage events don't always fire in same window)
    setInterval(checkForUpdates, 100);

    // Also listen for storage events (for cross-tab)
    window.addEventListener('storage', checkForUpdates);

    // Handle resize
    window.addEventListener('resize', () => {
      const fear = parseInt(localStorage.getItem('daggerheart-fear')) || 0;
      updateFear(fear);
    });
  </script>
</body>
</html>
