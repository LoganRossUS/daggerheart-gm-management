<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daggerheart - Player Display</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Cinzel+Decorative:wght@700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: 
        radial-gradient(ellipse at 30% 20%, rgba(123, 45, 142, 0.3) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 80%, rgba(75, 0, 130, 0.4) 0%, transparent 50%),
        linear-gradient(180deg, #12061a 0%, #1a0d24 50%, #0d0610 100%);
      font-family: 'Cinzel', serif;
      cursor: none;
    }
    
    /* Fear Tracker - Bottom of screen */
    #fearTracker {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 1200px;
    }
    
    .pike-container {
      position: relative;
      height: 120px;
      display: flex;
      align-items: center;
    }
    
    .pike-labels {
      position: absolute;
      width: 100%;
      display: flex;
      justify-content: space-between;
      top: -25px;
      padding: 0 30px;
    }
    
    .pike-labels span {
      font-size: 0.9rem;
      letter-spacing: 3px;
    }
    
    .pike-labels .hope {
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .pike-labels .fear-label {
      color: #b388ff;
      text-shadow: 0 0 10px rgba(179, 136, 255, 0.5);
    }
    
    .pike {
      position: absolute;
      left: 30px;
      right: 30px;
      top: 50%;
      transform: translateY(-50%);
      height: 14px;
      background: linear-gradient(180deg, #8B5A2B 0%, #6B4423 15%, #5D3A1A 30%, #4A2F15 50%, #5D3A1A 70%, #6B4423 85%, #8B5A2B 100%);
      border-radius: 7px;
      box-shadow: inset 0 2px 3px rgba(255,255,255,0.15), inset 0 -2px 3px rgba(0,0,0,0.4), 0 4px 12px rgba(0,0,0,0.6);
    }
    
    .pike::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(90deg, transparent 0px, rgba(0,0,0,0.08) 1px, transparent 2px, transparent 8px);
      border-radius: 7px;
    }
    
    .pike-point-left {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 0;
      height: 0;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-right: 22px solid #b8860b;
      filter: drop-shadow(-2px 0 3px rgba(0,0,0,0.5));
    }
    
    .pike-point-right {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 0;
      height: 0;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-left: 22px solid #4a0e4e;
      filter: drop-shadow(2px 0 5px rgba(75, 0, 130, 0.8));
    }
    
    .skull {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 50px;
      height: 65px;
      transition: left 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 10;
    }
    
    /* Fear Counter */
    #fearCounter {
      position: absolute;
      top: 20px;
      right: 30px;
      text-align: right;
    }
    
    #fearCounter .label {
      font-size: 1rem;
      color: #888;
      letter-spacing: 2px;
    }
    
    #fearCounter .value {
      font-family: 'Cinzel Decorative', serif;
      font-size: 4rem;
      font-weight: 900;
      transition: all 0.3s ease;
    }
    
    /* Dice Animation Area */
    #diceArea {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      perspective: 1200px;
    }

    /* 3D Dice Container */
    .die-container {
      position: absolute;
      transform-style: preserve-3d;
      filter: drop-shadow(0 20px 30px rgba(0,0,0,0.6));
    }

    .die {
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.1s linear;
    }

    .die-face {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Cinzel Decorative', serif;
      font-weight: 900;
      backface-visibility: visible;
      border: 2px solid rgba(0,0,0,0.3);
    }

    /* D6 Cube Dice */
    .die.d6 {
      width: 80px;
      height: 80px;
    }

    .die.d6 .die-face {
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
      border-radius: 12px;
      box-shadow: inset 0 0 15px rgba(0,0,0,0.1);
    }

    .die.d6 .die-face.front  { transform: translateZ(40px); }
    .die.d6 .die-face.back   { transform: rotateY(180deg) translateZ(40px); }
    .die.d6 .die-face.right  { transform: rotateY(90deg) translateZ(40px); }
    .die.d6 .die-face.left   { transform: rotateY(-90deg) translateZ(40px); }
    .die.d6 .die-face.top    { transform: rotateX(90deg) translateZ(40px); }
    .die.d6 .die-face.bottom { transform: rotateX(-90deg) translateZ(40px); }

    /* D6 Pips */
    .pip-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      width: 60px;
      height: 60px;
      gap: 2px;
    }

    .pip {
      width: 14px;
      height: 14px;
      background: radial-gradient(circle at 30% 30%, #333, #111);
      border-radius: 50%;
      margin: auto;
      box-shadow: inset 0 2px 3px rgba(255,255,255,0.2), 0 2px 4px rgba(0,0,0,0.3);
    }

    .pip.hidden { visibility: hidden; }

    /* D20 Icosahedron (simplified as larger die with number) */
    .die.d20 {
      width: 100px;
      height: 100px;
    }

    .die.d20 .die-face {
      width: 100px;
      height: 100px;
      font-size: 2.5rem;
      color: #1a1a1a;
      background: linear-gradient(145deg, #ffd700, #b8860b);
      clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
      border: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    .die.d20 .die-face.front  { transform: translateZ(50px); }
    .die.d20 .die-face.back   { transform: rotateY(180deg) translateZ(50px); }
    .die.d20 .die-face.right  { transform: rotateY(72deg) translateZ(50px); }
    .die.d20 .die-face.left   { transform: rotateY(-72deg) translateZ(50px); }
    .die.d20 .die-face.top    { transform: rotateX(72deg) translateZ(50px); }
    .die.d20 .die-face.bottom { transform: rotateX(-72deg) translateZ(50px); }

    /* D12 Dodecahedron */
    .die.d12 {
      width: 90px;
      height: 90px;
    }

    .die.d12 .die-face {
      width: 90px;
      height: 90px;
      font-size: 2rem;
      color: #1a1a1a;
      background: linear-gradient(145deg, #e8d5ff, #9c7cc4);
      clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
      border: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .die.d12 .die-face.front  { transform: translateZ(45px); }
    .die.d12 .die-face.back   { transform: rotateY(180deg) translateZ(45px); }
    .die.d12 .die-face.right  { transform: rotateY(72deg) translateZ(45px); }
    .die.d12 .die-face.left   { transform: rotateY(-72deg) translateZ(45px); }
    .die.d12 .die-face.top    { transform: rotateX(72deg) translateZ(45px); }
    .die.d12 .die-face.bottom { transform: rotateX(-72deg) translateZ(45px); }

    /* D12 Hope (Gold) */
    .die.d12.hope .die-face {
      background: linear-gradient(145deg, #ffd700, #b8860b);
    }

    /* D12 Fear (Purple) */
    .die.d12.fear .die-face {
      background: linear-gradient(145deg, #b388ff, #7c4dff);
    }

    /* D10 */
    .die.d10 {
      width: 75px;
      height: 75px;
    }

    .die.d10 .die-face {
      width: 75px;
      height: 75px;
      font-size: 1.8rem;
      color: #1a1a1a;
      background: linear-gradient(145deg, #90caf9, #42a5f5);
      clip-path: polygon(50% 0%, 95% 35%, 80% 100%, 20% 100%, 5% 35%);
      border: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .die.d10 .die-face.front  { transform: translateZ(38px); }
    .die.d10 .die-face.back   { transform: rotateY(180deg) translateZ(38px); }
    .die.d10 .die-face.right  { transform: rotateY(72deg) translateZ(38px); }
    .die.d10 .die-face.left   { transform: rotateY(-72deg) translateZ(38px); }
    .die.d10 .die-face.top    { transform: rotateX(72deg) translateZ(38px); }
    .die.d10 .die-face.bottom { transform: rotateX(-72deg) translateZ(38px); }

    /* D8 Octahedron */
    .die.d8 {
      width: 70px;
      height: 70px;
    }

    .die.d8 .die-face {
      width: 70px;
      height: 70px;
      font-size: 1.6rem;
      color: #1a1a1a;
      background: linear-gradient(145deg, #a5d6a7, #66bb6a);
      clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
      border: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .die.d8 .die-face.front  { transform: translateZ(35px); }
    .die.d8 .die-face.back   { transform: rotateY(180deg) translateZ(35px); }
    .die.d8 .die-face.right  { transform: rotateY(90deg) translateZ(35px); }
    .die.d8 .die-face.left   { transform: rotateY(-90deg) translateZ(35px); }
    .die.d8 .die-face.top    { transform: rotateX(90deg) translateZ(35px); }
    .die.d8 .die-face.bottom { transform: rotateX(-90deg) translateZ(35px); }

    /* D4 Tetrahedron */
    .die.d4 {
      width: 70px;
      height: 70px;
    }

    .die.d4 .die-face {
      width: 70px;
      height: 70px;
      font-size: 1.5rem;
      color: #1a1a1a;
      background: linear-gradient(145deg, #ffcc80, #ff9800);
      clip-path: polygon(50% 0%, 100% 100%, 0% 100%);
      border: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .die.d4 .die-face.front  { transform: translateZ(35px) rotateX(19.5deg); }
    .die.d4 .die-face.back   { transform: rotateY(180deg) translateZ(35px) rotateX(19.5deg); }
    .die.d4 .die-face.right  { transform: rotateY(120deg) translateZ(35px) rotateX(19.5deg); }
    .die.d4 .die-face.left   { transform: rotateY(-120deg) translateZ(35px) rotateX(19.5deg); }

    /* Rolling glow effect */
    .die-container.rolling {
      filter: drop-shadow(0 20px 30px rgba(0,0,0,0.6)) drop-shadow(0 0 20px rgba(255,215,0,0.3));
    }

    /* Settled state */
    .die-container.settled .die {
      transition: transform 0.3s ease-out;
    }
    
    /* Result Display */
    #resultDisplay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }
    
    #resultDisplay.visible {
      opacity: 1;
    }
    
    #resultDisplay .result-value {
      font-family: 'Cinzel Decorative', serif;
      font-size: 12rem;
      font-weight: 900;
      color: #ffd700;
      text-shadow: 0 0 60px rgba(255, 215, 0, 0.8), 0 0 120px rgba(255, 215, 0, 0.4);
    }
    
    #resultDisplay .result-detail {
      font-size: 2rem;
      color: #b388ff;
      margin-top: -20px;
    }
    
    /* Hope/Fear Specific */
    #resultDisplay.hope .result-value {
      color: #ffd700;
      text-shadow: 0 0 60px rgba(255, 215, 0, 0.8);
    }
    
    #resultDisplay.fear .result-value {
      color: #b388ff;
      text-shadow: 0 0 60px rgba(179, 136, 255, 0.8);
    }
    
    /* Title */
    #title {
      position: absolute;
      top: 20px;
      left: 30px;
    }
    
    #title h1 {
      font-family: 'Cinzel Decorative', serif;
      font-size: 2rem;
      background: linear-gradient(180deg, #ffd700, #b8860b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
  </style>
</head>
<body>
  <!-- Title -->
  <div id="title">
    <h1>DAGGERHEART</h1>
  </div>
  
  <!-- Fear Counter -->
  <div id="fearCounter">
    <div class="label">FEAR</div>
    <div class="value" id="fearValue">0</div>
  </div>
  
  <!-- Dice Animation Area -->
  <div id="diceArea"></div>
  
  <!-- Result Display -->
  <div id="resultDisplay">
    <div class="result-value" id="resultValue"></div>
    <div class="result-detail" id="resultDetail"></div>
  </div>
  
  <!-- Fear Tracker Pike -->
  <div id="fearTracker">
    <div class="pike-container">
      <div class="pike-labels">
        <span class="hope">✦ HOPE ✦</span>
        <span class="fear-label">✦ FEAR ✦</span>
      </div>
      <div class="pike-point-left"></div>
      <div class="pike"></div>
      <div class="pike-point-right"></div>
      <div id="skulls"></div>
    </div>
  </div>

  <script>
    // Skull SVG generator
    function createSkullSVG(level, isActive) {
      const baseColor = isActive ? '#e8d5ff' : '#f5f0e6';
      const shadowColor = isActive ? '#6b3d7a' : '#a09080';
      const highlightColor = isActive ? '#fff' : '#fffef8';
      const boneColor = isActive ? '#d4c4e8' : '#e8e0d4';
      
      const eyeAnger = Math.min(level * 1.5, 15);
      const jawOpen = level > 6 ? (level - 6) * 1.5 : 0;
      const teethSharpness = level > 3 ? Math.min((level - 3) * 0.5, 3) : 0;
      const crackOpacity = level > 4 ? Math.min((level - 4) * 0.12, 0.7) : 0;
      const hornLength = level > 9 ? (level - 9) * 6 : 0;
      const eyeGlow = level > 7 || isActive;
      const flameEyes = level > 10;
      
      let svg = `<svg viewBox="0 0 40 50" style="width:100%;height:100%;overflow:visible">
        <defs>
          <radialGradient id="skullMain-${level}-${isActive}" cx="40%" cy="30%" r="60%">
            <stop offset="0%" stop-color="${highlightColor}"/>
            <stop offset="60%" stop-color="${baseColor}"/>
            <stop offset="100%" stop-color="${shadowColor}"/>
          </radialGradient>
          <radialGradient id="jawGrad-${level}-${isActive}" cx="50%" cy="20%" r="70%">
            <stop offset="0%" stop-color="${baseColor}"/>
            <stop offset="100%" stop-color="${shadowColor}"/>
          </radialGradient>
          <radialGradient id="eyeGlow-${level}" cx="50%" cy="50%" r="50%">
            <stop offset="0%" stop-color="${isActive ? '#b388ff' : '#ff6b35'}"/>
            <stop offset="100%" stop-color="${isActive ? '#7c4dff' : '#d32f2f'}"/>
          </radialGradient>
        </defs>`;
      
      // Horns
      if (hornLength > 0) {
        svg += `<path d="M8,8 Q2,${4-hornLength*0.5} 4,${-hornLength}" fill="none" stroke="${isActive ? '#4a3050' : '#3d3530'}" stroke-width="4" stroke-linecap="round"/>`;
        svg += `<path d="M32,8 Q38,${4-hornLength*0.5} 36,${-hornLength}" fill="none" stroke="${isActive ? '#4a3050' : '#3d3530'}" stroke-width="4" stroke-linecap="round"/>`;
      }
      
      // Cranium
      svg += `<ellipse cx="20" cy="18" rx="16" ry="17" fill="url(#skullMain-${level}-${isActive})" stroke="${shadowColor}" stroke-width="0.5"/>`;
      
      // Cheekbones
      svg += `<ellipse cx="8" cy="26" rx="5" ry="4" fill="${boneColor}" opacity="0.5"/>`;
      svg += `<ellipse cx="32" cy="26" rx="5" ry="4" fill="${boneColor}" opacity="0.5"/>`;
      
      // Brow ridge
      svg += `<path d="M6,14 Q12,${12-eyeAnger*0.3} 20,14 Q28,${12-eyeAnger*0.3} 34,14" fill="none" stroke="${shadowColor}" stroke-width="2" stroke-linecap="round" opacity="0.6"/>`;
      
      // Eye sockets
      svg += `<ellipse cx="12" cy="20" rx="5" ry="6" fill="#1a1015" transform="rotate(${-eyeAnger}, 12, 20)"/>`;
      svg += `<ellipse cx="28" cy="20" rx="5" ry="6" fill="#1a1015" transform="rotate(${eyeAnger}, 28, 20)"/>`;
      
      // Eye glow
      if (eyeGlow && !flameEyes) {
        svg += `<ellipse cx="12" cy="20" rx="3" ry="4" fill="url(#eyeGlow-${level})" opacity="0.8"><animate attributeName="opacity" values="0.6;0.9;0.6" dur="2s" repeatCount="indefinite"/></ellipse>`;
        svg += `<ellipse cx="28" cy="20" rx="3" ry="4" fill="url(#eyeGlow-${level})" opacity="0.8"><animate attributeName="opacity" values="0.6;0.9;0.6" dur="2s" repeatCount="indefinite"/></ellipse>`;
      }
      
      // Flame eyes
      if (flameEyes) {
        svg += `<ellipse cx="12" cy="18" rx="4" ry="7" fill="#ff4500" opacity="0.9"><animate attributeName="ry" values="6;8;6" dur="0.2s" repeatCount="indefinite"/></ellipse>`;
        svg += `<ellipse cx="12" cy="18" rx="2" ry="5" fill="#ffff00" opacity="0.8"><animate attributeName="ry" values="4;6;4" dur="0.15s" repeatCount="indefinite"/></ellipse>`;
        svg += `<ellipse cx="28" cy="18" rx="4" ry="7" fill="#ff4500" opacity="0.9"><animate attributeName="ry" values="6;8;6" dur="0.2s" repeatCount="indefinite"/></ellipse>`;
        svg += `<ellipse cx="28" cy="18" rx="2" ry="5" fill="#ffff00" opacity="0.8"><animate attributeName="ry" values="4;6;4" dur="0.15s" repeatCount="indefinite"/></ellipse>`;
      }
      
      // Nose
      svg += `<path d="M20,26 L17,32 L20,31 L23,32 Z" fill="#1a1015"/>`;
      
      // Jaws
      svg += `<path d="M8,30 Q20,${34+jawOpen*0.3} 32,30 L32,36 Q20,38 8,36 Z" fill="url(#jawGrad-${level}-${isActive})" stroke="${shadowColor}" stroke-width="0.5"/>`;
      svg += `<path d="M10,${36+jawOpen} Q20,${42+jawOpen*1.2} 30,${36+jawOpen} L28,${40+jawOpen} Q20,${44+jawOpen*1.3} 12,${40+jawOpen} Z" fill="url(#jawGrad-${level}-${isActive})" stroke="${shadowColor}" stroke-width="0.5"/>`;
      
      // Teeth
      for (let i = 0; i < 6; i++) {
        const x = 11 + i * 3;
        const height = 3 + teethSharpness + ((i === 1 || i === 4) ? teethSharpness * 0.5 : 0);
        svg += `<path d="M${x},35 L${x + 1.5},${35 + height} L${x + 3},35" fill="${highlightColor}" stroke="${shadowColor}" stroke-width="0.3"/>`;
      }
      for (let i = 0; i < 5; i++) {
        const x = 12.5 + i * 3;
        const height = 2 + teethSharpness * 0.7;
        svg += `<path d="M${x},${37+jawOpen} L${x + 1.5},${37+jawOpen - height} L${x + 3},${37+jawOpen}" fill="${highlightColor}" stroke="${shadowColor}" stroke-width="0.3"/>`;
      }
      
      // Cracks
      if (crackOpacity > 0) {
        svg += `<path d="M14,6 L16,12 L14,15" fill="none" stroke="#2a2020" stroke-width="0.8" opacity="${crackOpacity}"/>`;
        svg += `<path d="M16,12 L18,14" fill="none" stroke="#2a2020" stroke-width="0.5" opacity="${crackOpacity}"/>`;
        svg += `<path d="M26,8 L24,13 L26,16" fill="none" stroke="#2a2020" stroke-width="0.8" opacity="${crackOpacity * 0.8}"/>`;
      }
      
      // Pike hole
      svg += `<ellipse cx="20" cy="24" rx="2.5" ry="1.5" fill="#1a1015"/>`;
      svg += `<ellipse cx="20" cy="24" rx="2" ry="1" fill="#0d0a0a"/>`;
      
      // Smile for friendly skulls
      if (level <= 2) {
        svg += `<path d="M14,${38+jawOpen} Q20,${41+jawOpen} 26,${38+jawOpen}" fill="none" stroke="${shadowColor}" stroke-width="1" stroke-linecap="round" opacity="0.5"/>`;
      }
      
      svg += `</svg>`;
      return svg;
    }
    
    // Initialize skulls
    function initSkulls() {
      const container = document.getElementById('skulls');
      container.innerHTML = '';
      
      for (let i = 0; i < 12; i++) {
        const skull = document.createElement('div');
        skull.className = 'skull';
        skull.id = `skull-${i}`;
        skull.innerHTML = createSkullSVG(12 - i, false);
        skull.style.left = `${(30 + (i * 4))}px`;
        skull.style.filter = `drop-shadow(0 0 6px rgba(255, 215, 0, 0.3))`;
        container.appendChild(skull);
      }
    }
    
    // Update fear display
    function updateFear(fearCount) {
      // Update counter
      const counter = document.getElementById('fearValue');
      counter.textContent = fearCount;
      counter.style.color = fearCount > 8 ? '#ff4444' : fearCount > 4 ? '#b388ff' : '#ffd700';
      counter.style.textShadow = `0 0 30px ${fearCount > 8 ? 'rgba(255,68,68,0.6)' : fearCount > 4 ? 'rgba(179,136,255,0.6)' : 'rgba(255,215,0,0.5)'}`;

      // Update skulls
      const pikeContainer = document.querySelector('.pike-container');
      const pikeWidth = pikeContainer.offsetWidth - 80; // Account for points

      for (let i = 0; i < 12; i++) {
        const skull = document.getElementById(`skull-${i}`);
        // Rightmost skull (index 11) moves first, then 10, 9, etc.
        // When fearCount=1, skull 11 is active
        // When fearCount=2, skulls 11 and 10 are active
        const isActive = i >= (12 - fearCount);
        const spacing = pikeWidth / 24;

        // Hope side: left half, Fear side: right half
        const hopePos = 40 + (i * spacing);
        const fearPos = (pikeWidth / 2) + 40 + (i * spacing);

        skull.style.left = `${isActive ? fearPos : hopePos}px`;
        skull.innerHTML = createSkullSVG(12 - i, isActive);
        skull.style.filter = `drop-shadow(0 0 ${isActive ? 12 : 6}px ${isActive ? 'rgba(179, 136, 255, 0.6)' : 'rgba(255, 215, 0, 0.3)'})`;
      }
    }
    
    // Create 3D die HTML with all faces
    function create3DDie(sides, extraClass = '') {
      const container = document.createElement('div');
      container.className = 'die-container rolling';

      const die = document.createElement('div');
      die.className = `die d${sides} ${extraClass}`;

      if (sides === 6) {
        // D6 with pips
        const faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];
        const faceValues = [1, 6, 3, 4, 2, 5]; // Opposite faces sum to 7

        faces.forEach((faceName, idx) => {
          const face = document.createElement('div');
          face.className = `die-face ${faceName}`;
          face.appendChild(createPips(faceValues[idx]));
          face.dataset.value = faceValues[idx];
          die.appendChild(face);
        });
      } else {
        // Other dice with numbers on faces
        const faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];
        const faceCount = sides === 4 ? 4 : 6;

        for (let i = 0; i < faceCount; i++) {
          const face = document.createElement('div');
          face.className = `die-face ${faces[i] || 'extra'}`;
          face.textContent = '?';
          face.dataset.value = (i % sides) + 1;
          die.appendChild(face);
        }
      }

      container.appendChild(die);
      return container;
    }

    // Create pip pattern for d6 faces
    function createPips(value) {
      const container = document.createElement('div');
      container.className = 'pip-container';

      // Grid positions: 0-8 for 3x3 grid
      const patterns = {
        1: [4],
        2: [0, 8],
        3: [0, 4, 8],
        4: [0, 2, 6, 8],
        5: [0, 2, 4, 6, 8],
        6: [0, 2, 3, 5, 6, 8]
      };

      const positions = patterns[value] || [];

      for (let i = 0; i < 9; i++) {
        const pip = document.createElement('div');
        pip.className = positions.includes(i) ? 'pip' : 'pip hidden';
        container.appendChild(pip);
      }

      return container;
    }

    // Update die faces with random or final values
    function updateDieFaces(die, value, sides, isRolling = false) {
      const faces = die.querySelectorAll('.die-face');

      if (sides === 6) {
        // D6 uses pips, no text update needed during rolling
        return;
      }

      faces.forEach((face, idx) => {
        if (isRolling) {
          face.textContent = Math.floor(Math.random() * sides) + 1;
        } else {
          // Show value on front face, complementary values on others
          if (idx === 0) {
            face.textContent = value;
          } else {
            face.textContent = ((value + idx - 1) % sides) + 1;
          }
        }
      });
    }

    // Get final rotation to show result
    function getFinalRotation(result, sides) {
      // Calculate rotation to show the result on top
      if (sides === 6) {
        // For d6 with pips, map result to correct face orientation
        const rotations = {
          1: { x: 0, y: 0 },
          2: { x: -90, y: 0 },
          3: { x: 0, y: -90 },
          4: { x: 0, y: 90 },
          5: { x: 90, y: 0 },
          6: { x: 180, y: 0 }
        };
        return rotations[result] || { x: 0, y: 0 };
      }

      // For other dice, use front face (rotateX and Y to 0)
      return { x: 0, y: 0 };
    }

    // Animate dice roll
    function animateDiceRoll(diceData) {
      const area = document.getElementById('diceArea');
      const resultDisplay = document.getElementById('resultDisplay');
      const resultValue = document.getElementById('resultValue');
      const resultDetail = document.getElementById('resultDetail');

      // Clear previous
      area.innerHTML = '';
      resultDisplay.classList.remove('visible', 'hope', 'fear');

      if (diceData.type === 'hopefear') {
        // Hope/Fear roll - two dice
        animateHopeFearRoll(diceData);
        return;
      }

      // Handle both legacy 'standard' format and new 'notation' format
      let allResults = [];
      let allSides = [];

      if (diceData.type === 'notation' && diceData.diceRolls) {
        // New notation format with multiple dice types
        diceData.diceRolls.forEach(roll => {
          roll.results.forEach(result => {
            allResults.push(result);
            allSides.push(roll.sides);
          });
        });
      } else if (diceData.results) {
        // Legacy standard format
        allResults = diceData.results;
        allSides = diceData.results.map(() => diceData.sides);
      }

      if (allResults.length === 0) return;

      const dice = [];

      for (let i = 0; i < allResults.length; i++) {
        const container = create3DDie(allSides[i]);
        const dieEl = container.querySelector('.die');

        // Random starting position (off screen)
        const startSide = Math.random() > 0.5 ? -1 : 1;
        container.style.left = startSide > 0 ? '-120px' : (window.innerWidth + 120) + 'px';
        container.style.top = (Math.random() * (window.innerHeight * 0.3) + 100) + 'px';

        area.appendChild(container);

        dice.push({
          container: container,
          die: dieEl,
          x: parseFloat(container.style.left),
          y: parseFloat(container.style.top),
          vx: startSide > 0 ? (12 + Math.random() * 8) : -(12 + Math.random() * 8),
          vy: -3 + Math.random() * 6,
          rotX: Math.random() * 360,
          rotY: Math.random() * 360,
          rotZ: Math.random() * 360,
          vrX: (Math.random() - 0.5) * 25,
          vrY: (Math.random() - 0.5) * 25,
          vrZ: (Math.random() - 0.5) * 15,
          result: allResults[i],
          sides: allSides[i],
          settled: false,
          settleFrame: 0
        });
      }

      const gravity = 0.4;
      const friction = 0.985;
      const bounceFactor = 0.55;
      const floor = window.innerHeight * 0.55;
      let settleTime = 0;

      function animate() {
        let allSettled = true;

        dice.forEach(d => {
          if (d.settled && d.settleFrame > 30) return;

          // Physics
          d.vy += gravity;
          d.x += d.vx;
          d.y += d.vy;

          // 3D rotation
          d.rotX += d.vrX;
          d.rotY += d.vrY;
          d.rotZ += d.vrZ;

          // Bounce off floor
          if (d.y > floor) {
            d.y = floor;
            d.vy *= -bounceFactor;
            d.vx *= friction;
            d.vrX *= 0.7;
            d.vrY *= 0.7;
            d.vrZ *= 0.7;

            // Add some random spin on bounce
            d.vrX += (Math.random() - 0.5) * 5;
            d.vrY += (Math.random() - 0.5) * 5;
          }

          // Bounce off walls
          if (d.x < 80) {
            d.x = 80;
            d.vx *= -bounceFactor;
            d.vrY += (Math.random() - 0.5) * 10;
          }
          if (d.x > window.innerWidth - 80) {
            d.x = window.innerWidth - 80;
            d.vx *= -bounceFactor;
            d.vrY += (Math.random() - 0.5) * 10;
          }

          // Apply friction
          d.vx *= friction;
          d.vrX *= 0.99;
          d.vrY *= 0.99;
          d.vrZ *= 0.99;

          // Check if settled
          const isSettling = Math.abs(d.vy) < 2 && Math.abs(d.vx) < 1 && d.y >= floor - 5;

          if (isSettling && !d.settled) {
            d.settled = true;
            d.container.classList.remove('rolling');
            d.container.classList.add('settled');

            // Calculate final rotation to show result
            const finalRot = getFinalRotation(d.result, d.sides);
            d.targetRotX = finalRot.x;
            d.targetRotY = finalRot.y;

            // Update die faces with final values
            updateDieFaces(d.die, d.result, d.sides, false);
          }

          if (d.settled) {
            d.settleFrame++;
            // Smoothly interpolate to final rotation
            d.rotX += (d.targetRotX - (d.rotX % 360)) * 0.15;
            d.rotY += (d.targetRotY - (d.rotY % 360)) * 0.15;
            d.rotZ *= 0.85;
            d.vrX = 0;
            d.vrY = 0;
            d.vrZ = 0;
          } else {
            allSettled = false;
            // Update die faces with random values while rolling
            if (Math.random() > 0.7) {
              updateDieFaces(d.die, d.result, d.sides, true);
            }
          }

          // Update position and rotation
          d.container.style.left = d.x + 'px';
          d.container.style.top = d.y + 'px';
          d.die.style.transform = `rotateX(${d.rotX}deg) rotateY(${d.rotY}deg) rotateZ(${d.rotZ}deg)`;
        });

        if (!allSettled || settleTime < 60) {
          if (allSettled) settleTime++;
          requestAnimationFrame(animate);
        } else {
          // Show final result
          setTimeout(() => {
            // Fade out dice slightly
            dice.forEach(d => d.container.style.opacity = '0.4');

            // Show result - use notation format if available
            resultValue.textContent = diceData.total;
            if (diceData.notation) {
              resultDetail.textContent = diceData.notation;
            } else if (diceData.count > 1) {
              resultDetail.textContent = `${diceData.results.join(' + ')}`;
            } else {
              resultDetail.textContent = `d${diceData.sides}`;
            }
            resultDisplay.classList.add('visible');

            // Hide after delay
            setTimeout(() => {
              resultDisplay.classList.remove('visible');
              setTimeout(() => { area.innerHTML = ''; }, 500);
            }, 3000);
          }, 300);
        }
      }

      requestAnimationFrame(animate);
    }
    
    // Hope/Fear roll animation
    function animateHopeFearRoll(data) {
      const area = document.getElementById('diceArea');
      const resultDisplay = document.getElementById('resultDisplay');
      const resultValue = document.getElementById('resultValue');
      const resultDetail = document.getElementById('resultDetail');

      // Create two 3D d12 dice - hope (gold) and fear (purple)
      const hopeContainer = create3DDie(12, 'hope');
      const fearContainer = create3DDie(12, 'fear');

      hopeContainer.style.left = '-120px';
      hopeContainer.style.top = '180px';

      fearContainer.style.left = (window.innerWidth + 120) + 'px';
      fearContainer.style.top = '180px';

      area.appendChild(hopeContainer);
      area.appendChild(fearContainer);

      const dice = [
        {
          container: hopeContainer,
          die: hopeContainer.querySelector('.die'),
          x: -120,
          y: 180,
          vx: 14,
          vy: -2,
          rotX: Math.random() * 360,
          rotY: Math.random() * 360,
          rotZ: Math.random() * 360,
          vrX: 18,
          vrY: 12,
          vrZ: 8,
          result: data.hope,
          type: 'hope',
          sides: 12,
          settled: false,
          settleFrame: 0
        },
        {
          container: fearContainer,
          die: fearContainer.querySelector('.die'),
          x: window.innerWidth + 120,
          y: 180,
          vx: -14,
          vy: -2,
          rotX: Math.random() * 360,
          rotY: Math.random() * 360,
          rotZ: Math.random() * 360,
          vrX: -18,
          vrY: -12,
          vrZ: -8,
          result: data.fear,
          type: 'fear',
          sides: 12,
          settled: false,
          settleFrame: 0
        }
      ];

      const gravity = 0.4;
      const friction = 0.985;
      const bounceFactor = 0.55;
      const floor = window.innerHeight * 0.55;
      let settleTime = 0;

      function animate() {
        let allSettled = true;

        dice.forEach(d => {
          if (d.settled && d.settleFrame > 30) return;

          // Physics
          d.vy += gravity;
          d.x += d.vx;
          d.y += d.vy;

          // 3D rotation
          d.rotX += d.vrX;
          d.rotY += d.vrY;
          d.rotZ += d.vrZ;

          // Bounce off floor
          if (d.y > floor) {
            d.y = floor;
            d.vy *= -bounceFactor;
            d.vx *= friction;
            d.vrX *= 0.7;
            d.vrY *= 0.7;
            d.vrZ *= 0.7;

            d.vrX += (Math.random() - 0.5) * 5;
            d.vrY += (Math.random() - 0.5) * 5;
          }

          // Bounce off walls
          if (d.x < 100) {
            d.x = 100;
            d.vx *= -bounceFactor;
            d.vrY += (Math.random() - 0.5) * 10;
          }
          if (d.x > window.innerWidth - 100) {
            d.x = window.innerWidth - 100;
            d.vx *= -bounceFactor;
            d.vrY += (Math.random() - 0.5) * 10;
          }

          // Apply friction
          d.vx *= friction;
          d.vrX *= 0.99;
          d.vrY *= 0.99;
          d.vrZ *= 0.99;

          // Check if settled
          const isSettling = Math.abs(d.vy) < 2 && Math.abs(d.vx) < 1 && d.y >= floor - 5;

          if (isSettling && !d.settled) {
            d.settled = true;
            d.container.classList.remove('rolling');
            d.container.classList.add('settled');

            // Calculate final rotation
            const finalRot = getFinalRotation(d.result, d.sides);
            d.targetRotX = finalRot.x;
            d.targetRotY = finalRot.y;

            // Update die faces
            updateDieFaces(d.die, d.result, d.sides, false);
          }

          if (d.settled) {
            d.settleFrame++;
            d.rotX += (d.targetRotX - (d.rotX % 360)) * 0.15;
            d.rotY += (d.targetRotY - (d.rotY % 360)) * 0.15;
            d.rotZ *= 0.85;
            d.vrX = 0;
            d.vrY = 0;
            d.vrZ = 0;
          } else {
            allSettled = false;
            if (Math.random() > 0.7) {
              updateDieFaces(d.die, d.result, d.sides, true);
            }
          }

          // Update position and rotation
          d.container.style.left = d.x + 'px';
          d.container.style.top = d.y + 'px';
          d.die.style.transform = `rotateX(${d.rotX}deg) rotateY(${d.rotY}deg) rotateZ(${d.rotZ}deg)`;
        });

        if (!allSettled || settleTime < 60) {
          if (allSettled) settleTime++;
          requestAnimationFrame(animate);
        } else {
          setTimeout(() => {
            dice.forEach(d => d.container.style.opacity = '0.4');

            resultValue.textContent = data.winner;
            resultDetail.textContent = `Hope: ${data.hope}  |  Fear: ${data.fear}`;
            resultDisplay.classList.add('visible', data.winner.toLowerCase());

            setTimeout(() => {
              resultDisplay.classList.remove('visible', 'hope', 'fear');
              setTimeout(() => { area.innerHTML = ''; }, 500);
            }, 4000);
          }, 300);
        }
      }

      requestAnimationFrame(animate);
    }
    
    // Listen for updates from GM panel
    let lastDiceTimestamp = 0;
    
    function checkForUpdates() {
      // Check fear
      const fear = parseInt(localStorage.getItem('daggerheart-fear')) || 0;
      updateFear(fear);
      
      // Check for dice roll
      const diceData = localStorage.getItem('daggerheart-dice');
      if (diceData) {
        const parsed = JSON.parse(diceData);
        if (parsed.timestamp > lastDiceTimestamp) {
          lastDiceTimestamp = parsed.timestamp;
          animateDiceRoll(parsed);
        }
      }
    }
    
    // Initialize
    initSkulls();
    checkForUpdates();
    
    // Poll for updates (localStorage events don't always fire in same window)
    setInterval(checkForUpdates, 100);
    
    // Also listen for storage events (for cross-tab)
    window.addEventListener('storage', checkForUpdates);
    
    // Handle resize
    window.addEventListener('resize', () => {
      const fear = parseInt(localStorage.getItem('daggerheart-fear')) || 0;
      updateFear(fear);
    });
  </script>
</body>
</html>
