<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GM Control Panel - Daggerheart</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      min-height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Cinzel', serif;
      color: #e0e0e0;
      padding: 20px;
    }
    
    h1 {
      text-align: center;
      font-size: 1.8rem;
      background: linear-gradient(180deg, #ffd700, #b8860b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    
    .subtitle {
      text-align: center;
      color: #888;
      font-size: 0.9rem;
      margin-bottom: 30px;
    }
    
    .section {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .section h2 {
      font-size: 1.1rem;
      color: #b388ff;
      margin-bottom: 15px;
      border-bottom: 1px solid rgba(179, 136, 255, 0.3);
      padding-bottom: 8px;
    }
    
    /* Fear Controls */
    .fear-controls {
      display: flex;
      align-items: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    .fear-display {
      font-size: 2.5rem;
      font-weight: 900;
      min-width: 100px;
      text-align: center;
    }
    
    .fear-buttons {
      display: flex;
      gap: 10px;
    }
    
    .fear-btn {
      width: 50px;
      height: 50px;
      border: none;
      border-radius: 8px;
      font-size: 1.5rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .fear-btn.add {
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      color: white;
    }
    
    .fear-btn.remove {
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
    }
    
    .fear-btn:hover {
      transform: scale(1.1);
    }
    
    .fear-btn:active {
      transform: scale(0.95);
    }
    
    .fear-btn.reset {
      width: auto;
      padding: 0 20px;
      font-size: 0.9rem;
      background: #333;
      color: #aaa;
    }
    
    /* Dice Controls */
    .dice-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 10px;
    }
    
    .dice-btn {
      padding: 15px 10px;
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      background: rgba(255,255,255,0.05);
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .dice-btn:hover {
      background: rgba(179, 136, 255, 0.2);
      border-color: #b388ff;
      transform: translateY(-2px);
    }
    
    .dice-btn:active {
      transform: translateY(0);
    }
    
    .dice-btn.d20 {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(184, 134, 11, 0.2));
      border-color: #ffd700;
    }
    
    .dice-btn.hope-fear {
      grid-column: span 2;
      background: linear-gradient(90deg, rgba(255, 215, 0, 0.2), rgba(123, 45, 142, 0.2));
      border-color: #b388ff;
    }
    
    /* Last Roll Display */
    .last-roll {
      margin-top: 15px;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      text-align: center;
    }
    
    .last-roll-label {
      font-size: 0.8rem;
      color: #888;
    }
    
    .last-roll-result {
      font-size: 1.5rem;
      font-weight: 700;
      color: #ffd700;
    }
    
    /* Open Display Button */
    .open-display-btn {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      border: none;
      border-radius: 10px;
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .open-display-btn:hover {
      transform: scale(1.02);
      box-shadow: 0 5px 20px rgba(123, 45, 142, 0.4);
    }
    
    .status {
      margin-top: 10px;
      text-align: center;
      font-size: 0.8rem;
      color: #4CAF50;
    }
    
    /* Dice Notation Input */
    .dice-input-row {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .dice-notation-input {
      flex: 1;
      padding: 12px 15px;
      border-radius: 8px;
      border: 2px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      transition: border-color 0.2s;
    }

    .dice-notation-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .dice-notation-input::placeholder {
      color: #666;
    }

    .roll-btn {
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .roll-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
    }

    .roll-btn:active {
      transform: scale(0.98);
    }

    .quick-dice {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 15px;
    }

    .quick-dice-btn {
      padding: 8px 12px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      color: #aaa;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .quick-dice-btn:hover {
      background: rgba(179, 136, 255, 0.2);
      border-color: #b388ff;
      color: #e0e0e0;
    }

    /* NPC Portrait Controls */
    .npc-portrait-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .npc-upload-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .npc-upload-btn {
      padding: 12px 20px;
      border: 2px dashed rgba(179, 136, 255, 0.5);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
      text-align: center;
    }

    .npc-upload-btn:hover {
      background: rgba(179, 136, 255, 0.15);
      border-color: #b388ff;
    }

    .npc-clear-btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      background: rgba(255,68,68,0.2);
      color: #ff6b6b;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .npc-clear-btn:hover {
      background: rgba(255,68,68,0.3);
    }

    .npc-clear-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .npc-preview-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 120px;
      border-radius: 10px;
      background: rgba(0,0,0,0.3);
      overflow: hidden;
    }

    .npc-preview {
      max-width: 100%;
      max-height: 200px;
      border-radius: 8px;
      object-fit: contain;
      display: none;
    }

    .npc-preview.visible {
      display: block;
    }

    .npc-placeholder {
      color: #666;
      font-size: 0.9rem;
      text-align: center;
      padding: 20px;
    }

    .npc-placeholder.hidden {
      display: none;
    }

    /* Toggle Switch */
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 15px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
    }

    .toggle-label {
      font-size: 0.95rem;
      color: #e0e0e0;
    }

    .toggle-status {
      font-size: 0.8rem;
      color: #888;
      margin-left: 10px;
    }

    .toggle-status.visible {
      color: #4CAF50;
    }

    .toggle-switch {
      position: relative;
      width: 56px;
      height: 28px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: #333;
      border-radius: 28px;
      transition: all 0.3s;
    }

    .toggle-slider::before {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      left: 3px;
      bottom: 3px;
      background: #888;
      border-radius: 50%;
      transition: all 0.3s;
    }

    .toggle-switch input:checked + .toggle-slider {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
    }

    .toggle-switch input:checked + .toggle-slider::before {
      transform: translateX(28px);
      background: #ffd700;
    }

    .toggle-switch input:disabled + .toggle-slider {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Encounters Section */
    .encounter-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .encounter-upload-btn {
      padding: 12px 20px;
      border: 2px dashed rgba(255, 136, 0, 0.5);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      color: #ff9800;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
      text-align: center;
    }

    .encounter-upload-btn:hover {
      background: rgba(255, 136, 0, 0.15);
      border-color: #ff9800;
    }

    .encounter-clear-btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      background: rgba(255,68,68,0.2);
      color: #ff6b6b;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .encounter-clear-btn:hover {
      background: rgba(255,68,68,0.3);
    }

    .encounter-clear-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .encounter-name {
      font-size: 1.1rem;
      color: #ffd700;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      text-align: center;
    }

    .encounter-empty {
      text-align: center;
      color: #666;
      padding: 30px;
      font-size: 0.9rem;
    }

    .adversary-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .adversary-card {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.2s;
    }

    .adversary-card.spotlighted {
      border-color: #ffd700;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
    }

    .adversary-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .adversary-portrait-thumb {
      width: 60px;
      height: 60px;
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .adversary-portrait-thumb:hover {
      border-color: #b388ff;
    }

    .adversary-portrait-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .adversary-portrait-thumb .upload-icon {
      color: #666;
      font-size: 1.5rem;
    }

    .adversary-portrait-thumb.has-default {
      border-color: rgba(107, 91, 149, 0.4);
    }

    .adversary-portrait-thumb.has-default:hover {
      border-color: #b388ff;
    }

    .adversary-portrait-thumb .default-indicator {
      position: absolute;
      bottom: 2px;
      right: 2px;
      background: rgba(107, 91, 149, 0.8);
      color: #e0d0ff;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      font-size: 10px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .adversary-portrait-gallery {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      margin-top: 5px;
    }

    .gallery-thumb {
      width: 35px;
      height: 35px;
      border-radius: 4px;
      overflow: hidden;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }

    .gallery-thumb:hover {
      border-color: #b388ff;
    }

    .gallery-thumb.active {
      border-color: #ffd700;
    }

    .gallery-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .add-image-btn {
      width: 35px;
      height: 35px;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
      border: 1px dashed rgba(255,255,255,0.2);
      color: #666;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      transition: all 0.2s;
    }

    .add-image-btn:hover {
      background: rgba(179, 136, 255, 0.15);
      border-color: #b388ff;
      color: #b388ff;
    }

    .adversary-info {
      flex: 1;
    }

    .adversary-name {
      font-size: 1rem;
      font-weight: 700;
      color: #e0e0e0;
      margin-bottom: 4px;
    }

    .adversary-tier {
      font-size: 0.75rem;
      color: #888;
    }

    .adversary-actions {
      display: flex;
      gap: 8px;
    }

    .spotlight-btn {
      padding: 8px 14px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .spotlight-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 3px 10px rgba(255, 215, 0, 0.4);
    }

    .spotlight-btn.active {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      color: #fff;
    }

    .stat-toggle-btn {
      padding: 8px 12px;
      border: 1px solid rgba(179, 136, 255, 0.3);
      border-radius: 6px;
      background: transparent;
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .stat-toggle-btn:hover {
      background: rgba(179, 136, 255, 0.15);
    }

    .stat-toggle-btn.expanded {
      background: rgba(179, 136, 255, 0.2);
    }

    .adversary-stats {
      display: none;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .adversary-stats.visible {
      display: block;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
      margin-bottom: 10px;
    }

    .stat-item {
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 6px;
      text-align: center;
    }

    .stat-label {
      font-size: 0.65rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .stat-value {
      font-size: 1rem;
      font-weight: 700;
      color: #ffd700;
    }

    .traits-section, .abilities-section {
      margin-top: 8px;
    }

    .section-label {
      font-size: 0.7rem;
      color: #b388ff;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 5px;
    }

    .trait-tag {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(179, 136, 255, 0.2);
      border-radius: 4px;
      font-size: 0.75rem;
      color: #e0e0e0;
      margin-right: 5px;
      margin-bottom: 5px;
    }

    .ability-item {
      font-size: 0.8rem;
      color: #ccc;
      padding: 5px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .ability-item:last-child {
      border-bottom: none;
    }

    .hide-spotlight-btn {
      width: 100%;
      padding: 10px;
      margin-top: 15px;
      border: none;
      border-radius: 8px;
      background: rgba(255,68,68,0.2);
      color: #ff6b6b;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .hide-spotlight-btn:hover {
      background: rgba(255,68,68,0.3);
    }

    .hide-spotlight-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    /* Sample Encounter Button */
    .sample-btn {
      padding: 8px 16px;
      border: 1px solid rgba(179, 136, 255, 0.3);
      border-radius: 6px;
      background: transparent;
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .sample-btn:hover {
      background: rgba(179, 136, 255, 0.15);
    }

    /* Adversary Search Autocomplete */
    .adversary-search-container {
      position: relative;
      margin-bottom: 15px;
    }

    .adversary-search-input {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid rgba(76, 175, 80, 0.4);
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.95rem;
      outline: none;
      transition: all 0.2s;
    }

    .adversary-search-input::placeholder {
      color: #666;
    }

    .adversary-search-input:focus {
      border-color: #4CAF50;
      background: rgba(0,0,0,0.4);
    }

    .autocomplete-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: #1a1a2e;
      border: 2px solid #4CAF50;
      border-top: none;
      border-radius: 0 0 8px 8px;
      z-index: 100;
      display: none;
    }

    .autocomplete-dropdown.visible {
      display: block;
    }

    .autocomplete-item {
      padding: 10px 16px;
      cursor: pointer;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      transition: all 0.15s;
    }

    .autocomplete-item:last-child {
      border-bottom: none;
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
      background: rgba(76, 175, 80, 0.2);
    }

    .autocomplete-item-name {
      font-weight: 700;
      color: #ffd700;
      font-size: 0.95rem;
    }

    .autocomplete-item-tier {
      font-size: 0.75rem;
      color: #888;
      margin-left: 8px;
    }

    .autocomplete-item-role {
      font-size: 0.75rem;
      color: #b388ff;
      margin-left: 8px;
    }

    .autocomplete-item-stats {
      font-size: 0.7rem;
      color: #666;
      margin-top: 2px;
    }

    .autocomplete-no-results {
      padding: 15px;
      text-align: center;
      color: #666;
      font-size: 0.85rem;
    }

    .loading-indicator {
      text-align: center;
      padding: 10px;
      color: #888;
      font-size: 0.85rem;
    }

    @keyframes flashGreen {
      0% {
        box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
        background: rgba(76, 175, 80, 0.3);
      }
      100% {
        box-shadow: 0 0 20px 10px rgba(76, 175, 80, 0);
        background: rgba(0,0,0,0.3);
      }
    }

    /* HP/Stress Tracker */
    .adversary-trackers {
      display: flex;
      gap: 12px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .tracker {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(0,0,0,0.3);
      padding: 6px 10px;
      border-radius: 6px;
    }

    .tracker-label {
      font-size: 0.7rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 45px;
    }

    .tracker-hp .tracker-label {
      color: #ff6b6b;
    }

    .tracker-stress .tracker-label {
      color: #b388ff;
    }

    .tracker-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .tracker-btn {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      color: #ccc;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .tracker-btn:hover {
      background: rgba(255,255,255,0.2);
    }

    .tracker-btn.minus:hover {
      background: rgba(255,68,68,0.3);
      color: #ff6b6b;
    }

    .tracker-btn.plus:hover {
      background: rgba(102,187,106,0.3);
      color: #66bb6a;
    }

    .tracker-value {
      min-width: 50px;
      text-align: center;
      font-size: 0.9rem;
      font-weight: 700;
    }

    .tracker-hp .tracker-value {
      color: #ff6b6b;
    }

    .tracker-stress .tracker-value {
      color: #b388ff;
    }

    .tracker-value.depleted {
      color: #666;
    }

    .tracker-value.critical {
      color: #ff4444;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .adversary-card.defeated {
      opacity: 0.5;
      border-color: rgba(255,68,68,0.3);
    }

    .adversary-card.defeated .adversary-name {
      text-decoration: line-through;
      color: #888;
    }

    .defeated-badge {
      background: rgba(255,68,68,0.2);
      color: #ff6b6b;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.7rem;
      margin-left: 8px;
    }

    /* Condition Toggles */
    .condition-toggles {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .condition-toggle {
      padding: 6px 12px;
      border: 2px solid;
      border-radius: 6px;
      background: transparent;
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .condition-toggle:hover {
      transform: scale(1.05);
    }

    /* Hidden condition toggle */
    .condition-toggle.hidden-toggle {
      border-color: rgba(106, 90, 205, 0.4);
      color: #9370db;
    }

    .condition-toggle.hidden-toggle:hover {
      background: rgba(106, 90, 205, 0.15);
      border-color: #9370db;
    }

    .condition-toggle.hidden-toggle.active {
      background: rgba(106, 90, 205, 0.3);
      border-color: #9370db;
      box-shadow: 0 0 10px rgba(106, 90, 205, 0.4);
    }

    /* Restrained condition toggle */
    .condition-toggle.restrained-toggle {
      border-color: rgba(112, 128, 144, 0.4);
      color: #b0c4de;
    }

    .condition-toggle.restrained-toggle:hover {
      background: rgba(112, 128, 144, 0.15);
      border-color: #b0c4de;
    }

    .condition-toggle.restrained-toggle.active {
      background: rgba(112, 128, 144, 0.3);
      border-color: #b0c4de;
      box-shadow: 0 0 10px rgba(112, 128, 144, 0.4);
    }

    /* Vulnerable condition toggle */
    .condition-toggle.vulnerable-toggle {
      border-color: rgba(218, 165, 32, 0.4);
      color: #ffd700;
    }

    .condition-toggle.vulnerable-toggle:hover {
      background: rgba(218, 165, 32, 0.15);
      border-color: #ffd700;
    }

    .condition-toggle.vulnerable-toggle.active {
      background: rgba(218, 165, 32, 0.3);
      border-color: #ffd700;
      box-shadow: 0 0 10px rgba(218, 165, 32, 0.4);
    }

    /* Condition badges next to name */
    .condition-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.6rem;
      margin-left: 5px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .condition-badge.hidden-badge {
      background: rgba(106, 90, 205, 0.25);
      color: #9370db;
    }

    .condition-badge.restrained-badge {
      background: rgba(112, 128, 144, 0.25);
      color: #b0c4de;
    }

    .condition-badge.vulnerable-badge {
      background: rgba(218, 165, 32, 0.25);
      color: #ffd700;
    }

    /* Image Source Dialog */
    .image-dialog-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .image-dialog-overlay.visible {
      display: flex;
    }

    .image-dialog {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 2px solid rgba(179, 136, 255, 0.4);
      border-radius: 16px;
      padding: 24px;
      max-width: 420px;
      width: 90%;
    }

    .image-dialog h3 {
      color: #b388ff;
      margin-bottom: 16px;
      font-size: 1.1rem;
    }

    .image-dialog-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .image-dialog-btn {
      padding: 14px 20px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
    }

    .image-dialog-btn:hover {
      background: rgba(179, 136, 255, 0.2);
      border-color: #b388ff;
    }

    .image-dialog-btn .btn-icon {
      margin-right: 10px;
    }

    .image-dialog-btn .btn-subtitle {
      display: block;
      font-size: 0.75rem;
      color: #888;
      margin-top: 4px;
      font-family: sans-serif;
    }

    .url-input-section {
      display: none;
      margin-top: 16px;
    }

    .url-input-section.visible {
      display: block;
    }

    .url-input-section label {
      display: block;
      color: #b388ff;
      font-size: 0.9rem;
      margin-bottom: 8px;
    }

    .url-input-row {
      display: flex;
      gap: 8px;
    }

    .url-input-row input {
      flex: 1;
      padding: 10px 12px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.3);
      color: #e0e0e0;
      font-family: sans-serif;
      font-size: 0.9rem;
    }

    .url-input-row input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .url-input-row input::placeholder {
      color: #666;
    }

    .url-add-btn {
      padding: 10px 16px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      color: white;
      font-family: 'Cinzel', serif;
      cursor: pointer;
      transition: all 0.2s;
    }

    .url-add-btn:hover {
      transform: scale(1.05);
    }

    .url-add-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .image-dialog-cancel {
      margin-top: 16px;
      padding: 10px;
      border: none;
      background: transparent;
      color: #888;
      font-family: 'Cinzel', serif;
      cursor: pointer;
      width: 100%;
      text-align: center;
    }

    .image-dialog-cancel:hover {
      color: #b388ff;
    }

    .url-preview {
      margin-top: 12px;
      text-align: center;
    }

    .url-preview img {
      max-width: 150px;
      max-height: 150px;
      border-radius: 8px;
      border: 2px solid rgba(179, 136, 255, 0.3);
    }

    .url-preview-error {
      color: #ff6b6b;
      font-size: 0.85rem;
      margin-top: 8px;
    }

    /* PeerJS Connection UI */
    .connection-section {
      display: flex;
      align-items: center;
      gap: 15px;
      flex-wrap: wrap;
    }

    .room-code-display {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 16px;
      border-radius: 8px;
      border: 2px solid rgba(179, 136, 255, 0.3);
    }

    .room-code-display .room-code-label {
      color: #888;
      font-size: 0.9rem;
    }

    .room-code-display .room-code-value {
      font-size: 1.3rem;
      font-weight: 700;
      color: #ffd700;
      letter-spacing: 3px;
    }

    .copy-code-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.1rem;
      padding: 4px;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .copy-code-btn:hover {
      opacity: 1;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9rem;
    }

    .connection-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff9800;
      animation: pulse 2s infinite;
    }

    .connection-indicator.connected {
      background: #4caf50;
      animation: none;
    }

    .connection-indicator.error {
      background: #f44336;
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Battle Map Controls */
    .map-controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 15px;
    }

    .map-upload-btn {
      padding: 12px 20px;
      border: 2px dashed rgba(179, 136, 255, 0.5);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .map-upload-btn:hover {
      background: rgba(179, 136, 255, 0.15);
      border-color: #b388ff;
    }

    .map-preview {
      width: 100%;
      max-height: 150px;
      object-fit: contain;
      border-radius: 8px;
      margin: 10px 0;
      background: rgba(0,0,0,0.3);
    }

    .map-toggle-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      margin-bottom: 10px;
    }

    .map-toggle-label {
      font-size: 0.9rem;
      color: #e0e0e0;
    }

    .token-list {
      max-height: 300px;
      overflow-y: auto;
      margin-top: 10px;
    }

    .token-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
      margin-bottom: 6px;
    }

    .token-item.player {
      border-left: 3px solid #4CAF50;
    }

    .token-item.adversary {
      border-left: 3px solid #f44336;
    }

    .token-thumb {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-size: cover;
      background-position: center;
      border: 2px solid;
      flex-shrink: 0;
    }

    .token-thumb.player {
      border-color: #4CAF50;
    }

    .token-thumb.adversary {
      border-color: #f44336;
    }

    .token-info {
      flex: 1;
      min-width: 0;
    }

    .token-name {
      font-size: 0.85rem;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .token-position {
      display: flex;
      gap: 5px;
      margin-top: 4px;
    }

    .token-coord-input {
      width: 50px;
      padding: 4px 6px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      text-align: center;
    }

    .token-coord-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .token-remove-btn {
      padding: 6px 10px;
      background: rgba(244, 67, 54, 0.2);
      border: 1px solid rgba(244, 67, 54, 0.5);
      border-radius: 4px;
      color: #f44336;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .token-remove-btn:hover {
      background: rgba(244, 67, 54, 0.3);
    }

    .add-player-btn {
      width: 100%;
      padding: 10px;
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid rgba(76, 175, 80, 0.5);
      border-radius: 6px;
      color: #4CAF50;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 10px;
    }

    .add-player-btn:hover {
      background: rgba(76, 175, 80, 0.3);
    }

    .grid-toggle-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
      margin-top: 10px;
    }

    .map-placeholder {
      padding: 40px 20px;
      text-align: center;
      color: #666;
      font-size: 0.85rem;
      border: 2px dashed rgba(255,255,255,0.1);
      border-radius: 8px;
    }

    /* Token positioning modal */
    .positioning-modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 10000;
      align-items: center;
      justify-content: center;
    }

    .positioning-modal.visible {
      display: flex;
    }

    .positioning-container {
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      background: #1a1a2e;
      border: 2px solid #b388ff;
      border-radius: 12px;
      padding: 20px;
    }

    .positioning-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .positioning-title {
      color: #b388ff;
      font-size: 1.1rem;
    }

    .positioning-close {
      background: none;
      border: none;
      color: #888;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 5px 10px;
    }

    .positioning-close:hover {
      color: #b388ff;
    }

    .positioning-map {
      position: relative;
      max-width: 80vw;
      max-height: 70vh;
      overflow: auto;
      border: 2px solid rgba(179, 136, 255, 0.3);
      border-radius: 8px;
      cursor: crosshair;
    }

    .positioning-map img {
      display: block;
      max-width: 100%;
      height: auto;
    }

    .positioning-marker {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 3px solid;
      background-size: cover;
      background-position: center;
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 10;
    }

    .positioning-marker.player {
      border-color: #4CAF50;
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.8);
    }

    .positioning-marker.adversary {
      border-color: #f44336;
      box-shadow: 0 0 15px rgba(244, 67, 54, 0.8);
    }

    .positioning-grid {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .token-actions {
      display: flex;
      gap: 5px;
      flex-direction: column;
    }

    .token-position-btn {
      padding: 4px 8px;
      background: rgba(179, 136, 255, 0.2);
      border: 1px solid rgba(179, 136, 255, 0.5);
      border-radius: 4px;
      color: #b388ff;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .token-position-btn:hover {
      background: rgba(179, 136, 255, 0.3);
    }

    .token-upload-btn {
      padding: 4px 8px;
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid rgba(76, 175, 80, 0.5);
      border-radius: 4px;
      color: #4CAF50;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .token-upload-btn:hover {
      background: rgba(76, 175, 80, 0.3);
    }

    .token-visibility-btn {
      padding: 4px 8px;
      background: rgba(255, 193, 7, 0.2);
      border: 1px solid rgba(255, 193, 7, 0.5);
      border-radius: 4px;
      color: #ffc107;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .token-visibility-btn:hover {
      background: rgba(255, 193, 7, 0.3);
    }

    .token-visibility-btn.hidden {
      background: rgba(158, 158, 158, 0.2);
      border-color: rgba(158, 158, 158, 0.5);
      color: #9e9e9e;
    }

    .token-item.hidden {
      opacity: 0.5;
    }
  </style>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
</head>
<body>
  <h1>‚öîÔ∏è GM Control Panel</h1>
  <p class="subtitle">Your players don't see this screen</p>
  
  <!-- Open Player Display -->
  <div class="section">
    <button class="open-display-btn" onclick="openPlayerDisplay()">
      üñ•Ô∏è Open Player Display Window
    </button>
    <p class="status" id="status">Click above to open the player-facing display</p>
  </div>

  <!-- Battle Map -->
  <div class="section">
    <button class="open-display-btn" onclick="openBattleMap()" style="background: linear-gradient(135deg, #1e88e5, #0d47a1);">
      üó∫Ô∏è Open Battle Map Window
    </button>
    <p class="status" id="battleMapStatus">Click above to open the battle map display</p>

    <div style="margin-top: 20px;">
      <h2>üó∫Ô∏è Map Control</h2>

      <input type="file" id="mapImageInput" accept="image/*" style="display: none;" onchange="handleMapUpload(event)">

      <div id="mapPreviewContainer" style="display: none;">
        <img id="mapPreview" class="map-preview" alt="Map Preview">
        <div class="map-toggle-row">
          <div>
            <span class="map-toggle-label">Show Map to Players</span>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="mapVisibilityToggle" onchange="toggleMapVisibility()">
            <span class="toggle-slider"></span>
          </label>
        </div>
      </div>

      <div id="mapPlaceholder" class="map-placeholder">
        <button class="map-upload-btn" onclick="document.getElementById('mapImageInput').click()">
          üìÅ Upload Battle Map
        </button>
        <div style="margin-top: 10px; font-size: 0.75rem;">
          Upload a map image to display on the battle map portal
        </div>
      </div>

      <div class="grid-toggle-row">
        <span style="font-size: 0.85rem; color: #e0e0e0;">Grid Overlay</span>
        <label class="toggle-switch">
          <input type="checkbox" id="gridToggle" onchange="toggleGrid()">
          <span class="toggle-slider"></span>
        </label>
      </div>

      <h2 style="margin-top: 20px;">üéØ Tokens</h2>
      <div id="tokenList" class="token-list">
        <!-- Tokens will be dynamically added here -->
      </div>
      <button class="add-player-btn" onclick="addPlayerToken()">+ Add Player Token</button>
    </div>
  </div>

  <!-- Remote Connection -->
  <div class="section">
    <h2>üì° Remote Connection</h2>
    <p style="color: #888; font-size: 0.85rem; margin-bottom: 12px;">Share this code with your Player Display</p>
    <div class="connection-section">
      <div class="room-code-display">
        <span class="room-code-label">Room Code:</span>
        <span class="room-code-value" id="roomCodeDisplay">----</span>
        <button class="copy-code-btn" onclick="copyRoomCode()" title="Copy to clipboard">üìã</button>
      </div>
      <div class="connection-status" id="connectionStatus">
        <div class="connection-indicator" id="connectionIndicator"></div>
        <span id="connectionText">Waiting for Player Display...</span>
      </div>
    </div>
  </div>
  
  <!-- Fear Tracker -->
  <div class="section">
    <h2>‚ò†Ô∏è Fear Tracker</h2>
    <div class="fear-controls">
      <div class="fear-display" id="fearDisplay">0</div>
      <div class="fear-buttons">
        <button class="fear-btn remove" onclick="adjustFear(-1)">‚àí</button>
        <button class="fear-btn add" onclick="adjustFear(1)">+</button>
        <button class="fear-btn reset" onclick="resetFear()">Reset</button>
      </div>
    </div>
  </div>

  <!-- NPC Portrait -->
  <div class="section">
    <h2>üé≠ NPC Portrait</h2>
    <div class="npc-portrait-container">
      <div class="npc-upload-row">
        <input type="file" id="npcImageInput" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
        <button class="npc-upload-btn" onclick="document.getElementById('npcImageInput').click()">
          üìÅ Browse for Image...
        </button>
        <button class="npc-clear-btn" id="clearImageBtn" onclick="clearNpcImage()" disabled>
          Clear
        </button>
      </div>
      <div class="npc-preview-container">
        <img id="npcPreview" class="npc-preview" alt="NPC Preview">
        <div id="npcPlaceholder" class="npc-placeholder">No image selected</div>
      </div>
      <div class="toggle-row">
        <div>
          <span class="toggle-label">Show to Players</span>
          <span class="toggle-status" id="toggleStatus">Hidden</span>
        </div>
        <label class="toggle-switch">
          <input type="checkbox" id="npcVisibilityToggle" onchange="toggleNpcVisibility()" disabled>
          <span class="toggle-slider"></span>
        </label>
      </div>
    </div>
  </div>

  <!-- Encounters -->
  <div class="section">
    <h2>‚öîÔ∏è Encounters</h2>
    <div class="encounter-controls">
      <input type="file" id="encounterFolderInput" webkitdirectory directory style="display: none;" onchange="handleEncounterFolderUpload(event)">
      <input type="file" id="encounterFileInput" accept=".json" style="display: none;" onchange="handleEncounterUpload(event)">
      <input type="file" id="adversaryImageInput" accept="image/*" style="display: none;" multiple onchange="handleAdversaryImageUpload(event)">
      <button class="encounter-upload-btn" onclick="document.getElementById('encounterFolderInput').click()">
        üìÅ Load Encounter Folder
      </button>
      <button class="encounter-clear-btn" id="clearEncounterBtn" onclick="clearEncounter()" disabled>
        Clear
      </button>
      <button class="sample-btn" onclick="loadSampleEncounter()">
        Sample
      </button>
    </div>
    <div class="adversary-search-container">
      <input type="text"
             id="adversarySearchInput"
             class="adversary-search-input"
             placeholder="üîç Search adversaries (e.g., skeleton, dragon, ooze...)"
             autocomplete="off">
      <div id="autocompleteDropdown" class="autocomplete-dropdown"></div>
    </div>
    <div id="encounterContainer">
      <div class="encounter-empty">
        No encounter loaded.<br>
        <small style="color: #888; display: block; margin-top: 8px;">
          Create a folder with encounter.json + images.<br>
          Use "portrait": "filename.png" in your JSON.
        </small>
      </div>
    </div>
    <button class="hide-spotlight-btn" id="hideSpotlightBtn" onclick="hideSpotlight()" disabled>
      Hide Spotlight
    </button>
  </div>

  <!-- Dice Roller -->
  <div class="section">
    <h2>üé≤ Dice Roller</h2>

    <div class="dice-input-row">
      <input type="text" id="diceNotation" class="dice-notation-input" placeholder="e.g. 1d20+1d6+2" value="1d20">
      <button class="roll-btn" onclick="rollNotation()">Roll</button>
    </div>

    <div class="quick-dice">
      <button class="quick-dice-btn" onclick="setNotation('1d4')">d4</button>
      <button class="quick-dice-btn" onclick="setNotation('1d6')">d6</button>
      <button class="quick-dice-btn" onclick="setNotation('1d8')">d8</button>
      <button class="quick-dice-btn" onclick="setNotation('1d10')">d10</button>
      <button class="quick-dice-btn" onclick="setNotation('1d12')">d12</button>
      <button class="quick-dice-btn" onclick="setNotation('1d20')">d20</button>
      <button class="quick-dice-btn" onclick="setNotation('2d6')">2d6</button>
      <button class="quick-dice-btn" onclick="setNotation('1d20+5')">d20+5</button>
    </div>

    <div class="dice-grid">
      <button class="dice-btn hope-fear" onclick="rollHopeFear()">‚öîÔ∏è Hope / Fear</button>
    </div>

    <div class="last-roll">
      <div class="last-roll-label">Last Roll</div>
      <div class="last-roll-result" id="lastRoll">‚Äî</div>
    </div>
  </div>

  <!-- Token Positioning Modal -->
  <div id="positioningModal" class="positioning-modal" onclick="closePositioningModal(event)">
    <div class="positioning-container" onclick="event.stopPropagation()">
      <div class="positioning-header">
        <div class="positioning-title" id="positioningTitle">Position Token</div>
        <button class="positioning-close" onclick="closePositioningModal()">√ó</button>
      </div>
      <div class="positioning-map" id="positioningMapContainer">
        <img id="positioningMapImage" src="" alt="Map">
        <canvas id="positioningGrid" class="positioning-grid"></canvas>
      </div>
    </div>
  </div>

  <!-- Player Token Image Upload -->
  <input type="file" id="playerTokenImageInput" accept="image/*" style="display: none;" onchange="handlePlayerTokenImageUpload(event)">

  <!-- Footer -->
  <div class="footer" style="text-align: center; padding: 30px 20px; margin-top: 20px; border-top: 1px solid rgba(179, 136, 255, 0.2);">
    <a href="encounter-generator.html" style="color: #b388ff; text-decoration: none; font-size: 0.95rem; padding: 10px 20px; border: 1px solid rgba(179, 136, 255, 0.3); border-radius: 8px; transition: all 0.2s;">
      Encounter Generator Tool
    </a>
  </div>

  <!-- Image Source Dialog -->
  <div id="imageSourceDialog" class="image-dialog-overlay" onclick="closeImageDialog(event)">
    <div class="image-dialog" onclick="event.stopPropagation()">
      <h3>Add Portrait Image</h3>
      <div class="image-dialog-options">
        <button class="image-dialog-btn" onclick="chooseFileUpload()">
          <span class="btn-icon">üìÅ</span>Upload from Computer
          <span class="btn-subtitle">Select an image file from your device</span>
        </button>
        <button class="image-dialog-btn" onclick="showUrlInput()">
          <span class="btn-icon">üîó</span>Use Image URL
          <span class="btn-subtitle">Paste a link to an image (CDN, web hosting, etc.)</span>
        </button>
      </div>
      <div id="urlInputSection" class="url-input-section">
        <label>Image URL:</label>
        <div class="url-input-row">
          <input type="url" id="imageUrlInput" placeholder="https://example.com/image.png" onkeyup="handleUrlKeyup(event)" oninput="previewUrlImage()">
          <button class="url-add-btn" id="urlAddBtn" onclick="addUrlPortrait()" disabled>Add</button>
        </div>
        <div id="urlPreview" class="url-preview"></div>
      </div>
      <button class="image-dialog-cancel" onclick="closeImageDialog()">Cancel</button>
    </div>
  </div>

  <script>
    let currentFear = 0;
    let currentNpcImage = null;
    let npcVisible = false;

    // Encounter state
    let currentEncounter = null;
    let spotlightedAdversary = null;
    let pendingImageUploadAdversaryId = null;

    // Battle Map state
    let currentMap = null;
    let mapVisible = false;
    let battleMapTokens = [];
    let gridVisible = false;
    let nextPlayerTokenId = 1;
    let positioningTokenId = null;
    let pendingPlayerTokenImageId = null;

    // Adversary database (parsed from markdown)
    let adversaryDatabase = [];
    let selectedAutocompleteIndex = -1;

    // PeerJS connection state
    let peer = null;
    let playerConnection = null;

    // Default NPC image (shadowy silhouette) - embedded SVG as data URL
    const DEFAULT_NPC_IMAGE = `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
      <defs>
        <radialGradient id="shadowGlow" cx="50%" cy="50%" r="50%">
          <stop offset="0%" style="stop-color:#1a1a2e"/>
          <stop offset="70%" style="stop-color:#0d0d15"/>
          <stop offset="100%" style="stop-color:#050508"/>
        </radialGradient>
        <filter id="blur"><feGaussianBlur in="SourceGraphic" stdDeviation="3"/></filter>
        <linearGradient id="silhouetteGrad" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" style="stop-color:#2d2d44"/>
          <stop offset="100%" style="stop-color:#15151f"/>
        </linearGradient>
      </defs>
      <rect width="200" height="200" fill="url(#shadowGlow)"/>
      <ellipse cx="100" cy="180" rx="60" ry="20" fill="#1a1a2e" filter="url(#blur)" opacity="0.8"/>
      <path d="M100 30 C75 30 60 50 60 75 C60 95 75 105 85 110 L75 115 C55 120 40 140 40 165 L40 190 L70 190 L75 150 L85 145 L90 190 L110 190 L115 145 L125 150 L130 190 L160 190 L160 165 C160 140 145 120 125 115 L115 110 C125 105 140 95 140 75 C140 50 125 30 100 30Z" fill="url(#silhouetteGrad)"/>
      <path d="M100 25 C70 25 55 50 55 80 C55 95 65 105 75 110 L65 115 C65 115 50 175 55 190 L70 190 L80 140 L100 135 L120 140 L130 190 L145 190 C150 175 135 115 135 115 L125 110 C135 105 145 95 145 80 C145 50 130 25 100 25Z" fill="#15151f" opacity="0.7"/>
      <ellipse cx="85" cy="60" rx="4" ry="3" fill="#4a4a6a" opacity="0.4"/>
      <ellipse cx="115" cy="60" rx="4" ry="3" fill="#4a4a6a" opacity="0.4"/>
      <text x="100" y="120" font-family="Georgia, serif" font-size="48" font-weight="bold" fill="#6b5b95" text-anchor="middle" opacity="0.6">?</text>
    </svg>`)}`;

    // Default NPC images directory path (for loading from folder uploads)
    const DEFAULT_NPC_IMAGES_PATH = 'images/npcs/';

    // Map of creature types/themes to default image filenames
    // Users can add images like 'undead.png', 'beast.png', etc. to images/npcs/
    const DEFAULT_NPC_IMAGE_MAP = {
      // Add creature type mappings here - these will be matched against
      // creature names, themes, or traits to find appropriate default images
      // Example: 'undead': 'undead.png', 'beast': 'beast.png'
    };

    // Helper function to get the appropriate default image for an adversary
    function getDefaultImageForAdversary(adv) {
      // First, check if there's a defaultPortrait specified in the adversary data
      if (adv.defaultPortrait) {
        return `${DEFAULT_NPC_IMAGES_PATH}${adv.defaultPortrait}`;
      }

      // Check themes for a matching default image
      if (adv.themes && Array.isArray(adv.themes)) {
        for (const theme of adv.themes) {
          const themeKey = theme.toLowerCase();
          if (DEFAULT_NPC_IMAGE_MAP[themeKey]) {
            return `${DEFAULT_NPC_IMAGES_PATH}${DEFAULT_NPC_IMAGE_MAP[themeKey]}`;
          }
        }
      }

      // Check traits for a matching default image
      if (adv.traits && Array.isArray(adv.traits)) {
        for (const trait of adv.traits) {
          const traitKey = trait.toLowerCase();
          if (DEFAULT_NPC_IMAGE_MAP[traitKey]) {
            return `${DEFAULT_NPC_IMAGES_PATH}${DEFAULT_NPC_IMAGE_MAP[traitKey]}`;
          }
        }
      }

      // Check creature name for keywords
      if (adv.name) {
        const nameLower = adv.name.toLowerCase();
        for (const [key, filename] of Object.entries(DEFAULT_NPC_IMAGE_MAP)) {
          if (nameLower.includes(key)) {
            return `${DEFAULT_NPC_IMAGES_PATH}${filename}`;
          }
        }
      }

      // Fall back to the embedded default silhouette
      return DEFAULT_NPC_IMAGE;
    }

    // ========== PeerJS Connection (GM hosts, Player connects) ==========

    let roomCode = null;

    // Generate a friendly room code
    function generateRoomCode() {
      const adjectives = ['RED', 'BLUE', 'GOLD', 'DARK', 'WILD', 'IRON', 'FIRE', 'FROST', 'STORM', 'SHADOW'];
      const nouns = ['WOLF', 'HAWK', 'BEAR', 'LION', 'RAVEN', 'DRAGON', 'SWORD', 'CROWN', 'FLAME', 'BLADE'];
      const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
      const noun = nouns[Math.floor(Math.random() * nouns.length)];
      const num = Math.floor(Math.random() * 100).toString().padStart(2, '0');
      return `${adj}-${noun}-${num}`;
    }

    // Copy room code to clipboard
    function copyRoomCode() {
      if (roomCode) {
        navigator.clipboard.writeText(roomCode).then(() => {
          const btn = document.querySelector('.copy-code-btn');
          btn.textContent = '‚úì';
          setTimeout(() => { btn.textContent = 'üìã'; }, 1500);
        });
      }
    }

    // Initialize PeerJS as host
    function initPeerHost() {
      roomCode = generateRoomCode();
      document.getElementById('roomCodeDisplay').textContent = roomCode;

      const indicator = document.getElementById('connectionIndicator');
      const text = document.getElementById('connectionText');

      // Create peer with room code as ID (GM hosts)
      // Using explicit config for better reliability
      peer = new Peer('dh-' + roomCode, {
        debug: 2, // More verbose logging
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' }
          ]
        }
      });

      peer.on('open', (id) => {
        console.log('GM hosting with room code:', roomCode);
        text.textContent = 'Ready - Waiting for Player Display...';
      });

      peer.on('connection', (conn) => {
        console.log('Player Display connection received, waiting for data channel...');

        // Update UI to show connected state
        indicator.className = 'connection-indicator connected';
        text.textContent = 'Player Display connecting...';

        conn.on('open', () => {
          console.log('Data channel open! Connection ready.');
          playerConnection = conn;
          text.textContent = 'Player Display connected!';
          // Send initial sync when connection is fully open
          sendFullSync();
        });

        conn.on('data', (data) => {
          // Handle incoming data from connected clients (e.g., battle map)
          if (data && data.type === 'battleMapConnected') {
            console.log('Battle map connected, sending full sync');
            sendBattleMapSync();
          }
        });

        conn.on('close', () => {
          console.log('Player Display disconnected');
          playerConnection = null;
          indicator.className = 'connection-indicator';
          text.textContent = 'Waiting for Player Display...';
        });

        conn.on('error', (err) => {
          console.error('Connection error:', err);
        });
      });

      peer.on('disconnected', () => {
        console.log('Disconnected from signaling server, attempting reconnect...');
        text.textContent = 'Reconnecting to server...';
        // Try to reconnect
        setTimeout(() => {
          if (peer && !peer.destroyed) {
            peer.reconnect();
          }
        }, 2000);
      });

      peer.on('error', (err) => {
        console.error('PeerJS error:', err);
        const indicator = document.getElementById('connectionIndicator');
        const text = document.getElementById('connectionText');

        if (err.type === 'unavailable-id') {
          // Room code already taken, generate a new one
          roomCode = generateRoomCode();
          document.getElementById('roomCodeDisplay').textContent = roomCode;
          peer.destroy();
          setTimeout(initPeerHost, 1000);
        } else {
          indicator.className = 'connection-indicator error';
          text.textContent = 'Connection error';
        }
      });
    }

    // Send data to player display via PeerJS
    function sendToPlayer(data) {
      if (playerConnection && playerConnection.open) {
        console.log('Sending to player:', data.type);
        try {
          playerConnection.send(data);
        } catch (e) {
          console.error('Failed to send:', e);
        }
      } else {
        console.log('Cannot send - connection not open. playerConnection:', !!playerConnection, 'open:', playerConnection?.open);
      }
    }

    // Send full state sync to player
    function sendFullSync() {
      if (!playerConnection || !playerConnection.open) return;

      const syncData = {
        type: 'sync',
        fear: currentFear,
        spotlight: null
      };

      // Include spotlight data if there's a spotlighted adversary
      if (spotlightedAdversary && currentEncounter) {
        const adversary = currentEncounter.adversaries.find(a => a.id === spotlightedAdversary);
        if (adversary) {
          const isDefeated = adversary.hp !== undefined && adversary.currentHp <= 0;
          const hasCustomPortrait = adversary.portraits && adversary.portraits.length > 0;
          const imageToShow = hasCustomPortrait
            ? adversary.portraits[adversary.activePortraitIndex || 0]
            : getDefaultImageForAdversary(adversary);

          syncData.spotlight = {
            visible: true,
            adversaryId: adversary.id,
            name: adversary.name,
            image: imageToShow,
            isDefaultImage: !hasCustomPortrait,
            defeated: isDefeated,
            conditions: adversary.conditions || {},
            timestamp: Date.now()
          };
        }
      }

      sendToPlayer(syncData);

      // Also send battle map sync
      sendBattleMapSync();
    }

    function sendBattleMapSync() {
      const mapSyncData = {
        type: 'mapSync',
        map: currentMap ? {
          type: 'map',
          visible: mapVisible,
          mapImage: mapVisible ? currentMap.mapImage : null,
          gridSize: currentMap.gridSize
        } : null,
        tokens: {
          type: 'tokens',
          tokens: battleMapTokens
        },
        grid: {
          type: 'grid',
          visible: gridVisible
        },
        timestamp: Date.now()
      };

      sendToBattleMap(mapSyncData);
    }

    // Initialize from localStorage
    function init() {
      const stored = localStorage.getItem('daggerheart-fear');
      if (stored) {
        currentFear = parseInt(stored) || 0;
        updateFearDisplay();
      }

      // Initialize NPC portrait state
      const npcData = localStorage.getItem('daggerheart-npc');
      if (npcData) {
        const parsed = JSON.parse(npcData);
        if (parsed.image) {
          currentNpcImage = parsed.image;
          npcVisible = parsed.visible || false;
          updateNpcPreview();
        }
      }

      // Initialize encounter state
      const encounterData = localStorage.getItem('daggerheart-encounter');
      if (encounterData) {
        const parsed = JSON.parse(encounterData);
        currentEncounter = parsed.encounter;
        renderEncounter();
      }

      // Initialize spotlight state
      const spotlightData = localStorage.getItem('daggerheart-spotlight');
      if (spotlightData) {
        const parsed = JSON.parse(spotlightData);
        if (parsed.visible && parsed.adversaryId && currentEncounter) {
          spotlightedAdversary = parsed.adversaryId;
          updateSpotlightUI();
        }
      }

      // Load adversary database from markdown
      loadAdversaryDatabase();

      // Initialize autocomplete
      initAdversarySearch();

      // Initialize battle map token list
      renderTokenList();

      // Initialize PeerJS host for remote connections
      initPeerHost();
    }

    // Handle image file selection
    function handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Check file size (limit to 5MB for localStorage)
      if (file.size > 5 * 1024 * 1024) {
        alert('Image too large. Please select an image under 5MB.');
        return;
      }

      const reader = new FileReader();
      reader.onload = function(e) {
        currentNpcImage = e.target.result;
        updateNpcPreview();
        syncNpcToStorage();
      };
      reader.readAsDataURL(file);
    }

    // Update the preview display
    function updateNpcPreview() {
      const preview = document.getElementById('npcPreview');
      const placeholder = document.getElementById('npcPlaceholder');
      const clearBtn = document.getElementById('clearImageBtn');
      const toggle = document.getElementById('npcVisibilityToggle');
      const toggleStatus = document.getElementById('toggleStatus');

      if (currentNpcImage) {
        preview.src = currentNpcImage;
        preview.classList.add('visible');
        placeholder.classList.add('hidden');
        clearBtn.disabled = false;
        toggle.disabled = false;
        toggle.checked = npcVisible;
        toggleStatus.textContent = npcVisible ? 'Visible' : 'Hidden';
        toggleStatus.classList.toggle('visible', npcVisible);
      } else {
        preview.src = '';
        preview.classList.remove('visible');
        placeholder.classList.remove('hidden');
        clearBtn.disabled = true;
        toggle.disabled = true;
        toggle.checked = false;
        toggleStatus.textContent = 'Hidden';
        toggleStatus.classList.remove('visible');
      }
    }

    // Toggle NPC visibility to players
    function toggleNpcVisibility() {
      npcVisible = document.getElementById('npcVisibilityToggle').checked;
      const toggleStatus = document.getElementById('toggleStatus');
      toggleStatus.textContent = npcVisible ? 'Visible' : 'Hidden';
      toggleStatus.classList.toggle('visible', npcVisible);
      syncNpcToStorage();
    }

    // Clear the NPC image
    function clearNpcImage() {
      currentNpcImage = null;
      npcVisible = false;
      document.getElementById('npcImageInput').value = '';
      updateNpcPreview();
      syncNpcToStorage();
    }

    // Sync NPC data to localStorage and PeerJS
    function syncNpcToStorage() {
      const npcData = {
        image: currentNpcImage,
        visible: npcVisible,
        timestamp: Date.now()
      };
      localStorage.setItem('daggerheart-npc', JSON.stringify(npcData));
      sendToPlayer({ type: 'npc', ...npcData });
    }

    // ============ ADVERSARY DATABASE & SEARCH ============

    // Embedded adversary database (parsed from DH-SRD-May202025.md)
    const EMBEDDED_ADVERSARIES = [
      {"name":"Acid Burrower","tier":1,"role":"Solo","difficulty":14,"hp":8,"stress":3,"attack":"+3 | Claws: Very Close | 1d12+2 phy","motives":"Burrow, drag away, feed, reposition"},
      {"name":"Adult Flickerfly","tier":3,"role":"Solo","difficulty":17,"hp":12,"stress":6,"attack":"+3 | Wing Slash: Very Close | 3d20 phy","motives":"Collect shiny things, hunt, nest, swoop"},
      {"name":"Apprentice Assassin","tier":2,"role":"Minion","difficulty":13,"hp":1,"stress":1,"attack":"-1 | Thrown Dagger: Very Close | 4 phy","motives":"Act reckless, kill, prove their worth"},
      {"name":"Arch-Necromancer","tier":4,"role":"Leader","difficulty":21,"hp":9,"stress":8,"attack":"+6 | Necrotic Blast: Far | 4d12+8 mag","motives":"Corrupt, decay, flee to fight another day"},
      {"name":"Archer Guard","tier":1,"role":"Ranged","difficulty":10,"hp":3,"stress":2,"attack":"+1 | Longbow: Far | 1d8+3 phy","motives":"Arrest, close gates, make it through the day"},
      {"name":"Archer Squadron","tier":2,"role":"Horde","difficulty":13,"hp":4,"stress":3,"attack":"+0 | Longbow: Far | 2d6+3 phy","motives":"Stick together, survive, volley fire"},
      {"name":"Assassin Poisoner","tier":2,"role":"Skulk","difficulty":14,"hp":4,"stress":4,"attack":"+3 | Poisoned Dagger: Close | 2d8+1 phy","motives":"Anticipate, get paid, kill, taint food"},
      {"name":"Battle Box","tier":2,"role":"Solo","difficulty":15,"hp":8,"stress":6,"attack":"+2 | Slam: Melee | 2d6+3 phy","motives":"Change tactics, trample foes, wait in disguise"},
      {"name":"Bear","tier":1,"role":"Bruiser","difficulty":14,"hp":7,"stress":2,"attack":"+1 | Claws: Melee | 1d8+3 phy","motives":"Climb, defend territory, pummel, track"},
      {"name":"Bladed Guard","tier":1,"role":"Standard","difficulty":12,"hp":5,"stress":2,"attack":"+1 | Longsword: Melee | 1d6+1 phy","motives":"Arrest, close gates, make it through the day"},
      {"name":"Brawny Zombie","tier":1,"role":"Bruiser","difficulty":10,"hp":7,"stress":4,"attack":"+2 | Slam: Very Close | 1d12+3 phy","motives":"Crush, destroy, hail debris, slam"},
      {"name":"Cave Ogre","tier":1,"role":"Solo","difficulty":13,"hp":8,"stress":3,"attack":"+1 | Club: Very Close | 1d10+2 phy","motives":"Bite off heads, feast, rip limbs, stomp"},
      {"name":"Chaos Skull","tier":2,"role":"Ranged","difficulty":15,"hp":5,"stress":4,"attack":"+2 | Energy Blast: Close | 2d8+3 mag","motives":"Cackle, consume magic, serve creator"},
      {"name":"Conscript","tier":2,"role":"Minion","difficulty":12,"hp":1,"stress":1,"attack":"+0 | Spears: Very Close | 6 phy","motives":"Follow orders, gang up, survive"},
      {"name":"Construct","tier":1,"role":"Solo","difficulty":13,"hp":9,"stress":4,"attack":"+4 | Fist Slam: Melee | 1d20 phy","motives":"Destroy environment, serve creator, smash"},
      {"name":"Courtesan","tier":2,"role":"Social","difficulty":13,"hp":3,"stress":4,"attack":"-3 | Dagger: Melee | 1d4+3 phy","motives":"Entice, maneuver, secure patrons"},
      {"name":"Courtier","tier":1,"role":"Social","difficulty":12,"hp":3,"stress":4,"attack":"-4 | Daggers: Melee | 1d4+2 phy","motives":"Discredit, gain favor, maneuver, scheme"},
      {"name":"Cult Adept","tier":2,"role":"Support","difficulty":14,"hp":4,"stress":6,"attack":"+2 | Rune-Covered Rod: Far | 2d4+3 mag","motives":"Curry favor, hinder foes, uncover knowledge"},
      {"name":"Cult Fang","tier":2,"role":"Skulk","difficulty":14,"hp":5,"stress":3,"attack":"+2 | Long Knife: Melee | 2d8+4 phy","motives":"Capture sacrifices, isolate prey"},
      {"name":"Cult Initiate","tier":2,"role":"Minion","difficulty":13,"hp":1,"stress":1,"attack":"+0 | Ritual Dagger: Melee | 5 phy","motives":"Follow orders, gain power, seek forbidden knowledge"},
      {"name":"Deeproot Defender","tier":1,"role":"Bruiser","difficulty":10,"hp":7,"stress":3,"attack":"+2 | Vines: Close | 1d8+3 phy","motives":"Ambush, grab, protect, pummel"},
      {"name":"Demon Of Avarice","tier":3,"role":"Support","difficulty":17,"hp":6,"stress":5,"attack":"+2 | Hungry Maw: Melee | 3d6+5 mag","motives":"Consume, fuel greed, sow dissent"},
      {"name":"Demon Of Despair","tier":3,"role":"Skulk","difficulty":17,"hp":6,"stress":5,"attack":"+3 | Miasma Bolt: Far | 3d6+1 mag","motives":"Make fear contagious, stick to shadows"},
      {"name":"Demon Of Hubris","tier":3,"role":"Leader","difficulty":18,"hp":7,"stress":5,"attack":"+4 | Perfect Spear: Very Close | 3d10 phy","motives":"Condescend, declare premature victory"},
      {"name":"Demon Of Jealousy","tier":3,"role":"Ranged","difficulty":17,"hp":6,"stress":6,"attack":"+4 | Psychic Assault: Far | 3d8+3 mag","motives":"Join in on others' success, hold grudges"},
      {"name":"Demon Of Wrath","tier":3,"role":"Bruiser","difficulty":17,"hp":7,"stress":5,"attack":"+3 | Fists: Very Close | 3d8+1 mag","motives":"Fuel anger, impress rivals, wreak havoc"},
      {"name":"Demonic Hound Pack","tier":2,"role":"Horde","difficulty":15,"hp":6,"stress":3,"attack":"+0 | Claws and Fangs: Melee | 2d8+2 phy","motives":"Cause fear, consume flesh, please masters"},
      {"name":"Dire Bat","tier":3,"role":"Skulk","difficulty":14,"hp":5,"stress":3,"attack":"+2 | Claws and Teeth: Melee | 2d6+7 phy","motives":"Dive-bomb, hide, protect leader"},
      {"name":"Dire Wolf","tier":1,"role":"Skulk","difficulty":12,"hp":4,"stress":3,"attack":"+2 | Claws: Melee | 1d6+2 phy","motives":"Defend territory, harry, protect pack"},
      {"name":"Dryad","tier":3,"role":"Leader","difficulty":16,"hp":8,"stress":5,"attack":"+4 | Deadfall Shortbow: Far | 3d10+1 phy","motives":"Command, cultivate, drive out, preserve forest"},
      {"name":"Electric Eels","tier":2,"role":"Horde","difficulty":15,"hp":4,"stress":4,"attack":"+0 | Shocking Bite: Melee | 2d6+4 phy","motives":"Avoid larger predators, shock prey"},
      {"name":"Elemental Spark","tier":3,"role":"Minion","difficulty":15,"hp":1,"stress":1,"attack":"+0 | Bursts of Fire: Close | 5 mag","motives":"Blast, consume, gain mass"},
      {"name":"Elite Soldier","tier":2,"role":"Standard","difficulty":15,"hp":4,"stress":3,"attack":"+1 | Spear: Very Close | 2d8+4 phy","motives":"Gain glory, keep order, make alliances"},
      {"name":"Failed Experiment","tier":2,"role":"Standard","difficulty":13,"hp":3,"stress":3,"attack":"+1 | Bite and Claw: Melee | 2d6+5 phy","motives":"Devour, hunt, track"},
      {"name":"Giant Beastmaster","tier":2,"role":"Leader","difficulty":16,"hp":6,"stress":5,"attack":"+2 | Longbow: Far | 2d8+4 phy","motives":"Command, maneuver, protect companions"},
      {"name":"Giant Brawler","tier":2,"role":"Bruiser","difficulty":15,"hp":7,"stress":4,"attack":"+2 | Warhammer: Very Close | 2d12+3 phy","motives":"Make a living, overwhelm, slam, topple"},
      {"name":"Giant Eagle","tier":2,"role":"Skulk","difficulty":14,"hp":4,"stress":4,"attack":"+1 | Claws and Beak: Very Close | 2d6+3 phy","motives":"Hunt prey, stay mobile, strike decisively"},
      {"name":"Giant Mosquitoes","tier":1,"role":"Horde","difficulty":10,"hp":6,"stress":3,"attack":"-2 | Proboscis: Melee | 1d8+3 phy","motives":"Fly away, harass, steal blood"},
      {"name":"Giant Rat","tier":1,"role":"Minion","difficulty":10,"hp":1,"stress":1,"attack":"-4 | Claws: Melee | 1 phy","motives":"Burrow, hunger, scavenge, wear down"},
      {"name":"Giant Recruit","tier":2,"role":"Minion","difficulty":13,"hp":1,"stress":2,"attack":"+1 | Warhammer: Very Close | 5 phy","motives":"Batter, make a living, overwhelm, terrify"},
      {"name":"Giant Scorpion","tier":1,"role":"Bruiser","difficulty":13,"hp":6,"stress":3,"attack":"+1 | Pincers: Melee | 1d12+2 phy","motives":"Ambush, feed, grapple, poison"},
      {"name":"Glass Snake","tier":1,"role":"Standard","difficulty":14,"hp":5,"stress":3,"attack":"+2 | Glass Fangs: Very Close | 1d8+2 phy","motives":"Climb, feed, keep distance, scare"},
      {"name":"Gorgon","tier":2,"role":"Solo","difficulty":15,"hp":9,"stress":3,"attack":"+4 | Sunsear Shortbow: Far | 2d20+3 mag","motives":"Corner, hit-and-run, petrify, seek vengeance"},
      {"name":"Greater Earth Elemental","tier":3,"role":"Bruiser","difficulty":17,"hp":10,"stress":4,"attack":"+7 | Boulder Fist: Very Close | 3d10+1 phy","motives":"Avalanche, knock over, pummel"},
      {"name":"Greater Water Elemental","tier":3,"role":"Support","difficulty":17,"hp":5,"stress":5,"attack":"+3 | Crashing Wave: Very Close | 3d4+1 mag","motives":"Deluge, disperse, drown"},
      {"name":"Green Ooze","tier":1,"role":"Skulk","difficulty":8,"hp":5,"stress":2,"attack":"+1 | Ooze Appendage: Melee | 1d6+1 mag","motives":"Camouflage, consume and multiply, creep up"},
      {"name":"Harrier","tier":1,"role":"Standard","difficulty":12,"hp":3,"stress":3,"attack":"+1 | Javelin: Close | 1d6+2 phy","motives":"Flank, harry, kite, profit"},
      {"name":"Head Guard","tier":1,"role":"Leader","difficulty":15,"hp":7,"stress":3,"attack":"+4 | Mace: Melee | 1d10+4 phy","motives":"Arrest, close gates, pin down, seek glory"},
      {"name":"Head Vampire","tier":3,"role":"Leader","difficulty":17,"hp":6,"stress":6,"attack":"+5 | Rapier: Melee | 2d20+4 phy","motives":"Create thralls, charm, command, fly"},
      {"name":"Huge Green Ooze","tier":3,"role":"Skulk","difficulty":15,"hp":7,"stress":4,"attack":"+3 | Ooze Appendage: Melee | 3d8+1 mag","motives":"Camouflage, creep up, envelop, multiply"},
      {"name":"Hydra","tier":3,"role":"Solo","difficulty":18,"hp":10,"stress":5,"attack":"+3 | Bite: Close | 2d12+2 phy","motives":"Devour, regenerate, terrify"},
      {"name":"Jagged Knife Bandit","tier":1,"role":"Standard","difficulty":12,"hp":5,"stress":3,"attack":"+1 | Daggers: Melee | 1d8+1 phy","motives":"Escape, profit, steal, throw smoke"},
      {"name":"Jagged Knife Hexer","tier":1,"role":"Support","difficulty":13,"hp":4,"stress":4,"attack":"+2 | Staff: Far | 1d6+2 mag","motives":"Command, hex, profit"},
      {"name":"Jagged Knife Kneebreaker","tier":1,"role":"Bruiser","difficulty":12,"hp":7,"stress":4,"attack":"-3 | Club: Melee | 1d4+6 phy","motives":"Grapple, intimidate, profit, steal"},
      {"name":"Jagged Knife Lackey","tier":1,"role":"Minion","difficulty":9,"hp":1,"stress":1,"attack":"-2 | Daggers: Melee | 2 phy","motives":"Escape, profit, throw smoke"},
      {"name":"Jagged Knife Lieutenant","tier":1,"role":"Leader","difficulty":13,"hp":6,"stress":3,"attack":"+2 | Javelin: Close | 1d8+3 phy","motives":"Bully, command, profit, reinforce"},
      {"name":"Jagged Knife Shadow","tier":1,"role":"Skulk","difficulty":12,"hp":3,"stress":3,"attack":"+1 | Daggers: Melee | 1d4+4 phy","motives":"Ambush, conceal, divide, profit"},
      {"name":"Jagged Knife Sniper","tier":1,"role":"Ranged","difficulty":13,"hp":3,"stress":2,"attack":"-1 | Shortbow: Far | 1d10+2 phy","motives":"Ambush, hide, profit, reposition"},
      {"name":"Juvenile Flickerfly","tier":2,"role":"Solo","difficulty":14,"hp":10,"stress":5,"attack":"+3 | Wing Slash: Very Close | 2d10+4 phy","motives":"Collect shiny things, hunt, swoop"},
      {"name":"Knight Of The Realm","tier":2,"role":"Leader","difficulty":15,"hp":6,"stress":4,"attack":"+4 | Longsword: Melee | 2d10+4 phy","motives":"Run down, seek glory, show dominance"},
      {"name":"Masked Thief","tier":2,"role":"Skulk","difficulty":14,"hp":4,"stress":5,"attack":"+3 | Backsword: Melee | 2d8+3 phy","motives":"Evade, hide, pilfer, profit"},
      {"name":"Master Assassin","tier":2,"role":"Leader","difficulty":15,"hp":7,"stress":5,"attack":"+5 | Serrated Dagger: Close | 2d10+2 phy","motives":"Ambush, get out alive, kill"},
      {"name":"Merchant","tier":1,"role":"Social","difficulty":12,"hp":3,"stress":3,"attack":"-4 | Club: Melee | 1d4+1 phy","motives":"Buy low, sell high, create demand"},
      {"name":"Merchant Baron","tier":2,"role":"Social","difficulty":15,"hp":5,"stress":3,"attack":"-2 | Rapier: Melee | 1d6+2 phy","motives":"Abuse power, gather resources"},
      {"name":"Minor Chaos Elemental","tier":1,"role":"Solo","difficulty":14,"hp":7,"stress":3,"attack":"+3 | Warp Blast: Close | 1d12+6 mag","motives":"Confound, destabilize, transmogrify"},
      {"name":"Minor Demon","tier":1,"role":"Solo","difficulty":14,"hp":8,"stress":4,"attack":"+3 | Claws: Melee | 1d8+6 phy","motives":"Act erratically, corral targets, relish pain"},
      {"name":"Minor Fire Elemental","tier":1,"role":"Solo","difficulty":13,"hp":9,"stress":3,"attack":"+3 | Elemental Blast: Far | 1d10+4 mag","motives":"Encircle enemies, grow in size, intimidate"},
      {"name":"Minor Treant","tier":1,"role":"Minion","difficulty":10,"hp":1,"stress":1,"attack":"-2 | Clawed Branch: Melee | 4 phy","motives":"Crush, overwhelm, protect"},
      {"name":"Minotaur Wrecker","tier":2,"role":"Bruiser","difficulty":16,"hp":7,"stress":5,"attack":"+2 | Battleaxe: Very Close | 2d8+5 phy","motives":"Consume, gore, navigate, overpower"},
      {"name":"Monarch","tier":3,"role":"Social","difficulty":16,"hp":6,"stress":5,"attack":"+0 | Warhammer: Melee | 3d6+3 phy","motives":"Control vassals, destroy rivals"},
      {"name":"Mortal Hunter","tier":2,"role":"Leader","difficulty":16,"hp":6,"stress":4,"attack":"+5 | Tear at Flesh: Very Close | 2d12+1 phy","motives":"Devour, hunt, track"},
      {"name":"Oak Treant","tier":3,"role":"Bruiser","difficulty":17,"hp":7,"stress":4,"attack":"+2 | Branch: Very Close | 3d8+2 phy","motives":"Hide in plain sight, preserve forest"},
      {"name":"Patchwork Zombie Hulk","tier":1,"role":"Solo","difficulty":13,"hp":10,"stress":3,"attack":"+4 | Too Many Arms: Very Close | 1d20 phy","motives":"Absorb corpses, flail, hunger, terrify"},
      {"name":"Petty Noble","tier":1,"role":"Social","difficulty":14,"hp":3,"stress":5,"attack":"-3 | Rapier: Melee | 1d6+1 phy","motives":"Abuse power, gather resources"},
      {"name":"Pirate Captain","tier":1,"role":"Leader","difficulty":14,"hp":7,"stress":5,"attack":"+4 | Cutlass: Melee | 1d12+2 phy","motives":"Command, plunder, raid"},
      {"name":"Pirate Raiders","tier":1,"role":"Horde","difficulty":12,"hp":4,"stress":3,"attack":"+1 | Cutlass: Melee | 1d8+2 phy","motives":"Gang up, plunder, raid"},
      {"name":"Pirate Tough","tier":1,"role":"Bruiser","difficulty":13,"hp":5,"stress":3,"attack":"+1 | Massive Fists: Melee | 2d6 phy","motives":"Plunder, raid, smash, terrorize"},
      {"name":"Red Ooze","tier":1,"role":"Skulk","difficulty":10,"hp":5,"stress":3,"attack":"+1 | Ooze Appendage: Melee | 1d8+3 mag","motives":"Camouflage, consume and multiply, ignite"},
      {"name":"Rotted Zombie","tier":1,"role":"Minion","difficulty":8,"hp":1,"stress":1,"attack":"-3 | Bite: Melee | 2 phy","motives":"Eat flesh, hunger, maul, surround"},
      {"name":"Royal Advisor","tier":2,"role":"Social","difficulty":14,"hp":3,"stress":3,"attack":"-3 | Wand: Far | 1d4+3 phy","motives":"Curry favor, manufacture evidence, scheme"},
      {"name":"Secret-Keeper","tier":2,"role":"Leader","difficulty":16,"hp":7,"stress":4,"attack":"+3 | Sigil-laden Staff: Far | 2d12 mag","motives":"Amass great power, plot, take command"},
      {"name":"Sellsword","tier":1,"role":"Minion","difficulty":10,"hp":1,"stress":1,"attack":"+3 | Longsword: Melee | 3 phy","motives":"Charge, lacerate, overwhelm, profit"},
      {"name":"Shambling Zombie","tier":1,"role":"Standard","difficulty":10,"hp":4,"stress":1,"attack":"+0 | Bite: Melee | 1d6+1 phy","motives":"Devour, hungry, mob enemy, shred flesh"},
      {"name":"Shark","tier":2,"role":"Bruiser","difficulty":14,"hp":7,"stress":3,"attack":"+2 | Toothy Maw: Very Close | 2d12+1 phy","motives":"Find the blood, isolate prey, target weak"},
      {"name":"Siren","tier":2,"role":"Skulk","difficulty":14,"hp":5,"stress":3,"attack":"+2 | Distended Jaw Bite: Melee | 2d6+3 phy","motives":"Consume, lure prey, subdue with song"},
      {"name":"Skeleton Archer","tier":1,"role":"Ranged","difficulty":9,"hp":3,"stress":2,"attack":"+2 | Shortbow: Far | 1d8+1 phy","motives":"Perforate distracted targets, play dead"},
      {"name":"Skeleton Dredge","tier":1,"role":"Minion","difficulty":8,"hp":1,"stress":1,"attack":"-1 | Bone Claws: Melee | 1 phy","motives":"Fall apart, overwhelm, play dead"},
      {"name":"Skeleton Knight","tier":1,"role":"Bruiser","difficulty":13,"hp":5,"stress":2,"attack":"+2 | Rusty Greatsword: Melee | 1d10+2 phy","motives":"Cut down the living, steal skin, wreak havoc"},
      {"name":"Skeleton Warrior","tier":1,"role":"Standard","difficulty":10,"hp":3,"stress":2,"attack":"+0 | Sword: Melee | 1d6+2 phy","motives":"Feign death, gang up, steal skin"},
      {"name":"Spectral Archer","tier":2,"role":"Ranged","difficulty":13,"hp":3,"stress":3,"attack":"+3 | Longbow: Far | 2d10+2 phy","motives":"Move through solid objects, stay out of fray"},
      {"name":"Spectral Captain","tier":2,"role":"Leader","difficulty":16,"hp":6,"stress":4,"attack":"+3 | Longbow: Far | 2d10+3 phy","motives":"Move through solid objects, rally troops"},
      {"name":"Spectral Guardian","tier":2,"role":"Standard","difficulty":15,"hp":4,"stress":3,"attack":"+1 | Spear: Very Close | 2d8+1 phy","motives":"Move through solid objects, protect treasure"},
      {"name":"Spellblade","tier":1,"role":"Leader","difficulty":14,"hp":6,"stress":3,"attack":"+3 | Empowered Longsword: Melee | 1d8+4 phy/mag","motives":"Blast, command, endure"},
      {"name":"Spy","tier":2,"role":"Social","difficulty":15,"hp":4,"stress":3,"attack":"-2 | Dagger: Melee | 2d6+3 phy","motives":"Cut and run, disguise appearance, eavesdrop"},
      {"name":"Stag Knight","tier":3,"role":"Leader","difficulty":17,"hp":7,"stress":5,"attack":"+4 | Antler Charge: Very Close | 3d10+2 phy","motives":"Command, defend the wild, trample"},
      {"name":"Stonewraith","tier":3,"role":"Skulk","difficulty":13,"hp":6,"stress":3,"attack":"+3 | Bite and Claws: Melee | 2d8+6 phy","motives":"Defend territory, isolate prey, stalk"},
      {"name":"Swarm Of Rats","tier":1,"role":"Horde","difficulty":10,"hp":6,"stress":2,"attack":"-3 | Claws: Melee | 1d8+2 phy","motives":"Consume, obscure, swarm"},
      {"name":"Sylvan Soldier","tier":1,"role":"Standard","difficulty":11,"hp":4,"stress":2,"attack":"+0 | Scythe: Melee | 1d8+1 phy","motives":"Ambush, hide, overwhelm, protect, trail"},
      {"name":"Tangle Bramble","tier":1,"role":"Minion","difficulty":11,"hp":1,"stress":1,"attack":"-1 | Thorns: Melee | 2 phy","motives":"Combine, drain, entangle"},
      {"name":"Tangle Bramble Swarm","tier":1,"role":"Horde","difficulty":12,"hp":6,"stress":3,"attack":"+0 | Thorns: Melee | 1d6+3 phy","motives":"Digest, entangle, immobilize"},
      {"name":"Tiny Green Ooze","tier":1,"role":"Skulk","difficulty":14,"hp":2,"stress":1,"attack":"-1 | Ooze Appendage: Melee | 1d4+1 mag","motives":"Camouflage, creep up"},
      {"name":"Tiny Red Ooze","tier":1,"role":"Skulk","difficulty":11,"hp":2,"stress":1,"attack":"-1 | Ooze Appendage: Melee | 1d4+2 mag","motives":"Blaze, camouflage"},
      {"name":"Treant Sapling","tier":3,"role":"Minion","difficulty":14,"hp":1,"stress":1,"attack":"+0 | Branches: Melee | 8 phy","motives":"Blend in, preserve forest, pummel, surround"},
      {"name":"Vampire","tier":3,"role":"Standard","difficulty":16,"hp":5,"stress":4,"attack":"+3 | Rapier: Melee | 3d8 phy","motives":"Bite, charm, deceive, feed, intimidate"},
      {"name":"Vault Guardian Gaoler","tier":3,"role":"Support","difficulty":16,"hp":5,"stress":3,"attack":"+2 | Body Bash: Very Close | 3d6+2 phy","motives":"Carry away, entrap, protect, pummel"},
      {"name":"Vault Guardian Sentinel","tier":3,"role":"Bruiser","difficulty":17,"hp":6,"stress":3,"attack":"+3 | Charged Mace: Very Close | 2d12+1 phy","motives":"Destroy at any cost, expunge, protect"},
      {"name":"Vault Guardian Turret","tier":3,"role":"Ranged","difficulty":16,"hp":5,"stress":4,"attack":"+3 | Magitech Cannon: Far | 3d10+3 mag","motives":"Concentrate fire, lock down, mark, protect"},
      {"name":"War Wizard","tier":3,"role":"Ranged","difficulty":16,"hp":5,"stress":6,"attack":"+4 | Staff: Far | 2d10+4 mag","motives":"Develop new spells, seek power"},
      {"name":"Weaponmaster","tier":1,"role":"Standard","difficulty":12,"hp":5,"stress":3,"attack":"+2 | Varied Weapons: Melee | 1d10+2 phy","motives":"Display skill, duel, seek worthy opponents"},
      {"name":"Young Dryad","tier":1,"role":"Leader","difficulty":11,"hp":6,"stress":2,"attack":"+0 | Scythe: Melee | 1d8+5 phy","motives":"Command, nurture, prune the unwelcome"},
      {"name":"Young Ice Dragon","tier":4,"role":"Solo","difficulty":18,"hp":10,"stress":6,"attack":"+7 | Bite and Claws: Close | 4d10 phy","motives":"Avalanche, defend lair, fly, freeze, maul"},
      {"name":"Zombie Pack","tier":1,"role":"Horde","difficulty":8,"hp":6,"stress":3,"attack":"-1 | Bite: Melee | 1d10+2 phy","motives":"Consume flesh, hunger, maul"}
    ];

    // Load adversary database (uses embedded data for local file support)
    function loadAdversaryDatabase() {
      adversaryDatabase = EMBEDDED_ADVERSARIES.map(adv => ({
        ...adv,
        abilities: adv.abilities || []
      }));
      console.log(`Loaded ${adversaryDatabase.length} adversaries from embedded database`);
    }

    // Initialize adversary search autocomplete
    function initAdversarySearch() {
      const input = document.getElementById('adversarySearchInput');
      const dropdown = document.getElementById('autocompleteDropdown');

      if (!input || !dropdown) return;

      // Input event for searching
      input.addEventListener('input', (e) => {
        const query = e.target.value.trim();
        if (query.length < 1) {
          hideAutocomplete();
          return;
        }
        const results = searchAdversaries(query);
        showAutocomplete(results);
      });

      // Keyboard navigation
      input.addEventListener('keydown', (e) => {
        const items = dropdown.querySelectorAll('.autocomplete-item');
        if (!items.length) return;

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, items.length - 1);
          updateAutocompleteSelection(items);
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, 0);
          updateAutocompleteSelection(items);
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selectedAutocompleteIndex >= 0 && items[selectedAutocompleteIndex]) {
            const advName = items[selectedAutocompleteIndex].dataset.adversaryName;
            addAdversaryToEncounter(advName);
            input.value = '';
            hideAutocomplete();
          }
        } else if (e.key === 'Escape') {
          hideAutocomplete();
          input.blur();
        }
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.adversary-search-container')) {
          hideAutocomplete();
        }
      });

      // Focus behavior
      input.addEventListener('focus', () => {
        const query = input.value.trim();
        if (query.length >= 1) {
          const results = searchAdversaries(query);
          showAutocomplete(results);
        }
      });
    }

    // Search adversaries by query
    function searchAdversaries(query) {
      if (!adversaryDatabase.length) return [];

      const lowerQuery = query.toLowerCase();
      return adversaryDatabase
        .filter(adv => {
          const nameMatch = adv.name.toLowerCase().includes(lowerQuery);
          const roleMatch = adv.role && adv.role.toLowerCase().includes(lowerQuery);
          return nameMatch || roleMatch;
        })
        .slice(0, 15); // Limit to 15 results
    }

    // Show autocomplete dropdown
    function showAutocomplete(results) {
      const dropdown = document.getElementById('autocompleteDropdown');
      selectedAutocompleteIndex = -1;

      if (!results.length) {
        if (adversaryDatabase.length === 0) {
          dropdown.innerHTML = '<div class="loading-indicator">Loading adversary database...</div>';
        } else {
          dropdown.innerHTML = '<div class="autocomplete-no-results">No adversaries found</div>';
        }
        dropdown.classList.add('visible');
        return;
      }

      dropdown.innerHTML = results.map((adv, idx) => `
        <div class="autocomplete-item" data-adversary-name="${adv.name}" onclick="selectAutocompleteItem('${adv.name.replace(/'/g, "\\'")}')">
          <div>
            <span class="autocomplete-item-name">${highlightMatch(adv.name, document.getElementById('adversarySearchInput').value)}</span>
            <span class="autocomplete-item-tier">Tier ${adv.tier}</span>
            <span class="autocomplete-item-role">${adv.role}</span>
          </div>
          <div class="autocomplete-item-stats">
            HP: ${adv.hp} | Stress: ${adv.stress} | Difficulty: ${adv.difficulty}
          </div>
        </div>
      `).join('');

      dropdown.classList.add('visible');
    }

    // Hide autocomplete dropdown
    function hideAutocomplete() {
      const dropdown = document.getElementById('autocompleteDropdown');
      dropdown.classList.remove('visible');
      selectedAutocompleteIndex = -1;
    }

    // Update selection highlighting
    function updateAutocompleteSelection(items) {
      items.forEach((item, idx) => {
        item.classList.toggle('selected', idx === selectedAutocompleteIndex);
      });
      // Scroll into view
      if (selectedAutocompleteIndex >= 0 && items[selectedAutocompleteIndex]) {
        items[selectedAutocompleteIndex].scrollIntoView({ block: 'nearest' });
      }
    }

    // Highlight matching text
    function highlightMatch(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      return text.replace(regex, '<strong style="color: #4CAF50;">$1</strong>');
    }

    // Select item from autocomplete
    function selectAutocompleteItem(name) {
      addAdversaryToEncounter(name);
      document.getElementById('adversarySearchInput').value = '';
      hideAutocomplete();
    }

    // Add adversary from database to current encounter
    function addAdversaryToEncounter(adversaryName) {
      const adversary = adversaryDatabase.find(a => a.name === adversaryName);
      if (!adversary) {
        console.error('Adversary not found:', adversaryName);
        return;
      }

      // Create encounter if none exists
      if (!currentEncounter) {
        currentEncounter = {
          name: 'Quick Encounter',
          adversaries: []
        };
      }

      // Create a unique ID for this adversary instance
      const existingCount = currentEncounter.adversaries.filter(a =>
        a.name.startsWith(adversary.name)
      ).length;
      const instanceNum = existingCount + 1;

      // Build the adversary object for the encounter
      const newAdversary = {
        id: `adv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        name: instanceNum > 1 ? `${adversary.name} #${instanceNum}` : adversary.name,
        tier: adversary.tier,
        hp: adversary.hp,
        currentHp: adversary.hp,
        stress: adversary.stress,
        currentStress: adversary.stress,
        defense: adversary.difficulty,
        attack: adversary.attack,
        traits: adversary.role ? [adversary.role] : [],
        abilities: adversary.abilities || [],
        portraits: [],
        activePortraitIndex: 0,
        conditions: {}
      };

      // Add motives as a trait if exists
      if (adversary.motives) {
        newAdversary.traits.push(`Motives: ${adversary.motives}`);
      }

      currentEncounter.adversaries.push(newAdversary);
      renderEncounter();
      syncEncounterToStorage();

      // Flash feedback
      const card = document.querySelector(`[data-adversary-id="${newAdversary.id}"]`);
      if (card) {
        card.style.animation = 'none';
        card.offsetHeight; // Trigger reflow
        card.style.animation = 'flashGreen 0.5s ease-out';
      }
    }

    // ============ ENCOUNTER FUNCTIONS ============

    // Handle encounter JSON file upload
    function handleEncounterUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const encounter = JSON.parse(e.target.result);

          // Validate encounter structure
          if (!encounter.name || !Array.isArray(encounter.adversaries)) {
            alert('Invalid encounter file. Must have "name" and "adversaries" array.');
            return;
          }

          // Add unique IDs to adversaries if not present
          encounter.adversaries = encounter.adversaries.map((adv, idx) => ({
            ...adv,
            id: adv.id || `adv-${Date.now()}-${idx}`,
            portraits: adv.portraits || [],
            activePortraitIndex: 0,
            conditions: adv.conditions || {}
          }));

          currentEncounter = encounter;
          spotlightedAdversary = null;
          renderEncounter();
          syncEncounterToStorage();
          syncSpotlightToStorage();
        } catch (err) {
          alert('Error parsing encounter file: ' + err.message);
        }
      };
      reader.readAsText(file);
      event.target.value = ''; // Reset input
    }

    // Handle encounter folder upload (folder with JSON + images)
    function handleEncounterFolderUpload(event) {
      const files = Array.from(event.target.files);
      if (!files.length) return;

      // Find the JSON file
      const jsonFile = files.find(f => f.name.endsWith('.json'));
      if (!jsonFile) {
        alert('No JSON file found in folder. Please include an encounter.json file.');
        return;
      }

      // Find all image files
      const imageFiles = files.filter(f =>
        f.type.startsWith('image/') ||
        /\.(png|jpg|jpeg|gif|webp|svg)$/i.test(f.name)
      );

      // Read the JSON file first
      const jsonReader = new FileReader();
      jsonReader.onload = function(e) {
        try {
          const encounter = JSON.parse(e.target.result);

          // Validate encounter structure
          if (!encounter.name || !Array.isArray(encounter.adversaries)) {
            alert('Invalid encounter file. Must have "name" and "adversaries" array.');
            return;
          }

          // Process adversaries and match images
          const imageLoadPromises = [];
          const imageMap = new Map(); // filename -> base64 data

          // Load all images first
          imageFiles.forEach(imgFile => {
            const promise = new Promise((resolve) => {
              const reader = new FileReader();
              reader.onload = function(imgE) {
                // Store with just the filename (not the path)
                const filename = imgFile.name;
                imageMap.set(filename.toLowerCase(), imgE.target.result);
                resolve();
              };
              reader.onerror = () => resolve(); // Continue even if image fails
              reader.readAsDataURL(imgFile);
            });
            imageLoadPromises.push(promise);
          });

          // After all images are loaded, process the encounter
          Promise.all(imageLoadPromises).then(() => {
            // Add unique IDs and match images to adversaries
            encounter.adversaries = encounter.adversaries.map((adv, idx) => {
              const processedAdv = {
                ...adv,
                id: adv.id || `adv-${Date.now()}-${idx}`,
                portraits: [],
                activePortraitIndex: 0,
                conditions: adv.conditions || {}
              };

              // Check for image reference in JSON (supports: portrait, image, portraits array)
              // Can be: filename (matched to uploaded files), URL (http/https), or data URL
              const imageRefs = [];

              if (adv.portrait) {
                imageRefs.push(adv.portrait);
              }
              if (adv.image) {
                imageRefs.push(adv.image);
              }
              if (Array.isArray(adv.portraits)) {
                imageRefs.push(...adv.portraits.filter(p => typeof p === 'string'));
              }

              // Process image references - URLs pass through, filenames are matched
              imageRefs.forEach(ref => {
                if (typeof ref !== 'string') return;

                // Check if it's an external URL (http/https)
                if (ref.startsWith('http://') || ref.startsWith('https://')) {
                  processedAdv.portraits.push(ref);
                }
                // Check if it's already a data URL
                else if (ref.startsWith('data:')) {
                  processedAdv.portraits.push(ref);
                }
                // Otherwise treat as filename and try to match
                else {
                  const filename = ref.toLowerCase();
                  if (imageMap.has(filename)) {
                    processedAdv.portraits.push(imageMap.get(filename));
                  }
                }
              });

              return processedAdv;
            });

            currentEncounter = encounter;
            spotlightedAdversary = null;
            renderEncounter();
            syncEncounterToStorage();
            syncSpotlightToStorage();

            // Show feedback
            const loadedImages = encounter.adversaries.reduce((sum, adv) => sum + adv.portraits.length, 0);
            if (loadedImages > 0) {
              console.log(`Loaded encounter "${encounter.name}" with ${loadedImages} image(s)`);
            } else if (imageFiles.length > 0) {
              alert(`Loaded encounter but couldn't match images. Make sure your JSON uses "portrait" or "image" fields matching the image filenames.`);
            }
          });

        } catch (err) {
          alert('Error parsing encounter file: ' + err.message);
        }
      };
      jsonReader.readAsText(jsonFile);
      event.target.value = ''; // Reset input
    }

    // Load sample encounter for testing
    function loadSampleEncounter() {
      const sampleEncounter = {
        name: "Skeleton Ambush",
        adversaries: [
          {
            id: "skeleton-1",
            name: "Skeleton Warrior",
            tier: 1,
            hp: 6,
            stress: 3,
            attack: "+2 (2d6+2 physical)",
            defense: 10,
            traits: ["Undead", "Fearless"],
            abilities: [
              "Bone Strike: Melee attack dealing 2d6+2 physical damage",
              "Reassemble: Once per encounter, regain 1d6 HP when reduced to 0"
            ],
            portraits: [],
            activePortraitIndex: 0
          },
          {
            id: "skeleton-2",
            name: "Skeleton Archer",
            tier: 1,
            hp: 4,
            stress: 2,
            attack: "+3 (2d6+1 physical, ranged)",
            defense: 8,
            traits: ["Undead", "Fearless"],
            abilities: [
              "Arrow Volley: Ranged attack dealing 2d6+1 physical damage",
              "Bone Shield: Reaction - reduce incoming damage by 2"
            ],
            portraits: [],
            activePortraitIndex: 0
          },
          {
            id: "ooze-1",
            name: "Crimson Ooze",
            tier: 2,
            hp: 12,
            stress: 4,
            attack: "+1 (2d8 acid)",
            defense: 6,
            traits: ["Ooze", "Acidic", "Slow"],
            abilities: [
              "Engulf: Melee attack dealing 2d8 acid damage. On hit, target is grappled",
              "Split: When reduced to half HP, split into two smaller oozes with 4 HP each",
              "Acid Trail: Leaves acidic residue that deals 1d4 damage to creatures that step in it"
            ],
            portraits: [],
            activePortraitIndex: 0
          }
        ]
      };

      currentEncounter = sampleEncounter;
      spotlightedAdversary = null;
      renderEncounter();
      syncEncounterToStorage();
      syncSpotlightToStorage();
    }

    // Render the encounter UI
    function renderEncounter() {
      const container = document.getElementById('encounterContainer');
      const clearBtn = document.getElementById('clearEncounterBtn');

      if (!currentEncounter) {
        container.innerHTML = `
          <div class="encounter-empty">
            No encounter loaded.<br>
            <small style="color: #888; display: block; margin-top: 8px;">
              Create a folder with encounter.json + images.<br>
              Use "portrait": "filename.png" or a CDN URL in your JSON.<br>
              Click adversary portraits to add images.
            </small>
          </div>
        `;
        clearBtn.disabled = true;
        return;
      }

      clearBtn.disabled = false;

      let html = `<div class="encounter-name">${currentEncounter.name}</div>`;
      html += '<div class="adversary-list">';

      currentEncounter.adversaries.forEach((adv, index) => {
        const isSpotlighted = spotlightedAdversary === adv.id;
        const hasPortrait = adv.portraits && adv.portraits.length > 0;
        const activePortrait = hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : null;

        // Initialize current HP/Stress if not set
        if (adv.hp !== undefined && adv.currentHp === undefined) {
          adv.currentHp = adv.hp;
        }
        if (adv.stress !== undefined && adv.currentStress === undefined) {
          adv.currentStress = adv.stress;
        }

        const isDefeated = adv.hp !== undefined && adv.currentHp <= 0;
        const hpCritical = adv.hp !== undefined && adv.currentHp > 0 && adv.currentHp <= Math.ceil(adv.hp / 4);

        html += `
          <div class="adversary-card ${isSpotlighted ? 'spotlighted' : ''} ${isDefeated ? 'defeated' : ''}" data-adversary-id="${adv.id}">
            <div class="adversary-header">
              <div class="adversary-portrait-thumb ${!hasPortrait ? 'has-default' : ''}" onclick="triggerImageUpload('${adv.id}')" title="${hasPortrait ? 'Click to change portrait' : 'Click to add portrait (showing default)'}">
                <img src="${activePortrait || getDefaultImageForAdversary(adv)}" alt="${adv.name}">
                ${!hasPortrait ? '<span class="default-indicator" title="Default image - click to upload custom">?</span>' : ''}
              </div>
              <div class="adversary-info">
                <div class="adversary-name">
                  ${adv.name}
                  ${isDefeated ? '<span class="defeated-badge">DEFEATED</span>' : ''}
                  ${adv.conditions?.hidden ? '<span class="condition-badge hidden-badge">Hidden</span>' : ''}
                  ${adv.conditions?.restrained ? '<span class="condition-badge restrained-badge">Restrained</span>' : ''}
                  ${adv.conditions?.vulnerable ? '<span class="condition-badge vulnerable-badge">Vulnerable</span>' : ''}
                </div>
                <div class="adversary-tier">Tier ${adv.tier || 1}</div>
                ${hasPortrait && adv.portraits.length > 1 ? `
                  <div class="adversary-portrait-gallery">
                    ${adv.portraits.map((p, pIdx) => `
                      <div class="gallery-thumb ${pIdx === (adv.activePortraitIndex || 0) ? 'active' : ''}"
                           onclick="selectPortrait('${adv.id}', ${pIdx})">
                        <img src="${p}" alt="Portrait ${pIdx + 1}">
                      </div>
                    `).join('')}
                    <button class="add-image-btn" onclick="triggerImageUpload('${adv.id}')" title="Add another portrait">+</button>
                  </div>
                ` : ''}
              </div>
              <div class="adversary-actions">
                <button class="spotlight-btn ${isSpotlighted ? 'active' : ''}"
                        onclick="toggleSpotlight('${adv.id}')"
                        title="${!hasPortrait ? 'Show with default image' : 'Show to players'}">
                  ${isSpotlighted ? '‚òÖ Lit' : '‚òÜ Show'}
                </button>
                <button class="stat-toggle-btn" onclick="toggleStats('${adv.id}')">Stats</button>
              </div>
            </div>
            ${(adv.hp !== undefined || adv.stress !== undefined) ? `
              <div class="adversary-trackers">
                ${adv.hp !== undefined ? `
                  <div class="tracker tracker-hp">
                    <span class="tracker-label">HP</span>
                    <div class="tracker-controls">
                      <button class="tracker-btn minus" onclick="adjustHp('${adv.id}', -1)">-</button>
                      <span class="tracker-value ${adv.currentHp <= 0 ? 'depleted' : ''} ${hpCritical ? 'critical' : ''}">${adv.currentHp} / ${adv.hp}</span>
                      <button class="tracker-btn plus" onclick="adjustHp('${adv.id}', 1)">+</button>
                    </div>
                  </div>
                ` : ''}
                ${adv.stress !== undefined ? `
                  <div class="tracker tracker-stress">
                    <span class="tracker-label">Stress</span>
                    <div class="tracker-controls">
                      <button class="tracker-btn minus" onclick="adjustStress('${adv.id}', -1)">-</button>
                      <span class="tracker-value ${adv.currentStress <= 0 ? 'depleted' : ''}">${adv.currentStress} / ${adv.stress}</span>
                      <button class="tracker-btn plus" onclick="adjustStress('${adv.id}', 1)">+</button>
                    </div>
                  </div>
                ` : ''}
              </div>
            ` : ''}
            <div class="condition-toggles">
              <button class="condition-toggle hidden-toggle ${adv.conditions?.hidden ? 'active' : ''}"
                      onclick="toggleCondition('${adv.id}', 'hidden')"
                      title="Rolls against Hidden have disadvantage">
                üëÅ Hidden
              </button>
              <button class="condition-toggle restrained-toggle ${adv.conditions?.restrained ? 'active' : ''}"
                      onclick="toggleCondition('${adv.id}', 'restrained')"
                      title="Restrained creatures can't move">
                ‚õì Restrained
              </button>
              <button class="condition-toggle vulnerable-toggle ${adv.conditions?.vulnerable ? 'active' : ''}"
                      onclick="toggleCondition('${adv.id}', 'vulnerable')"
                      title="Rolls against Vulnerable have advantage">
                ‚ö† Vulnerable
              </button>
            </div>
            <div class="adversary-stats" id="stats-${adv.id}">
              <div class="stat-grid">
                ${adv.defense !== undefined ? `<div class="stat-item"><div class="stat-label">Defense</div><div class="stat-value">${adv.defense}</div></div>` : ''}
                ${adv.attack ? `<div class="stat-item"><div class="stat-label">Attack</div><div class="stat-value" style="font-size: 0.75rem;">${adv.attack}</div></div>` : ''}
              </div>
              ${adv.traits && adv.traits.length > 0 ? `
                <div class="traits-section">
                  <div class="section-label">Traits</div>
                  ${adv.traits.map(t => `<span class="trait-tag">${t}</span>`).join('')}
                </div>
              ` : ''}
              ${adv.abilities && adv.abilities.length > 0 ? `
                <div class="abilities-section">
                  <div class="section-label">Abilities</div>
                  ${adv.abilities.map(a => `<div class="ability-item">${a}</div>`).join('')}
                </div>
              ` : ''}
            </div>
          </div>
        `;
      });

      html += '</div>';
      container.innerHTML = html;
      updateSpotlightUI();

      // Sync adversary tokens to battle map
      syncAdversaryTokens();
    }

    // Toggle stat block visibility
    function toggleStats(adversaryId) {
      const statsEl = document.getElementById(`stats-${adversaryId}`);
      const btn = document.querySelector(`[data-adversary-id="${adversaryId}"] .stat-toggle-btn`);

      if (statsEl) {
        statsEl.classList.toggle('visible');
        btn.classList.toggle('expanded');
      }
    }

    // Adjust HP for an adversary
    function adjustHp(adversaryId, amount) {
      const adversary = currentEncounter.adversaries.find(a => a.id === adversaryId);
      if (!adversary || adversary.hp === undefined) return;

      // Initialize current HP if needed
      if (adversary.currentHp === undefined) {
        adversary.currentHp = adversary.hp;
      }

      // Adjust HP (can go negative but not above max)
      adversary.currentHp = Math.min(adversary.hp, adversary.currentHp + amount);

      renderEncounter();
      syncEncounterToStorage();

      // Update spotlight if this adversary is spotlighted (defeated status may have changed)
      if (spotlightedAdversary === adversaryId) {
        syncSpotlightToStorage();
      }
    }

    // Adjust Stress for an adversary
    function adjustStress(adversaryId, amount) {
      const adversary = currentEncounter.adversaries.find(a => a.id === adversaryId);
      if (!adversary || adversary.stress === undefined) return;

      // Initialize current Stress if needed
      if (adversary.currentStress === undefined) {
        adversary.currentStress = adversary.stress;
      }

      // Adjust Stress (can go negative but not above max)
      adversary.currentStress = Math.min(adversary.stress, adversary.currentStress + amount);

      renderEncounter();
      syncEncounterToStorage();
    }

    // Toggle a condition on an adversary
    function toggleCondition(adversaryId, conditionName) {
      const adversary = currentEncounter.adversaries.find(a => a.id === adversaryId);
      if (!adversary) return;

      // Initialize conditions object if needed
      if (!adversary.conditions) {
        adversary.conditions = {};
      }

      // Toggle the condition
      adversary.conditions[conditionName] = !adversary.conditions[conditionName];

      renderEncounter();
      syncEncounterToStorage();

      // Update spotlight if this adversary is spotlighted
      if (spotlightedAdversary === adversaryId) {
        syncSpotlightToStorage();
      }
    }

    // Trigger image upload for specific adversary - shows dialog with file/URL options
    function triggerImageUpload(adversaryId) {
      pendingImageUploadAdversaryId = adversaryId;
      // Show the image source dialog
      document.getElementById('imageSourceDialog').classList.add('visible');
      // Reset the dialog state
      document.getElementById('urlInputSection').classList.remove('visible');
      document.getElementById('imageUrlInput').value = '';
      document.getElementById('urlPreview').innerHTML = '';
      document.getElementById('urlAddBtn').disabled = true;
    }

    // Close the image source dialog
    function closeImageDialog(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('imageSourceDialog').classList.remove('visible');
      pendingImageUploadAdversaryId = null;
    }

    // User chose to upload a file
    function chooseFileUpload() {
      document.getElementById('imageSourceDialog').classList.remove('visible');
      document.getElementById('adversaryImageInput').click();
    }

    // Show the URL input section
    function showUrlInput() {
      document.getElementById('urlInputSection').classList.add('visible');
      document.getElementById('imageUrlInput').focus();
    }

    // Handle Enter key in URL input
    function handleUrlKeyup(event) {
      if (event.key === 'Enter' && !document.getElementById('urlAddBtn').disabled) {
        addUrlPortrait();
      }
    }

    // Preview the URL image
    function previewUrlImage() {
      const url = document.getElementById('imageUrlInput').value.trim();
      const preview = document.getElementById('urlPreview');
      const addBtn = document.getElementById('urlAddBtn');

      if (!url) {
        preview.innerHTML = '';
        addBtn.disabled = true;
        return;
      }

      // Basic URL validation
      try {
        const parsed = new URL(url);
        if (!['http:', 'https:'].includes(parsed.protocol)) {
          preview.innerHTML = '<div class="url-preview-error">URL must start with http:// or https://</div>';
          addBtn.disabled = true;
          return;
        }
      } catch (e) {
        preview.innerHTML = '<div class="url-preview-error">Invalid URL format</div>';
        addBtn.disabled = true;
        return;
      }

      // Try to load the image
      preview.innerHTML = '<div style="color: #888; font-size: 0.8rem;">Loading preview...</div>';
      const img = new Image();
      img.onload = function() {
        preview.innerHTML = '';
        preview.appendChild(img);
        addBtn.disabled = false;
      };
      img.onerror = function() {
        preview.innerHTML = '<div class="url-preview-error">Could not load image. Check the URL or try a different one.</div>';
        addBtn.disabled = true;
      };
      img.src = url;
    }

    // Add URL as portrait
    function addUrlPortrait() {
      const url = document.getElementById('imageUrlInput').value.trim();
      if (!url || !pendingImageUploadAdversaryId) return;

      const adversary = currentEncounter.adversaries.find(a => a.id === pendingImageUploadAdversaryId);
      if (!adversary) return;

      // Add URL directly to portraits (no compression needed for external URLs)
      if (!adversary.portraits) {
        adversary.portraits = [];
      }
      adversary.portraits.push(url);
      adversary.activePortraitIndex = adversary.portraits.length - 1;

      // Update UI
      renderEncounter();
      syncEncounterToStorage();

      // If this adversary is spotlighted, update the spotlight
      if (spotlightedAdversary === adversary.id) {
        syncSpotlightToStorage();
      }

      // Close dialog
      closeImageDialog();
    }

    // Compress/resize image if too large for localStorage
    // Target: max 800KB base64 (leaves room for other data in localStorage)
    const MAX_IMAGE_SIZE = 800 * 1024; // 800KB target for base64 output
    const MAX_DIMENSION = 1024; // Max width/height in pixels

    function compressImage(dataUrl, callback) {
      const img = new Image();
      img.onload = function() {
        let { width, height } = img;

        // Check if we need to resize based on dimensions
        if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
          const ratio = Math.min(MAX_DIMENSION / width, MAX_DIMENSION / height);
          width = Math.round(width * ratio);
          height = Math.round(height * ratio);
        }

        // Check if original is small enough (estimate base64 size)
        const estimatedSize = dataUrl.length;
        if (estimatedSize < MAX_IMAGE_SIZE && img.width <= MAX_DIMENSION && img.height <= MAX_DIMENSION) {
          callback(dataUrl); // No compression needed
          return;
        }

        // Create canvas and draw resized image
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);

        // Try JPEG first (better compression for photos)
        let quality = 0.85;
        let compressed = canvas.toDataURL('image/jpeg', quality);

        // If still too large, reduce quality further
        while (compressed.length > MAX_IMAGE_SIZE && quality > 0.3) {
          quality -= 0.1;
          compressed = canvas.toDataURL('image/jpeg', quality);
        }

        // If JPEG at low quality is still too big, reduce dimensions more
        if (compressed.length > MAX_IMAGE_SIZE) {
          const scaleFactor = Math.sqrt(MAX_IMAGE_SIZE / compressed.length);
          width = Math.round(width * scaleFactor);
          height = Math.round(height * scaleFactor);
          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);
          compressed = canvas.toDataURL('image/jpeg', 0.7);
        }

        console.log(`Image compressed: ${(dataUrl.length / 1024).toFixed(0)}KB -> ${(compressed.length / 1024).toFixed(0)}KB`);
        callback(compressed);
      };
      img.onerror = function() {
        console.error('Failed to load image for compression');
        callback(dataUrl); // Return original on error
      };
      img.src = dataUrl;
    }

    // Handle adversary portrait image upload
    function handleAdversaryImageUpload(event) {
      const files = event.target.files;
      if (!files.length || !pendingImageUploadAdversaryId) return;

      const adversary = currentEncounter.adversaries.find(a => a.id === pendingImageUploadAdversaryId);
      if (!adversary) return;

      // Filter valid files first (under 10MB raw - will be compressed)
      const validFiles = Array.from(files).filter(file => {
        if (file.size > 10 * 1024 * 1024) {
          alert(`Image "${file.name}" is too large. Please select images under 10MB.`);
          return false;
        }
        return true;
      });

      if (validFiles.length === 0) {
        event.target.value = '';
        pendingImageUploadAdversaryId = null;
        return;
      }

      // Process each valid file
      validFiles.forEach(file => {
        const reader = new FileReader();
        reader.onload = function(e) {
          // Compress/resize the image before storing
          compressImage(e.target.result, function(compressedDataUrl) {
            if (!adversary.portraits) {
              adversary.portraits = [];
            }
            adversary.portraits.push(compressedDataUrl);
            adversary.activePortraitIndex = adversary.portraits.length - 1;

            // Update UI after each file loads for immediate feedback
            renderEncounter();
            syncEncounterToStorage();

            // If this adversary is spotlighted, update the spotlight
            if (spotlightedAdversary === adversary.id) {
              syncSpotlightToStorage();
            }
          });
        };
        reader.onerror = function() {
          console.error(`Failed to read file: ${file.name}`);
        };
        reader.readAsDataURL(file);
      });

      event.target.value = ''; // Reset input
      pendingImageUploadAdversaryId = null;
    }

    // Select a specific portrait from the gallery
    function selectPortrait(adversaryId, portraitIndex) {
      const adversary = currentEncounter.adversaries.find(a => a.id === adversaryId);
      if (!adversary) return;

      adversary.activePortraitIndex = portraitIndex;
      renderEncounter();
      syncEncounterToStorage();

      // If this adversary is spotlighted, update the spotlight
      if (spotlightedAdversary === adversaryId) {
        syncSpotlightToStorage();
      }
    }

    // Toggle spotlight for an adversary
    function toggleSpotlight(adversaryId) {
      const adversary = currentEncounter.adversaries.find(a => a.id === adversaryId);
      if (!adversary) return;

      if (spotlightedAdversary === adversaryId) {
        // Turn off spotlight
        spotlightedAdversary = null;
      } else {
        // Spotlight this adversary
        spotlightedAdversary = adversaryId;
      }

      renderEncounter();
      syncSpotlightToStorage();
    }

    // Hide spotlight (turn off current spotlight)
    function hideSpotlight() {
      spotlightedAdversary = null;
      renderEncounter();
      syncSpotlightToStorage();
    }

    // Update spotlight UI elements
    function updateSpotlightUI() {
      const hideBtn = document.getElementById('hideSpotlightBtn');
      hideBtn.disabled = !spotlightedAdversary;
    }

    // Clear current encounter
    function clearEncounter() {
      currentEncounter = null;
      spotlightedAdversary = null;
      renderEncounter();
      syncEncounterToStorage();
      syncSpotlightToStorage();
      document.getElementById('encounterFileInput').value = '';
    }

    // Sync encounter data to localStorage
    function syncEncounterToStorage() {
      if (currentEncounter) {
        const encounterData = {
          encounter: currentEncounter,
          timestamp: Date.now()
        };
        localStorage.setItem('daggerheart-encounter', JSON.stringify(encounterData));
      } else {
        localStorage.removeItem('daggerheart-encounter');
      }
    }

    // Sync spotlight data to localStorage and PeerJS (this is what player display reads)
    function syncSpotlightToStorage() {
      if (spotlightedAdversary && currentEncounter) {
        const adversary = currentEncounter.adversaries.find(a => a.id === spotlightedAdversary);
        if (adversary) {
          const isDefeated = adversary.hp !== undefined && adversary.currentHp <= 0;
          // Use custom portrait if available, otherwise use default image
          const hasCustomPortrait = adversary.portraits && adversary.portraits.length > 0;
          const imageToShow = hasCustomPortrait
            ? adversary.portraits[adversary.activePortraitIndex || 0]
            : getDefaultImageForAdversary(adversary);

          const spotlightData = {
            visible: true,
            adversaryId: adversary.id,
            name: adversary.name,
            image: imageToShow,
            isDefaultImage: !hasCustomPortrait,
            defeated: isDefeated,
            conditions: adversary.conditions || {},
            timestamp: Date.now()
          };

          try {
            localStorage.setItem('daggerheart-spotlight', JSON.stringify(spotlightData));
            document.getElementById('hideSpotlightBtn').disabled = false;
          } catch (e) {
            console.error('Failed to sync spotlight to localStorage:', e);
            if (e.name === 'QuotaExceededError' || e.code === 22) {
              alert('Image is too large to display on player screen. Please use a smaller image (under 1MB recommended) or compress the current image.');
            }
          }

          // Send via PeerJS (works even for large images since it's P2P)
          sendToPlayer({ type: 'spotlight', ...spotlightData });
          return;
        }
      }

      // No spotlight
      const spotlightData = {
        visible: false,
        timestamp: Date.now()
      };
      try {
        localStorage.setItem('daggerheart-spotlight', JSON.stringify(spotlightData));
      } catch (e) {
        console.error('Failed to clear spotlight in localStorage:', e);
      }
      sendToPlayer({ type: 'spotlight', ...spotlightData });
      document.getElementById('hideSpotlightBtn').disabled = true;
    }

    // ============ END ENCOUNTER FUNCTIONS ============

    function updateFearDisplay() {
      const display = document.getElementById('fearDisplay');
      display.textContent = currentFear;
      display.style.color = currentFear > 8 ? '#ff4444' : currentFear > 4 ? '#b388ff' : '#ffd700';
    }
    
    function adjustFear(amount) {
      currentFear = Math.max(0, Math.min(12, currentFear + amount));
      updateFearDisplay();

      // Send to player display (localStorage for same-browser, PeerJS for remote)
      localStorage.setItem('daggerheart-fear', currentFear);
      localStorage.setItem('daggerheart-update', Date.now()); // Trigger update
      sendToPlayer({ type: 'fear', value: currentFear });
    }

    function resetFear() {
      currentFear = 0;
      updateFearDisplay();
      localStorage.setItem('daggerheart-fear', 0);
      localStorage.setItem('daggerheart-update', Date.now());
      sendToPlayer({ type: 'fear', value: 0 });
    }
    
    function setNotation(notation) {
      document.getElementById('diceNotation').value = notation;
    }

    function parseAndRollNotation(notation) {
      // Parse notation like "1d20+2d6+5" or "2d8-1"
      const cleanNotation = notation.replace(/\s/g, '').toLowerCase();

      // Split by + and - while keeping the operators
      const parts = cleanNotation.split(/(?=[+-])/);

      const diceRolls = []; // Array of {sides, count, results}
      let modifier = 0;
      let total = 0;
      const breakdown = [];

      for (const part of parts) {
        const trimmed = part.replace(/^\+/, ''); // Remove leading +

        // Check if it's a dice roll (contains 'd')
        const diceMatch = trimmed.match(/^(-?)(\d*)d(\d+)$/);

        if (diceMatch) {
          const negative = diceMatch[1] === '-';
          const count = parseInt(diceMatch[2]) || 1;
          const sides = parseInt(diceMatch[3]);
          const results = [];

          for (let i = 0; i < count; i++) {
            results.push(Math.floor(Math.random() * sides) + 1);
          }

          const subtotal = results.reduce((a, b) => a + b, 0) * (negative ? -1 : 1);
          total += subtotal;

          diceRolls.push({ sides, count, results, negative });

          if (count === 1) {
            breakdown.push((negative ? '-' : (breakdown.length > 0 ? '+' : '')) + results[0]);
          } else {
            breakdown.push((negative ? '-(' : (breakdown.length > 0 ? '+(' : '(')) + results.join('+') + ')');
          }
        } else {
          // It's a flat modifier
          const num = parseInt(trimmed);
          if (!isNaN(num)) {
            modifier += num;
            total += num;
            if (num >= 0 && breakdown.length > 0) {
              breakdown.push('+' + num);
            } else {
              breakdown.push(num.toString());
            }
          }
        }
      }

      return { diceRolls, modifier, total, breakdown, notation: cleanNotation };
    }

    function rollNotation() {
      const notation = document.getElementById('diceNotation').value.trim();
      if (!notation) return;

      const result = parseAndRollNotation(notation);

      // Display result
      const breakdownStr = result.breakdown.join('');
      document.getElementById('lastRoll').textContent = `${notation}: ${breakdownStr} = ${result.total}`;

      // Send to player display (localStorage for same-browser, PeerJS for remote)
      const diceData = {
        type: 'notation',
        notation: result.notation,
        diceRolls: result.diceRolls,
        modifier: result.modifier,
        total: result.total,
        breakdown: result.breakdown,
        timestamp: Date.now()
      };
      localStorage.setItem('daggerheart-dice', JSON.stringify(diceData));
      sendToPlayer({ type: 'dice', ...diceData });
    }

    // Allow Enter key to roll
    document.addEventListener('DOMContentLoaded', function() {
      document.getElementById('diceNotation').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          rollNotation();
        }
      });
    });

    function rollHopeFear() {
      const hope = Math.floor(Math.random() * 12) + 1;
      const fear = Math.floor(Math.random() * 12) + 1;
      const sum = hope + fear;
      const winner = hope >= fear ? 'Hope' : 'Fear';

      document.getElementById('lastRoll').textContent = `${sum} with ${winner} (${hope} + ${fear})`;

      // Send to player display (localStorage for same-browser, PeerJS for remote)
      const diceData = {
        type: 'hopefear',
        hope: hope,
        fear: fear,
        sum: sum,
        winner: winner,
        timestamp: Date.now()
      };
      localStorage.setItem('daggerheart-dice', JSON.stringify(diceData));
      sendToPlayer({ type: 'dice', ...diceData });
    }
    
    function openPlayerDisplay() {
      const playerWindow = window.open('player-display.html', 'PlayerDisplay',
        'width=1920,height=1080,menubar=no,toolbar=no,location=no,status=no');

      if (playerWindow) {
        document.getElementById('status').textContent = '‚úì Player display opened! Drag it to your player-facing monitor.';
      } else {
        document.getElementById('status').textContent = '‚ö†Ô∏è Pop-up blocked. Please allow pop-ups or open player-display.html manually.';
        document.getElementById('status').style.color = '#ff6b6b';
      }
    }

    // ========== Battle Map Functions ==========

    function openBattleMap() {
      const battleMapWindow = window.open('battle-map.html', 'BattleMap',
        'width=1920,height=1080,menubar=no,toolbar=no,location=no,status=no');

      if (battleMapWindow) {
        document.getElementById('battleMapStatus').textContent = '‚úì Battle map opened! Drag it to your TV display.';
      } else {
        document.getElementById('battleMapStatus').textContent = '‚ö†Ô∏è Pop-up blocked. Please allow pop-ups or open battle-map.html manually.';
        document.getElementById('battleMapStatus').style.color = '#ff6b6b';
      }
    }

    function handleMapUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        currentMap = {
          mapImage: e.target.result,
          gridSize: 50 // Default grid size in pixels
        };

        // Show preview
        document.getElementById('mapPreview').src = e.target.result;
        document.getElementById('mapPreviewContainer').style.display = 'block';
        document.getElementById('mapPlaceholder').style.display = 'none';

        // If toggle is on, send to battle map
        if (document.getElementById('mapVisibilityToggle').checked) {
          syncMapToBattleMap();
        }
      };
      reader.readAsDataURL(file);
    }

    function toggleMapVisibility() {
      mapVisible = document.getElementById('mapVisibilityToggle').checked;
      syncMapToBattleMap();
    }

    function toggleGrid() {
      gridVisible = document.getElementById('gridToggle').checked;
      syncGridToBattleMap();
    }

    function syncMapToBattleMap() {
      const data = {
        type: 'map',
        visible: mapVisible,
        mapImage: mapVisible && currentMap ? currentMap.mapImage : null,
        gridSize: currentMap ? currentMap.gridSize : 50,
        timestamp: Date.now()
      };

      // Send via PeerJS
      sendToBattleMap(data);

      // Also save to localStorage as fallback
      localStorage.setItem('daggerheart-battle-map', JSON.stringify(data));
    }

    function syncGridToBattleMap() {
      const data = {
        type: 'grid',
        visible: gridVisible,
        timestamp: Date.now()
      };

      sendToBattleMap(data);
      localStorage.setItem('daggerheart-battle-grid', JSON.stringify(data));
    }

    function syncTokensToBattleMap() {
      // Only send visible tokens to the battle map
      const visibleTokens = battleMapTokens.filter(t => t.visible !== false);

      const data = {
        type: 'tokens',
        tokens: visibleTokens,
        timestamp: Date.now()
      };

      sendToBattleMap(data);
      localStorage.setItem('daggerheart-battle-tokens', JSON.stringify(data));
    }

    function sendToBattleMap(data) {
      // Send to all connected battle map displays
      if (peer && peer.connections) {
        for (const peerId in peer.connections) {
          const connections = peer.connections[peerId];
          if (connections && connections.length > 0) {
            connections.forEach(conn => {
              if (conn.open && conn.metadata && conn.metadata.type === 'battleMap') {
                try {
                  conn.send(data);
                } catch (err) {
                  console.error('Error sending to battle map:', err);
                }
              }
            });
          }
        }
      }

      // Also broadcast to all connections (battle map will filter)
      if (playerConnection && playerConnection.open) {
        try {
          playerConnection.send(data);
        } catch (err) {
          console.error('Error broadcasting battle map data:', err);
        }
      }
    }

    function addPlayerToken() {
      const playerName = prompt('Enter player name:');
      if (!playerName) return;

      const token = {
        id: `player-${nextPlayerTokenId++}`,
        name: playerName,
        type: 'player',
        x: 5,
        y: 5,
        image: null,
        conditions: {},
        visible: true
      };

      battleMapTokens.push(token);
      renderTokenList();
      syncTokensToBattleMap();
    }

    function addAdversaryToken(adversary) {
      // Check if token already exists for this adversary
      const existingToken = battleMapTokens.find(t => t.id === adversary.id);
      if (existingToken) {
        return; // Token already exists
      }

      // Get the active portrait
      let image = null;
      if (adversary.portraits && adversary.portraits.length > 0) {
        const activeIndex = adversary.activePortraitIndex || 0;
        image = adversary.portraits[activeIndex];
      }

      const token = {
        id: adversary.id,
        name: adversary.name,
        type: 'adversary',
        x: 10,
        y: 10,
        image: image,
        conditions: adversary.conditions || {},
        visible: false // Adversaries start hidden, GM can show them
      };

      battleMapTokens.push(token);
      renderTokenList();
      syncTokensToBattleMap();
    }

    function removeToken(tokenId) {
      battleMapTokens = battleMapTokens.filter(t => t.id !== tokenId);
      renderTokenList();
      syncTokensToBattleMap();
    }

    function updateTokenPosition(tokenId, x, y) {
      const token = battleMapTokens.find(t => t.id === tokenId);
      if (token) {
        token.x = parseInt(x) || 0;
        token.y = parseInt(y) || 0;
        syncTokensToBattleMap();
      }
    }

    function renderTokenList() {
      const tokenList = document.getElementById('tokenList');
      if (battleMapTokens.length === 0) {
        tokenList.innerHTML = '<div style="padding: 20px; text-align: center; color: #666; font-size: 0.85rem;">No tokens added yet</div>';
        return;
      }

      tokenList.innerHTML = battleMapTokens.map(token => {
        const tokenTypeClass = token.type;
        const isVisible = token.visible !== false;
        const thumbStyle = token.image ? `background-image: url(${token.image})` : `background-color: ${token.type === 'player' ? '#4CAF50' : '#f44336'}`;
        const visibilityBtnClass = isVisible ? '' : 'hidden';
        const visibilityText = isVisible ? 'üëÅ Visible' : 'üëÅ Hidden';

        return `
          <div class="token-item ${tokenTypeClass} ${isVisible ? '' : 'hidden'}">
            <div class="token-thumb ${tokenTypeClass}" style="${thumbStyle}" ${token.type === 'player' && !token.image ? `onclick="uploadPlayerTokenImage('${token.id}')"` : ''} title="${token.type === 'player' && !token.image ? 'Click to add image' : ''}"></div>
            <div class="token-info">
              <div class="token-name">${token.name}</div>
              <div class="token-position">
                <span style="font-size: 0.75rem; color: #888;">X:</span>
                <input type="number" class="token-coord-input" value="${token.x}"
                       onchange="updateTokenPosition('${token.id}', this.value, document.getElementById('tokenY-${token.id}').value)"
                       min="0" step="1">
                <span style="font-size: 0.75rem; color: #888;">Y:</span>
                <input type="number" class="token-coord-input" id="tokenY-${token.id}" value="${token.y}"
                       onchange="updateTokenPosition('${token.id}', document.querySelector('[onchange*=\\'${token.id}\\'][onchange*=\\'tokenY\\']').previousElementSibling.previousElementSibling.value, this.value)"
                       min="0" step="1">
              </div>
            </div>
            <div class="token-actions">
              <button class="token-position-btn" onclick="openPositioningModal('${token.id}')" ${!currentMap ? 'disabled title="Upload a map first"' : ''}>üìç Position</button>
              ${token.type === 'player' ? `<button class="token-upload-btn" onclick="uploadPlayerTokenImage('${token.id}')">üñº Image</button>` : ''}
              <button class="token-visibility-btn ${visibilityBtnClass}" onclick="toggleTokenVisibility('${token.id}')">${visibilityText}</button>
              <button class="token-remove-btn" onclick="removeToken('${token.id}')">Remove</button>
            </div>
          </div>
        `;
      }).join('');
    }

    // Auto-add adversary tokens when encounter is loaded or spotlight changes
    function syncAdversaryTokens() {
      if (!currentEncounter || !currentEncounter.adversaries) return;

      currentEncounter.adversaries.forEach(adversary => {
        const existingToken = battleMapTokens.find(t => t.id === adversary.id);
        if (!existingToken) {
          addAdversaryToken(adversary);
        } else {
          // Update existing token's image and conditions
          let image = null;
          if (adversary.portraits && adversary.portraits.length > 0) {
            const activeIndex = adversary.activePortraitIndex || 0;
            image = adversary.portraits[activeIndex];
          }
          existingToken.image = image;
          existingToken.conditions = adversary.conditions || {};
        }
      });

      renderTokenList();
      syncTokensToBattleMap();
    }

    // Upload image for player token
    function uploadPlayerTokenImage(tokenId) {
      pendingPlayerTokenImageId = tokenId;
      document.getElementById('playerTokenImageInput').click();
    }

    function handlePlayerTokenImageUpload(event) {
      const file = event.target.files[0];
      if (!file || !pendingPlayerTokenImageId) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const token = battleMapTokens.find(t => t.id === pendingPlayerTokenImageId);
        if (token) {
          token.image = e.target.result;
          renderTokenList();
          syncTokensToBattleMap();
        }
        pendingPlayerTokenImageId = null;
      };
      reader.readAsDataURL(file);

      // Clear the input so the same file can be selected again
      event.target.value = '';
    }

    // Toggle token visibility
    function toggleTokenVisibility(tokenId) {
      const token = battleMapTokens.find(t => t.id === tokenId);
      if (token) {
        token.visible = token.visible === false ? true : false;
        renderTokenList();
        syncTokensToBattleMap();
      }
    }

    // Position token on map via click interface
    function openPositioningModal(tokenId) {
      if (!currentMap || !currentMap.mapImage) {
        alert('Please upload a map first!');
        return;
      }

      positioningTokenId = tokenId;
      const token = battleMapTokens.find(t => t.id === tokenId);
      if (!token) return;

      const modal = document.getElementById('positioningModal');
      const mapImg = document.getElementById('positioningMapImage');
      const title = document.getElementById('positioningTitle');
      const container = document.getElementById('positioningMapContainer');

      title.textContent = `Position: ${token.name}`;
      mapImg.src = currentMap.mapImage;

      // Wait for image to load, then set up click handler
      mapImg.onload = () => {
        // Remove previous click handler
        container.replaceWith(container.cloneNode(true));
        const newContainer = document.getElementById('positioningMapContainer');
        const newMapImg = document.getElementById('positioningMapImage');

        // Draw existing tokens
        drawPositioningTokens(newMapImg);

        // Add click handler
        newContainer.addEventListener('click', (e) => {
          const rect = newMapImg.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          // Calculate grid position
          const gridX = Math.floor(x / gridSize);
          const gridY = Math.floor(y / gridSize);

          // Update token position
          updateTokenPosition(positioningTokenId, gridX, gridY);

          // Redraw tokens with new position
          drawPositioningTokens(newMapImg);
        });
      };

      modal.classList.add('visible');
    }

    function closePositioningModal(event) {
      if (event && event.target !== event.currentTarget && !event.target.classList.contains('positioning-close')) {
        return;
      }

      const modal = document.getElementById('positioningModal');
      modal.classList.remove('visible');
      positioningTokenId = null;
    }

    function drawPositioningTokens(mapImg) {
      // Remove existing markers
      const container = document.getElementById('positioningMapContainer');
      const existingMarkers = container.querySelectorAll('.positioning-marker');
      existingMarkers.forEach(m => m.remove());

      // Get map image dimensions
      const rect = mapImg.getBoundingClientRect();
      const mapWidth = mapImg.naturalWidth;
      const mapHeight = mapImg.naturalHeight;
      const displayWidth = rect.width;
      const displayHeight = rect.height;

      // Calculate scale
      const scale = displayWidth / mapWidth;

      // Draw ALL tokens (both visible and hidden) so GM can position them before revealing
      battleMapTokens.forEach(token => {
        const marker = document.createElement('div');
        marker.className = `positioning-marker ${token.type}`;

        // Position marker
        const pixelX = (token.x * gridSize * scale);
        const pixelY = (token.y * gridSize * scale);

        marker.style.left = `${pixelX}px`;
        marker.style.top = `${pixelY}px`;

        // Set background image
        if (token.image) {
          marker.style.backgroundImage = `url(${token.image})`;
        } else {
          marker.style.backgroundColor = token.type === 'player' ? '#4CAF50' : '#f44336';
        }

        // Show hidden tokens with reduced opacity (for GM planning)
        if (token.visible === false) {
          marker.style.opacity = '0.4';
        }

        // Highlight the token being positioned
        if (token.id === positioningTokenId) {
          marker.style.boxShadow = '0 0 25px rgba(255, 215, 0, 1)';
          marker.style.borderColor = '#ffd700';
          marker.style.borderWidth = '4px';
          marker.style.opacity = '1'; // Full opacity for the one being positioned
        }

        container.appendChild(marker);
      });
    }

    init();
  </script>
</body>
</html>
