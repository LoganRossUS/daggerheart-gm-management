<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GM Control Panel - Daggerheart</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      min-height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Cinzel', serif;
      color: #e0e0e0;
      padding: 20px;
    }
    
    h1 {
      text-align: center;
      font-size: 1.8rem;
      background: linear-gradient(180deg, #ffd700, #b8860b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    
    .subtitle {
      text-align: center;
      color: #888;
      font-size: 0.9rem;
      margin-bottom: 30px;
    }
    
    .section {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .section h2 {
      font-size: 1.1rem;
      color: #b388ff;
      margin-bottom: 15px;
      border-bottom: 1px solid rgba(179, 136, 255, 0.3);
      padding-bottom: 8px;
    }
    
    /* Fear Controls */
    .fear-controls {
      display: flex;
      align-items: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    .fear-display {
      font-size: 2.5rem;
      font-weight: 900;
      min-width: 100px;
      text-align: center;
    }
    
    .fear-buttons {
      display: flex;
      gap: 10px;
    }
    
    .fear-btn {
      width: 50px;
      height: 50px;
      border: none;
      border-radius: 8px;
      font-size: 1.5rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .fear-btn.add {
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      color: white;
    }
    
    .fear-btn.remove {
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
    }
    
    .fear-btn:hover {
      transform: scale(1.1);
    }
    
    .fear-btn:active {
      transform: scale(0.95);
    }
    
    .fear-btn.reset {
      width: auto;
      padding: 0 20px;
      font-size: 0.9rem;
      background: #333;
      color: #aaa;
    }
    
    /* Dice Controls */
    .dice-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 10px;
    }
    
    .dice-btn {
      padding: 15px 10px;
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      background: rgba(255,255,255,0.05);
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .dice-btn:hover {
      background: rgba(179, 136, 255, 0.2);
      border-color: #b388ff;
      transform: translateY(-2px);
    }
    
    .dice-btn:active {
      transform: translateY(0);
    }
    
    .dice-btn.d20 {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(184, 134, 11, 0.2));
      border-color: #ffd700;
    }
    
    .dice-btn.hope-fear {
      grid-column: span 2;
      background: linear-gradient(90deg, rgba(255, 215, 0, 0.2), rgba(123, 45, 142, 0.2));
      border-color: #b388ff;
    }
    
    /* Last Roll Display */
    .last-roll {
      margin-top: 15px;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      text-align: center;
    }
    
    .last-roll-label {
      font-size: 0.8rem;
      color: #888;
    }
    
    .last-roll-result {
      font-size: 1.5rem;
      font-weight: 700;
      color: #ffd700;
    }
    
    /* Open Display Button */
    .open-display-btn {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      border: none;
      border-radius: 10px;
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .open-display-btn:hover {
      transform: scale(1.02);
      box-shadow: 0 5px 20px rgba(123, 45, 142, 0.4);
    }
    
    .status {
      margin-top: 10px;
      text-align: center;
      font-size: 0.8rem;
      color: #4CAF50;
    }
    
    /* Dice Notation Input */
    .dice-input-row {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .dice-notation-input {
      flex: 1;
      padding: 12px 15px;
      border-radius: 8px;
      border: 2px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      transition: border-color 0.2s;
    }

    .dice-notation-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .dice-notation-input::placeholder {
      color: #666;
    }

    .roll-btn {
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .roll-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
    }

    .roll-btn:active {
      transform: scale(0.98);
    }

    .quick-dice {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 15px;
    }

    .quick-dice-btn {
      padding: 8px 12px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      color: #aaa;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .quick-dice-btn:hover {
      background: rgba(179, 136, 255, 0.2);
      border-color: #b388ff;
      color: #e0e0e0;
    }

    /* NPC Portrait Controls */
    .npc-portrait-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .npc-upload-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .npc-upload-btn {
      padding: 12px 20px;
      border: 2px dashed rgba(179, 136, 255, 0.5);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
      text-align: center;
    }

    .npc-upload-btn:hover {
      background: rgba(179, 136, 255, 0.15);
      border-color: #b388ff;
    }

    .npc-clear-btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      background: rgba(255,68,68,0.2);
      color: #ff6b6b;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .npc-clear-btn:hover {
      background: rgba(255,68,68,0.3);
    }

    .npc-clear-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .npc-preview-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 120px;
      border-radius: 10px;
      background: rgba(0,0,0,0.3);
      overflow: hidden;
    }

    .npc-preview {
      max-width: 100%;
      max-height: 200px;
      border-radius: 8px;
      object-fit: contain;
      display: none;
    }

    .npc-preview.visible {
      display: block;
    }

    .npc-placeholder {
      color: #666;
      font-size: 0.9rem;
      text-align: center;
      padding: 20px;
    }

    .npc-placeholder.hidden {
      display: none;
    }

    /* Toggle Switch */
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 15px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
    }

    .toggle-label {
      font-size: 0.95rem;
      color: #e0e0e0;
    }

    .toggle-status {
      font-size: 0.8rem;
      color: #888;
      margin-left: 10px;
    }

    .toggle-status.visible {
      color: #4CAF50;
    }

    .toggle-switch {
      position: relative;
      width: 56px;
      height: 28px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: #333;
      border-radius: 28px;
      transition: all 0.3s;
    }

    .toggle-slider::before {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      left: 3px;
      bottom: 3px;
      background: #888;
      border-radius: 50%;
      transition: all 0.3s;
    }

    .toggle-switch input:checked + .toggle-slider {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
    }

    .toggle-switch input:checked + .toggle-slider::before {
      transform: translateX(28px);
      background: #ffd700;
    }

    .toggle-switch input:disabled + .toggle-slider {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Encounters Section */
    .encounter-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .encounter-upload-btn {
      padding: 12px 20px;
      border: 2px dashed rgba(255, 136, 0, 0.5);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      color: #ff9800;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
      text-align: center;
    }

    .encounter-upload-btn:hover {
      background: rgba(255, 136, 0, 0.15);
      border-color: #ff9800;
    }

    .encounter-clear-btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      background: rgba(255,68,68,0.2);
      color: #ff6b6b;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .encounter-clear-btn:hover {
      background: rgba(255,68,68,0.3);
    }

    .encounter-clear-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .encounter-name {
      font-size: 1.1rem;
      color: #ffd700;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      text-align: center;
    }

    .encounter-empty {
      text-align: center;
      color: #666;
      padding: 30px;
      font-size: 0.9rem;
    }

    .adversary-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .adversary-card {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.2s;
    }

    .adversary-card.spotlighted {
      border-color: #ffd700;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
    }

    .adversary-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .adversary-portrait-thumb {
      width: 60px;
      height: 60px;
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .adversary-portrait-thumb:hover {
      border-color: #b388ff;
    }

    .adversary-portrait-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .adversary-portrait-thumb .upload-icon {
      color: #666;
      font-size: 1.5rem;
    }

    .adversary-portrait-gallery {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      margin-top: 5px;
    }

    .gallery-thumb {
      width: 35px;
      height: 35px;
      border-radius: 4px;
      overflow: hidden;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }

    .gallery-thumb:hover {
      border-color: #b388ff;
    }

    .gallery-thumb.active {
      border-color: #ffd700;
    }

    .gallery-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .add-image-btn {
      width: 35px;
      height: 35px;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
      border: 1px dashed rgba(255,255,255,0.2);
      color: #666;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      transition: all 0.2s;
    }

    .add-image-btn:hover {
      background: rgba(179, 136, 255, 0.15);
      border-color: #b388ff;
      color: #b388ff;
    }

    .adversary-info {
      flex: 1;
    }

    .adversary-name {
      font-size: 1rem;
      font-weight: 700;
      color: #e0e0e0;
      margin-bottom: 4px;
    }

    .adversary-tier {
      font-size: 0.75rem;
      color: #888;
    }

    .adversary-actions {
      display: flex;
      gap: 8px;
    }

    .spotlight-btn {
      padding: 8px 14px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .spotlight-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 3px 10px rgba(255, 215, 0, 0.4);
    }

    .spotlight-btn.active {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      color: #fff;
    }

    .stat-toggle-btn {
      padding: 8px 12px;
      border: 1px solid rgba(179, 136, 255, 0.3);
      border-radius: 6px;
      background: transparent;
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .stat-toggle-btn:hover {
      background: rgba(179, 136, 255, 0.15);
    }

    .stat-toggle-btn.expanded {
      background: rgba(179, 136, 255, 0.2);
    }

    .adversary-stats {
      display: none;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .adversary-stats.visible {
      display: block;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
      margin-bottom: 10px;
    }

    .stat-item {
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 6px;
      text-align: center;
    }

    .stat-label {
      font-size: 0.65rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .stat-value {
      font-size: 1rem;
      font-weight: 700;
      color: #ffd700;
    }

    .traits-section, .abilities-section {
      margin-top: 8px;
    }

    .section-label {
      font-size: 0.7rem;
      color: #b388ff;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 5px;
    }

    .trait-tag {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(179, 136, 255, 0.2);
      border-radius: 4px;
      font-size: 0.75rem;
      color: #e0e0e0;
      margin-right: 5px;
      margin-bottom: 5px;
    }

    .ability-item {
      font-size: 0.8rem;
      color: #ccc;
      padding: 5px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .ability-item:last-child {
      border-bottom: none;
    }

    .hide-spotlight-btn {
      width: 100%;
      padding: 10px;
      margin-top: 15px;
      border: none;
      border-radius: 8px;
      background: rgba(255,68,68,0.2);
      color: #ff6b6b;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .hide-spotlight-btn:hover {
      background: rgba(255,68,68,0.3);
    }

    .hide-spotlight-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    /* Sample Encounter Button */
    .sample-btn {
      padding: 8px 16px;
      border: 1px solid rgba(179, 136, 255, 0.3);
      border-radius: 6px;
      background: transparent;
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .sample-btn:hover {
      background: rgba(179, 136, 255, 0.15);
    }

    /* HP/Stress Tracker */
    .adversary-trackers {
      display: flex;
      gap: 12px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .tracker {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(0,0,0,0.3);
      padding: 6px 10px;
      border-radius: 6px;
    }

    .tracker-label {
      font-size: 0.7rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 45px;
    }

    .tracker-hp .tracker-label {
      color: #ff6b6b;
    }

    .tracker-stress .tracker-label {
      color: #b388ff;
    }

    .tracker-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .tracker-btn {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      color: #ccc;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .tracker-btn:hover {
      background: rgba(255,255,255,0.2);
    }

    .tracker-btn.minus:hover {
      background: rgba(255,68,68,0.3);
      color: #ff6b6b;
    }

    .tracker-btn.plus:hover {
      background: rgba(102,187,106,0.3);
      color: #66bb6a;
    }

    .tracker-value {
      min-width: 50px;
      text-align: center;
      font-size: 0.9rem;
      font-weight: 700;
    }

    .tracker-hp .tracker-value {
      color: #ff6b6b;
    }

    .tracker-stress .tracker-value {
      color: #b388ff;
    }

    .tracker-value.depleted {
      color: #666;
    }

    .tracker-value.critical {
      color: #ff4444;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .adversary-card.defeated {
      opacity: 0.5;
      border-color: rgba(255,68,68,0.3);
    }

    .adversary-card.defeated .adversary-name {
      text-decoration: line-through;
      color: #888;
    }

    .defeated-badge {
      background: rgba(255,68,68,0.2);
      color: #ff6b6b;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.7rem;
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <h1>‚öîÔ∏è GM Control Panel</h1>
  <p class="subtitle">Your players don't see this screen</p>
  
  <!-- Open Player Display -->
  <div class="section">
    <button class="open-display-btn" onclick="openPlayerDisplay()">
      üñ•Ô∏è Open Player Display Window
    </button>
    <p class="status" id="status">Click above to open the player-facing display</p>
  </div>
  
  <!-- Fear Tracker -->
  <div class="section">
    <h2>‚ò†Ô∏è Fear Tracker</h2>
    <div class="fear-controls">
      <div class="fear-display" id="fearDisplay">0</div>
      <div class="fear-buttons">
        <button class="fear-btn remove" onclick="adjustFear(-1)">‚àí</button>
        <button class="fear-btn add" onclick="adjustFear(1)">+</button>
        <button class="fear-btn reset" onclick="resetFear()">Reset</button>
      </div>
    </div>
  </div>

  <!-- NPC Portrait -->
  <div class="section">
    <h2>üé≠ NPC Portrait</h2>
    <div class="npc-portrait-container">
      <div class="npc-upload-row">
        <input type="file" id="npcImageInput" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
        <button class="npc-upload-btn" onclick="document.getElementById('npcImageInput').click()">
          üìÅ Browse for Image...
        </button>
        <button class="npc-clear-btn" id="clearImageBtn" onclick="clearNpcImage()" disabled>
          Clear
        </button>
      </div>
      <div class="npc-preview-container">
        <img id="npcPreview" class="npc-preview" alt="NPC Preview">
        <div id="npcPlaceholder" class="npc-placeholder">No image selected</div>
      </div>
      <div class="toggle-row">
        <div>
          <span class="toggle-label">Show to Players</span>
          <span class="toggle-status" id="toggleStatus">Hidden</span>
        </div>
        <label class="toggle-switch">
          <input type="checkbox" id="npcVisibilityToggle" onchange="toggleNpcVisibility()" disabled>
          <span class="toggle-slider"></span>
        </label>
      </div>
    </div>
  </div>

  <!-- Encounters -->
  <div class="section">
    <h2>‚öîÔ∏è Encounters</h2>
    <div class="encounter-controls">
      <input type="file" id="encounterFolderInput" webkitdirectory directory style="display: none;" onchange="handleEncounterFolderUpload(event)">
      <input type="file" id="encounterFileInput" accept=".json" style="display: none;" onchange="handleEncounterUpload(event)">
      <input type="file" id="adversaryImageInput" accept="image/*" style="display: none;" multiple onchange="handleAdversaryImageUpload(event)">
      <button class="encounter-upload-btn" onclick="document.getElementById('encounterFolderInput').click()">
        üìÅ Load Encounter Folder
      </button>
      <button class="encounter-clear-btn" id="clearEncounterBtn" onclick="clearEncounter()" disabled>
        Clear
      </button>
      <button class="sample-btn" onclick="loadSampleEncounter()">
        Sample
      </button>
    </div>
    <div id="encounterContainer">
      <div class="encounter-empty">
        No encounter loaded.<br>
        <small style="color: #888; display: block; margin-top: 8px;">
          Create a folder with encounter.json + images.<br>
          Use "portrait": "filename.png" in your JSON.
        </small>
      </div>
    </div>
    <button class="hide-spotlight-btn" id="hideSpotlightBtn" onclick="hideSpotlight()" disabled>
      Hide Spotlight
    </button>
  </div>

  <!-- Dice Roller -->
  <div class="section">
    <h2>üé≤ Dice Roller</h2>

    <div class="dice-input-row">
      <input type="text" id="diceNotation" class="dice-notation-input" placeholder="e.g. 1d20+1d6+2" value="1d20">
      <button class="roll-btn" onclick="rollNotation()">Roll</button>
    </div>

    <div class="quick-dice">
      <button class="quick-dice-btn" onclick="setNotation('1d4')">d4</button>
      <button class="quick-dice-btn" onclick="setNotation('1d6')">d6</button>
      <button class="quick-dice-btn" onclick="setNotation('1d8')">d8</button>
      <button class="quick-dice-btn" onclick="setNotation('1d10')">d10</button>
      <button class="quick-dice-btn" onclick="setNotation('1d12')">d12</button>
      <button class="quick-dice-btn" onclick="setNotation('1d20')">d20</button>
      <button class="quick-dice-btn" onclick="setNotation('2d6')">2d6</button>
      <button class="quick-dice-btn" onclick="setNotation('1d20+5')">d20+5</button>
    </div>

    <div class="dice-grid">
      <button class="dice-btn hope-fear" onclick="rollHopeFear()">‚öîÔ∏è Hope / Fear</button>
    </div>

    <div class="last-roll">
      <div class="last-roll-label">Last Roll</div>
      <div class="last-roll-result" id="lastRoll">‚Äî</div>
    </div>
  </div>

  <script>
    let currentFear = 0;
    let currentNpcImage = null;
    let npcVisible = false;

    // Encounter state
    let currentEncounter = null;
    let spotlightedAdversary = null;
    let pendingImageUploadAdversaryId = null;

    // Initialize from localStorage
    function init() {
      const stored = localStorage.getItem('daggerheart-fear');
      if (stored) {
        currentFear = parseInt(stored) || 0;
        updateFearDisplay();
      }

      // Initialize NPC portrait state
      const npcData = localStorage.getItem('daggerheart-npc');
      if (npcData) {
        const parsed = JSON.parse(npcData);
        if (parsed.image) {
          currentNpcImage = parsed.image;
          npcVisible = parsed.visible || false;
          updateNpcPreview();
        }
      }

      // Initialize encounter state
      const encounterData = localStorage.getItem('daggerheart-encounter');
      if (encounterData) {
        const parsed = JSON.parse(encounterData);
        currentEncounter = parsed.encounter;
        renderEncounter();
      }

      // Initialize spotlight state
      const spotlightData = localStorage.getItem('daggerheart-spotlight');
      if (spotlightData) {
        const parsed = JSON.parse(spotlightData);
        if (parsed.visible && parsed.adversaryId && currentEncounter) {
          spotlightedAdversary = parsed.adversaryId;
          updateSpotlightUI();
        }
      }
    }

    // Handle image file selection
    function handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Check file size (limit to 5MB for localStorage)
      if (file.size > 5 * 1024 * 1024) {
        alert('Image too large. Please select an image under 5MB.');
        return;
      }

      const reader = new FileReader();
      reader.onload = function(e) {
        currentNpcImage = e.target.result;
        updateNpcPreview();
        syncNpcToStorage();
      };
      reader.readAsDataURL(file);
    }

    // Update the preview display
    function updateNpcPreview() {
      const preview = document.getElementById('npcPreview');
      const placeholder = document.getElementById('npcPlaceholder');
      const clearBtn = document.getElementById('clearImageBtn');
      const toggle = document.getElementById('npcVisibilityToggle');
      const toggleStatus = document.getElementById('toggleStatus');

      if (currentNpcImage) {
        preview.src = currentNpcImage;
        preview.classList.add('visible');
        placeholder.classList.add('hidden');
        clearBtn.disabled = false;
        toggle.disabled = false;
        toggle.checked = npcVisible;
        toggleStatus.textContent = npcVisible ? 'Visible' : 'Hidden';
        toggleStatus.classList.toggle('visible', npcVisible);
      } else {
        preview.src = '';
        preview.classList.remove('visible');
        placeholder.classList.remove('hidden');
        clearBtn.disabled = true;
        toggle.disabled = true;
        toggle.checked = false;
        toggleStatus.textContent = 'Hidden';
        toggleStatus.classList.remove('visible');
      }
    }

    // Toggle NPC visibility to players
    function toggleNpcVisibility() {
      npcVisible = document.getElementById('npcVisibilityToggle').checked;
      const toggleStatus = document.getElementById('toggleStatus');
      toggleStatus.textContent = npcVisible ? 'Visible' : 'Hidden';
      toggleStatus.classList.toggle('visible', npcVisible);
      syncNpcToStorage();
    }

    // Clear the NPC image
    function clearNpcImage() {
      currentNpcImage = null;
      npcVisible = false;
      document.getElementById('npcImageInput').value = '';
      updateNpcPreview();
      syncNpcToStorage();
    }

    // Sync NPC data to localStorage
    function syncNpcToStorage() {
      const npcData = {
        image: currentNpcImage,
        visible: npcVisible,
        timestamp: Date.now()
      };
      localStorage.setItem('daggerheart-npc', JSON.stringify(npcData));
    }

    // ============ ENCOUNTER FUNCTIONS ============

    // Handle encounter JSON file upload
    function handleEncounterUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const encounter = JSON.parse(e.target.result);

          // Validate encounter structure
          if (!encounter.name || !Array.isArray(encounter.adversaries)) {
            alert('Invalid encounter file. Must have "name" and "adversaries" array.');
            return;
          }

          // Add unique IDs to adversaries if not present
          encounter.adversaries = encounter.adversaries.map((adv, idx) => ({
            ...adv,
            id: adv.id || `adv-${Date.now()}-${idx}`,
            portraits: adv.portraits || [],
            activePortraitIndex: 0
          }));

          currentEncounter = encounter;
          spotlightedAdversary = null;
          renderEncounter();
          syncEncounterToStorage();
          syncSpotlightToStorage();
        } catch (err) {
          alert('Error parsing encounter file: ' + err.message);
        }
      };
      reader.readAsText(file);
      event.target.value = ''; // Reset input
    }

    // Handle encounter folder upload (folder with JSON + images)
    function handleEncounterFolderUpload(event) {
      const files = Array.from(event.target.files);
      if (!files.length) return;

      // Find the JSON file
      const jsonFile = files.find(f => f.name.endsWith('.json'));
      if (!jsonFile) {
        alert('No JSON file found in folder. Please include an encounter.json file.');
        return;
      }

      // Find all image files
      const imageFiles = files.filter(f =>
        f.type.startsWith('image/') ||
        /\.(png|jpg|jpeg|gif|webp|svg)$/i.test(f.name)
      );

      // Read the JSON file first
      const jsonReader = new FileReader();
      jsonReader.onload = function(e) {
        try {
          const encounter = JSON.parse(e.target.result);

          // Validate encounter structure
          if (!encounter.name || !Array.isArray(encounter.adversaries)) {
            alert('Invalid encounter file. Must have "name" and "adversaries" array.');
            return;
          }

          // Process adversaries and match images
          const imageLoadPromises = [];
          const imageMap = new Map(); // filename -> base64 data

          // Load all images first
          imageFiles.forEach(imgFile => {
            const promise = new Promise((resolve) => {
              const reader = new FileReader();
              reader.onload = function(imgE) {
                // Store with just the filename (not the path)
                const filename = imgFile.name;
                imageMap.set(filename.toLowerCase(), imgE.target.result);
                resolve();
              };
              reader.onerror = () => resolve(); // Continue even if image fails
              reader.readAsDataURL(imgFile);
            });
            imageLoadPromises.push(promise);
          });

          // After all images are loaded, process the encounter
          Promise.all(imageLoadPromises).then(() => {
            // Add unique IDs and match images to adversaries
            encounter.adversaries = encounter.adversaries.map((adv, idx) => {
              const processedAdv = {
                ...adv,
                id: adv.id || `adv-${Date.now()}-${idx}`,
                portraits: [],
                activePortraitIndex: 0
              };

              // Check for image reference in JSON (supports: portrait, image, portraits array)
              const imageRefs = [];

              if (adv.portrait) {
                imageRefs.push(adv.portrait);
              }
              if (adv.image) {
                imageRefs.push(adv.image);
              }
              if (Array.isArray(adv.portraits)) {
                imageRefs.push(...adv.portraits.filter(p => typeof p === 'string' && !p.startsWith('data:')));
              }

              // Match image references to loaded images
              imageRefs.forEach(ref => {
                const filename = ref.toLowerCase();
                if (imageMap.has(filename)) {
                  processedAdv.portraits.push(imageMap.get(filename));
                }
              });

              return processedAdv;
            });

            currentEncounter = encounter;
            spotlightedAdversary = null;
            renderEncounter();
            syncEncounterToStorage();
            syncSpotlightToStorage();

            // Show feedback
            const loadedImages = encounter.adversaries.reduce((sum, adv) => sum + adv.portraits.length, 0);
            if (loadedImages > 0) {
              console.log(`Loaded encounter "${encounter.name}" with ${loadedImages} image(s)`);
            } else if (imageFiles.length > 0) {
              alert(`Loaded encounter but couldn't match images. Make sure your JSON uses "portrait" or "image" fields matching the image filenames.`);
            }
          });

        } catch (err) {
          alert('Error parsing encounter file: ' + err.message);
        }
      };
      jsonReader.readAsText(jsonFile);
      event.target.value = ''; // Reset input
    }

    // Load sample encounter for testing
    function loadSampleEncounter() {
      const sampleEncounter = {
        name: "Skeleton Ambush",
        adversaries: [
          {
            id: "skeleton-1",
            name: "Skeleton Warrior",
            tier: 1,
            hp: 6,
            stress: 3,
            attack: "+2 (2d6+2 physical)",
            defense: 10,
            traits: ["Undead", "Fearless"],
            abilities: [
              "Bone Strike: Melee attack dealing 2d6+2 physical damage",
              "Reassemble: Once per encounter, regain 1d6 HP when reduced to 0"
            ],
            portraits: [],
            activePortraitIndex: 0
          },
          {
            id: "skeleton-2",
            name: "Skeleton Archer",
            tier: 1,
            hp: 4,
            stress: 2,
            attack: "+3 (2d6+1 physical, ranged)",
            defense: 8,
            traits: ["Undead", "Fearless"],
            abilities: [
              "Arrow Volley: Ranged attack dealing 2d6+1 physical damage",
              "Bone Shield: Reaction - reduce incoming damage by 2"
            ],
            portraits: [],
            activePortraitIndex: 0
          },
          {
            id: "ooze-1",
            name: "Crimson Ooze",
            tier: 2,
            hp: 12,
            stress: 4,
            attack: "+1 (2d8 acid)",
            defense: 6,
            traits: ["Ooze", "Acidic", "Slow"],
            abilities: [
              "Engulf: Melee attack dealing 2d8 acid damage. On hit, target is grappled",
              "Split: When reduced to half HP, split into two smaller oozes with 4 HP each",
              "Acid Trail: Leaves acidic residue that deals 1d4 damage to creatures that step in it"
            ],
            portraits: [],
            activePortraitIndex: 0
          }
        ]
      };

      currentEncounter = sampleEncounter;
      spotlightedAdversary = null;
      renderEncounter();
      syncEncounterToStorage();
      syncSpotlightToStorage();
    }

    // Render the encounter UI
    function renderEncounter() {
      const container = document.getElementById('encounterContainer');
      const clearBtn = document.getElementById('clearEncounterBtn');

      if (!currentEncounter) {
        container.innerHTML = `
          <div class="encounter-empty">
            No encounter loaded.<br>
            <small style="color: #888; display: block; margin-top: 8px;">
              Create a folder with encounter.json + images.<br>
              Use "portrait": "filename.png" in your JSON.
            </small>
          </div>
        `;
        clearBtn.disabled = true;
        return;
      }

      clearBtn.disabled = false;

      let html = `<div class="encounter-name">${currentEncounter.name}</div>`;
      html += '<div class="adversary-list">';

      currentEncounter.adversaries.forEach((adv, index) => {
        const isSpotlighted = spotlightedAdversary === adv.id;
        const hasPortrait = adv.portraits && adv.portraits.length > 0;
        const activePortrait = hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : null;

        // Initialize current HP/Stress if not set
        if (adv.hp !== undefined && adv.currentHp === undefined) {
          adv.currentHp = adv.hp;
        }
        if (adv.stress !== undefined && adv.currentStress === undefined) {
          adv.currentStress = adv.stress;
        }

        const isDefeated = adv.hp !== undefined && adv.currentHp <= 0;
        const hpCritical = adv.hp !== undefined && adv.currentHp > 0 && adv.currentHp <= Math.ceil(adv.hp / 4);

        html += `
          <div class="adversary-card ${isSpotlighted ? 'spotlighted' : ''} ${isDefeated ? 'defeated' : ''}" data-adversary-id="${adv.id}">
            <div class="adversary-header">
              <div class="adversary-portrait-thumb" onclick="triggerImageUpload('${adv.id}')" title="Click to add portrait">
                ${activePortrait ?
                  `<img src="${activePortrait}" alt="${adv.name}">` :
                  '<span class="upload-icon">üì∑</span>'}
              </div>
              <div class="adversary-info">
                <div class="adversary-name">
                  ${adv.name}
                  ${isDefeated ? '<span class="defeated-badge">DEFEATED</span>' : ''}
                </div>
                <div class="adversary-tier">Tier ${adv.tier || 1}</div>
                ${hasPortrait && adv.portraits.length > 1 ? `
                  <div class="adversary-portrait-gallery">
                    ${adv.portraits.map((p, pIdx) => `
                      <div class="gallery-thumb ${pIdx === (adv.activePortraitIndex || 0) ? 'active' : ''}"
                           onclick="selectPortrait('${adv.id}', ${pIdx})">
                        <img src="${p}" alt="Portrait ${pIdx + 1}">
                      </div>
                    `).join('')}
                    <button class="add-image-btn" onclick="triggerImageUpload('${adv.id}')" title="Add another portrait">+</button>
                  </div>
                ` : ''}
              </div>
              <div class="adversary-actions">
                <button class="spotlight-btn ${isSpotlighted ? 'active' : ''}"
                        onclick="toggleSpotlight('${adv.id}')"
                        ${!hasPortrait ? 'disabled title="Add a portrait first"' : ''}>
                  ${isSpotlighted ? '‚òÖ Lit' : '‚òÜ Show'}
                </button>
                <button class="stat-toggle-btn" onclick="toggleStats('${adv.id}')">Stats</button>
              </div>
            </div>
            ${(adv.hp !== undefined || adv.stress !== undefined) ? `
              <div class="adversary-trackers">
                ${adv.hp !== undefined ? `
                  <div class="tracker tracker-hp">
                    <span class="tracker-label">HP</span>
                    <div class="tracker-controls">
                      <button class="tracker-btn minus" onclick="adjustHp('${adv.id}', -1)">-</button>
                      <span class="tracker-value ${adv.currentHp <= 0 ? 'depleted' : ''} ${hpCritical ? 'critical' : ''}">${adv.currentHp} / ${adv.hp}</span>
                      <button class="tracker-btn plus" onclick="adjustHp('${adv.id}', 1)">+</button>
                    </div>
                  </div>
                ` : ''}
                ${adv.stress !== undefined ? `
                  <div class="tracker tracker-stress">
                    <span class="tracker-label">Stress</span>
                    <div class="tracker-controls">
                      <button class="tracker-btn minus" onclick="adjustStress('${adv.id}', -1)">-</button>
                      <span class="tracker-value ${adv.currentStress <= 0 ? 'depleted' : ''}">${adv.currentStress} / ${adv.stress}</span>
                      <button class="tracker-btn plus" onclick="adjustStress('${adv.id}', 1)">+</button>
                    </div>
                  </div>
                ` : ''}
              </div>
            ` : ''}
            <div class="adversary-stats" id="stats-${adv.id}">
              <div class="stat-grid">
                ${adv.defense !== undefined ? `<div class="stat-item"><div class="stat-label">Defense</div><div class="stat-value">${adv.defense}</div></div>` : ''}
                ${adv.attack ? `<div class="stat-item"><div class="stat-label">Attack</div><div class="stat-value" style="font-size: 0.75rem;">${adv.attack}</div></div>` : ''}
              </div>
              ${adv.traits && adv.traits.length > 0 ? `
                <div class="traits-section">
                  <div class="section-label">Traits</div>
                  ${adv.traits.map(t => `<span class="trait-tag">${t}</span>`).join('')}
                </div>
              ` : ''}
              ${adv.abilities && adv.abilities.length > 0 ? `
                <div class="abilities-section">
                  <div class="section-label">Abilities</div>
                  ${adv.abilities.map(a => `<div class="ability-item">${a}</div>`).join('')}
                </div>
              ` : ''}
            </div>
          </div>
        `;
      });

      html += '</div>';
      container.innerHTML = html;
      updateSpotlightUI();
    }

    // Toggle stat block visibility
    function toggleStats(adversaryId) {
      const statsEl = document.getElementById(`stats-${adversaryId}`);
      const btn = document.querySelector(`[data-adversary-id="${adversaryId}"] .stat-toggle-btn`);

      if (statsEl) {
        statsEl.classList.toggle('visible');
        btn.classList.toggle('expanded');
      }
    }

    // Adjust HP for an adversary
    function adjustHp(adversaryId, amount) {
      const adversary = currentEncounter.adversaries.find(a => a.id === adversaryId);
      if (!adversary || adversary.hp === undefined) return;

      // Initialize current HP if needed
      if (adversary.currentHp === undefined) {
        adversary.currentHp = adversary.hp;
      }

      // Adjust HP (can go negative but not above max)
      adversary.currentHp = Math.min(adversary.hp, adversary.currentHp + amount);

      renderEncounter();
      syncEncounterToStorage();
    }

    // Adjust Stress for an adversary
    function adjustStress(adversaryId, amount) {
      const adversary = currentEncounter.adversaries.find(a => a.id === adversaryId);
      if (!adversary || adversary.stress === undefined) return;

      // Initialize current Stress if needed
      if (adversary.currentStress === undefined) {
        adversary.currentStress = adversary.stress;
      }

      // Adjust Stress (can go negative but not above max)
      adversary.currentStress = Math.min(adversary.stress, adversary.currentStress + amount);

      renderEncounter();
      syncEncounterToStorage();
    }

    // Trigger image upload for specific adversary
    function triggerImageUpload(adversaryId) {
      pendingImageUploadAdversaryId = adversaryId;
      document.getElementById('adversaryImageInput').click();
    }

    // Handle adversary portrait image upload
    function handleAdversaryImageUpload(event) {
      const files = event.target.files;
      if (!files.length || !pendingImageUploadAdversaryId) return;

      const adversary = currentEncounter.adversaries.find(a => a.id === pendingImageUploadAdversaryId);
      if (!adversary) return;

      // Process each file
      let loadedCount = 0;
      Array.from(files).forEach(file => {
        if (file.size > 5 * 1024 * 1024) {
          alert(`Image "${file.name}" is too large. Please select images under 5MB.`);
          return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
          if (!adversary.portraits) {
            adversary.portraits = [];
          }
          adversary.portraits.push(e.target.result);
          adversary.activePortraitIndex = adversary.portraits.length - 1;
          loadedCount++;

          // After all files are loaded, update UI
          if (loadedCount === files.length) {
            renderEncounter();
            syncEncounterToStorage();

            // If this adversary is spotlighted, update the spotlight
            if (spotlightedAdversary === adversary.id) {
              syncSpotlightToStorage();
            }
          }
        };
        reader.readAsDataURL(file);
      });

      event.target.value = ''; // Reset input
      pendingImageUploadAdversaryId = null;
    }

    // Select a specific portrait from the gallery
    function selectPortrait(adversaryId, portraitIndex) {
      const adversary = currentEncounter.adversaries.find(a => a.id === adversaryId);
      if (!adversary) return;

      adversary.activePortraitIndex = portraitIndex;
      renderEncounter();
      syncEncounterToStorage();

      // If this adversary is spotlighted, update the spotlight
      if (spotlightedAdversary === adversaryId) {
        syncSpotlightToStorage();
      }
    }

    // Toggle spotlight for an adversary
    function toggleSpotlight(adversaryId) {
      const adversary = currentEncounter.adversaries.find(a => a.id === adversaryId);
      if (!adversary || !adversary.portraits || adversary.portraits.length === 0) return;

      if (spotlightedAdversary === adversaryId) {
        // Turn off spotlight
        spotlightedAdversary = null;
      } else {
        // Spotlight this adversary
        spotlightedAdversary = adversaryId;
      }

      renderEncounter();
      syncSpotlightToStorage();
    }

    // Hide spotlight (turn off current spotlight)
    function hideSpotlight() {
      spotlightedAdversary = null;
      renderEncounter();
      syncSpotlightToStorage();
    }

    // Update spotlight UI elements
    function updateSpotlightUI() {
      const hideBtn = document.getElementById('hideSpotlightBtn');
      hideBtn.disabled = !spotlightedAdversary;
    }

    // Clear current encounter
    function clearEncounter() {
      currentEncounter = null;
      spotlightedAdversary = null;
      renderEncounter();
      syncEncounterToStorage();
      syncSpotlightToStorage();
      document.getElementById('encounterFileInput').value = '';
    }

    // Sync encounter data to localStorage
    function syncEncounterToStorage() {
      if (currentEncounter) {
        const encounterData = {
          encounter: currentEncounter,
          timestamp: Date.now()
        };
        localStorage.setItem('daggerheart-encounter', JSON.stringify(encounterData));
      } else {
        localStorage.removeItem('daggerheart-encounter');
      }
    }

    // Sync spotlight data to localStorage (this is what player display reads)
    function syncSpotlightToStorage() {
      if (spotlightedAdversary && currentEncounter) {
        const adversary = currentEncounter.adversaries.find(a => a.id === spotlightedAdversary);
        if (adversary && adversary.portraits && adversary.portraits.length > 0) {
          const spotlightData = {
            visible: true,
            adversaryId: adversary.id,
            name: adversary.name,
            image: adversary.portraits[adversary.activePortraitIndex || 0],
            timestamp: Date.now()
          };
          localStorage.setItem('daggerheart-spotlight', JSON.stringify(spotlightData));
          document.getElementById('hideSpotlightBtn').disabled = false;
          return;
        }
      }

      // No spotlight
      const spotlightData = {
        visible: false,
        timestamp: Date.now()
      };
      localStorage.setItem('daggerheart-spotlight', JSON.stringify(spotlightData));
      document.getElementById('hideSpotlightBtn').disabled = true;
    }

    // ============ END ENCOUNTER FUNCTIONS ============

    function updateFearDisplay() {
      const display = document.getElementById('fearDisplay');
      display.textContent = currentFear;
      display.style.color = currentFear > 8 ? '#ff4444' : currentFear > 4 ? '#b388ff' : '#ffd700';
    }
    
    function adjustFear(amount) {
      currentFear = Math.max(0, Math.min(12, currentFear + amount));
      updateFearDisplay();
      
      // Send to player display
      localStorage.setItem('daggerheart-fear', currentFear);
      localStorage.setItem('daggerheart-update', Date.now()); // Trigger update
    }
    
    function resetFear() {
      currentFear = 0;
      updateFearDisplay();
      localStorage.setItem('daggerheart-fear', 0);
      localStorage.setItem('daggerheart-update', Date.now());
    }
    
    function setNotation(notation) {
      document.getElementById('diceNotation').value = notation;
    }

    function parseAndRollNotation(notation) {
      // Parse notation like "1d20+2d6+5" or "2d8-1"
      const cleanNotation = notation.replace(/\s/g, '').toLowerCase();

      // Split by + and - while keeping the operators
      const parts = cleanNotation.split(/(?=[+-])/);

      const diceRolls = []; // Array of {sides, count, results}
      let modifier = 0;
      let total = 0;
      const breakdown = [];

      for (const part of parts) {
        const trimmed = part.replace(/^\+/, ''); // Remove leading +

        // Check if it's a dice roll (contains 'd')
        const diceMatch = trimmed.match(/^(-?)(\d*)d(\d+)$/);

        if (diceMatch) {
          const negative = diceMatch[1] === '-';
          const count = parseInt(diceMatch[2]) || 1;
          const sides = parseInt(diceMatch[3]);
          const results = [];

          for (let i = 0; i < count; i++) {
            results.push(Math.floor(Math.random() * sides) + 1);
          }

          const subtotal = results.reduce((a, b) => a + b, 0) * (negative ? -1 : 1);
          total += subtotal;

          diceRolls.push({ sides, count, results, negative });

          if (count === 1) {
            breakdown.push((negative ? '-' : (breakdown.length > 0 ? '+' : '')) + results[0]);
          } else {
            breakdown.push((negative ? '-(' : (breakdown.length > 0 ? '+(' : '(')) + results.join('+') + ')');
          }
        } else {
          // It's a flat modifier
          const num = parseInt(trimmed);
          if (!isNaN(num)) {
            modifier += num;
            total += num;
            if (num >= 0 && breakdown.length > 0) {
              breakdown.push('+' + num);
            } else {
              breakdown.push(num.toString());
            }
          }
        }
      }

      return { diceRolls, modifier, total, breakdown, notation: cleanNotation };
    }

    function rollNotation() {
      const notation = document.getElementById('diceNotation').value.trim();
      if (!notation) return;

      const result = parseAndRollNotation(notation);

      // Display result
      const breakdownStr = result.breakdown.join('');
      document.getElementById('lastRoll').textContent = `${notation}: ${breakdownStr} = ${result.total}`;

      // Send to player display
      localStorage.setItem('daggerheart-dice', JSON.stringify({
        type: 'notation',
        notation: result.notation,
        diceRolls: result.diceRolls,
        modifier: result.modifier,
        total: result.total,
        breakdown: result.breakdown,
        timestamp: Date.now()
      }));
    }

    // Allow Enter key to roll
    document.addEventListener('DOMContentLoaded', function() {
      document.getElementById('diceNotation').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          rollNotation();
        }
      });
    });
    
    function rollHopeFear() {
      const hope = Math.floor(Math.random() * 12) + 1;
      const fear = Math.floor(Math.random() * 12) + 1;
      const winner = hope >= fear ? 'HOPE' : 'FEAR';
      
      document.getElementById('lastRoll').textContent = `Hope: ${hope} | Fear: ${fear} ‚Üí ${winner}!`;
      
      // Send to player display
      localStorage.setItem('daggerheart-dice', JSON.stringify({
        type: 'hopefear',
        hope: hope,
        fear: fear,
        winner: winner,
        timestamp: Date.now()
      }));
    }
    
    function openPlayerDisplay() {
      const playerWindow = window.open('player-display.html', 'PlayerDisplay', 
        'width=1920,height=1080,menubar=no,toolbar=no,location=no,status=no');
      
      if (playerWindow) {
        document.getElementById('status').textContent = '‚úì Player display opened! Drag it to your player-facing monitor.';
      } else {
        document.getElementById('status').textContent = '‚ö†Ô∏è Pop-up blocked. Please allow pop-ups or open player-display.html manually.';
        document.getElementById('status').style.color = '#ff6b6b';
      }
    }
    
    init();
  </script>
</body>
</html>
