<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daggerheart - Battle Map</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #1a0d24;
      font-family: 'Cinzel', serif;
      cursor: none;
    }

    /* Connection Status */
    #connectionStatus {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid rgba(179, 136, 255, 0.4);
      border-radius: 12px;
      padding: 16px 20px;
      z-index: 1000;
      font-family: 'Cinzel', serif;
      cursor: default;
      transition: all 0.3s ease;
    }

    #connectionStatus.connected {
      border-color: rgba(76, 175, 80, 0.6);
      background: rgba(0, 30, 0, 0.85);
    }

    #connectionStatus.minimized {
      padding: 8px 12px;
    }

    #connectionStatus.minimized .connection-details {
      display: none;
    }

    .connection-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    #connectionStatus.minimized .connection-header {
      margin-bottom: 0;
    }

    .connection-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff9800;
      animation: pulse 2s infinite;
    }

    #connectionStatus.connected .connection-indicator {
      background: #4caf50;
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .connection-title {
      font-size: 0.85rem;
      color: #b388ff;
    }

    #connectionStatus.connected .connection-title {
      color: #81c784;
    }

    .connection-details {
      margin-top: 8px;
    }

    .room-code-input {
      width: 100%;
      padding: 10px;
      margin: 8px 0;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.4);
      color: #ffd700;
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      font-weight: 700;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .room-code-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .room-code-input::placeholder {
      color: #555;
      font-weight: 400;
    }

    .connect-btn {
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .connect-btn:hover:not(:disabled) {
      transform: scale(1.02);
      filter: brightness(1.1);
    }

    .connect-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .connect-btn.connecting {
      background: linear-gradient(135deg, #ff9800, #e65100);
    }

    .room-code-label {
      font-size: 0.7rem;
      color: #888;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }

    .connected-info {
      font-size: 0.8rem;
      color: #81c784;
      text-align: center;
      padding: 10px 0;
    }

    .minimize-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      color: #888;
      cursor: pointer;
      font-size: 1rem;
      padding: 4px;
      line-height: 1;
    }

    .minimize-btn:hover {
      color: #b388ff;
    }

    /* Map Display */
    #mapContainer {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: #1a0d24;
    }

    #mapContainer.visible {
      display: flex;
    }

    #mapImage {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      position: relative;
    }

    /* Token Layer */
    #tokenLayer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 100;
    }

    .token {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 3px solid;
      background-size: cover;
      background-position: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .token.player {
      border-color: #4CAF50;
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.6), 0 4px 12px rgba(0, 0, 0, 0.6);
    }

    .token.adversary {
      border-color: #f44336;
      box-shadow: 0 0 15px rgba(244, 67, 54, 0.6), 0 4px 12px rgba(0, 0, 0, 0.6);
    }

    .token-name {
      position: absolute;
      bottom: -22px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.7rem;
      white-space: nowrap;
      pointer-events: none;
    }

    .token-conditions {
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      gap: 2px;
    }

    .condition-badge {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      font-weight: bold;
      border: 2px solid rgba(0, 0, 0, 0.8);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }

    .condition-badge.hidden {
      background: linear-gradient(135deg, #424242 0%, #616161 100%);
      color: white;
    }

    .condition-badge.restrained {
      background: linear-gradient(135deg, #1976D2 0%, #42A5F5 100%);
      color: white;
    }

    .condition-badge.vulnerable {
      background: linear-gradient(135deg, #D32F2F 0%, #F44336 100%);
      color: white;
    }

    /* Grid Overlay */
    #gridOverlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 50;
      display: none;
    }

    #gridOverlay.visible {
      display: block;
    }

  </style>
</head>
<body>
  <!-- Connection Status -->
  <div id="connectionStatus">
    <button class="minimize-btn" onclick="toggleConnectionMinimize()">−</button>
    <div class="connection-header">
      <div class="connection-indicator"></div>
      <div class="connection-title">Enter GM Room Code</div>
    </div>
    <div class="connection-details">
      <div class="room-code-label">Room Code from GM Panel</div>
      <input type="text" id="roomCodeInput" class="room-code-input" placeholder="FIRE-DRAGON-00" maxlength="20" onkeyup="handleRoomCodeKeyup(event)">
      <button class="connect-btn" id="connectBtn" onclick="connectToGM()">Connect</button>
    </div>
  </div>

  <!-- Map Container -->
  <div id="mapContainer">
    <img id="mapImage" src="" alt="Battle Map">
  </div>

  <!-- Grid Overlay -->
  <canvas id="gridOverlay"></canvas>

  <!-- Token Layer -->
  <div id="tokenLayer"></div>

  <!-- PeerJS Library -->
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

  <script>
    let peer = null;
    let gmConnection = null;
    let currentMap = null;
    let tokens = [];
    let gridSize = 50;

    // Handle Enter key in room code input
    function handleRoomCodeKeyup(event) {
      if (event.key === 'Enter') {
        connectToGM();
      }
    }

    // Toggle connection status minimize
    function toggleConnectionMinimize() {
      const statusEl = document.getElementById('connectionStatus');
      statusEl.classList.toggle('minimized');
      const btn = statusEl.querySelector('.minimize-btn');
      btn.textContent = statusEl.classList.contains('minimized') ? '+' : '−';
    }

    // Connect to GM via PeerJS
    function connectToGM() {
      const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
      if (!roomCode) {
        return;
      }

      const statusEl = document.getElementById('connectionStatus');
      const connectBtn = document.getElementById('connectBtn');
      const indicator = statusEl.querySelector('.connection-indicator');
      const title = statusEl.querySelector('.connection-title');

      // Update UI to show connecting
      connectBtn.disabled = true;
      connectBtn.textContent = 'Connecting...';
      connectBtn.classList.add('connecting');
      title.textContent = 'Connecting to GM...';

      // Create peer if not already created
      if (!peer) {
        peer = new Peer({
          debug: 2,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              { urls: 'stun:stun2.l.google.com:19302' },
              { urls: 'stun:stun3.l.google.com:19302' },
              { urls: 'stun:stun4.l.google.com:19302' }
            ]
          }
        });

        peer.on('open', (id) => {
          console.log('Peer initialized with ID:', id);
        });

        peer.on('error', (err) => {
          console.error('PeerJS error:', err);
          indicator.style.background = '#f44336';
          title.textContent = 'Connection error: ' + err.type;
          connectBtn.disabled = false;
          connectBtn.textContent = 'Connect';
          connectBtn.classList.remove('connecting');
        });
      }

      // Connect to GM's peer ID
      const peerId = `dh-${roomCode}`;
      console.log('Attempting to connect to GM:', peerId);

      gmConnection = peer.connect(peerId, {
        serialization: 'binary',
        reliable: true
      });

      gmConnection.on('open', () => {
        console.log('Connected to GM!');

        // Update UI
        statusEl.classList.add('connected');
        title.textContent = 'Connected to GM';
        connectBtn.disabled = true;

        // Replace connection details with connected info
        statusEl.querySelector('.connection-details').innerHTML = `
          <div class="connected-info">Battle Map Connected</div>
        `;

        // Request full sync
        try {
          gmConnection.send({ type: 'battleMapConnected' });
        } catch (err) {
          console.error('Error sending connection message:', err);
        }
      });

      gmConnection.on('data', (data) => {
        handleGMData(data);
      });

      gmConnection.on('close', () => {
        console.log('Disconnected from GM');
        gmConnection = null;
        statusEl.classList.remove('connected');
        title.textContent = 'Disconnected from GM';
        statusEl.querySelector('.connection-details').innerHTML = `
          <div class="room-code-label">Room Code from GM Panel</div>
          <input type="text" id="roomCodeInput" class="room-code-input" placeholder="FIRE-DRAGON-00" maxlength="20" value="${roomCode}" onkeyup="handleRoomCodeKeyup(event)">
          <button class="connect-btn" id="connectBtn" onclick="connectToGM()">Reconnect</button>
        `;
      });

      gmConnection.on('error', (err) => {
        console.error('Connection error:', err);
        title.textContent = 'Failed to connect';
        connectBtn.disabled = false;
        connectBtn.textContent = 'Connect';
        connectBtn.classList.remove('connecting');
      });

      // Connection timeout
      setTimeout(() => {
        if (!gmConnection || !gmConnection.open) {
          console.log('Connection timeout');
          title.textContent = 'Connection timeout - GM not found';
          connectBtn.disabled = false;
          connectBtn.textContent = 'Retry';
          connectBtn.classList.remove('connecting');
        }
      }, 10000);
    }

    function handleGMData(data) {
      console.log('Received data from GM:', data);

      if (!data || !data.type) return;

      switch (data.type) {
        case 'map':
          updateMap(data);
          break;
        case 'tokens':
          updateTokens(data);
          break;
        case 'grid':
          updateGrid(data);
          break;
        case 'mapSync':
          // Full sync
          if (data.map) updateMap(data.map);
          if (data.tokens) updateTokens(data.tokens);
          if (data.grid) updateGrid(data.grid);
          break;
      }
    }

    function updateMap(data) {
      const mapContainer = document.getElementById('mapContainer');
      const mapImage = document.getElementById('mapImage');

      if (data.visible && data.mapImage) {
        currentMap = data;
        mapImage.src = data.mapImage;
        mapContainer.classList.add('visible');

        if (data.gridSize) {
          gridSize = data.gridSize;
        }
      } else {
        mapContainer.classList.remove('visible');
        currentMap = null;
      }
    }

    function updateTokens(data) {
      tokens = data.tokens || [];
      renderTokens();
    }

    function renderTokens() {
      const tokenLayer = document.getElementById('tokenLayer');
      tokenLayer.innerHTML = '';

      if (!currentMap || !tokens.length) return;

      const mapImage = document.getElementById('mapImage');
      const mapRect = mapImage.getBoundingClientRect();

      tokens.forEach(token => {
        const tokenEl = document.createElement('div');
        tokenEl.className = `token ${token.type}`;
        tokenEl.id = `token-${token.id}`;

        // Calculate position based on grid coordinates
        const pixelX = mapRect.left + (token.x * gridSize);
        const pixelY = mapRect.top + (token.y * gridSize);

        tokenEl.style.left = `${pixelX}px`;
        tokenEl.style.top = `${pixelY}px`;

        // Set token image
        if (token.image) {
          tokenEl.style.backgroundImage = `url(${token.image})`;
        } else {
          // Default colored circle if no image
          tokenEl.style.backgroundColor = token.type === 'player' ? '#4CAF50' : '#f44336';
        }

        // Add token name
        const nameEl = document.createElement('div');
        nameEl.className = 'token-name';
        nameEl.textContent = token.name;
        tokenEl.appendChild(nameEl);

        // Add condition badges
        if (token.conditions && Object.keys(token.conditions).length > 0) {
          const conditionsEl = document.createElement('div');
          conditionsEl.className = 'token-conditions';

          if (token.conditions.hidden) {
            const badge = document.createElement('div');
            badge.className = 'condition-badge hidden';
            badge.textContent = 'H';
            badge.title = 'Hidden';
            conditionsEl.appendChild(badge);
          }

          if (token.conditions.restrained) {
            const badge = document.createElement('div');
            badge.className = 'condition-badge restrained';
            badge.textContent = 'R';
            badge.title = 'Restrained';
            conditionsEl.appendChild(badge);
          }

          if (token.conditions.vulnerable) {
            const badge = document.createElement('div');
            badge.className = 'condition-badge vulnerable';
            badge.textContent = 'V';
            badge.title = 'Vulnerable';
            conditionsEl.appendChild(badge);
          }

          tokenEl.appendChild(conditionsEl);
        }

        tokenLayer.appendChild(tokenEl);
      });
    }

    function updateGrid(data) {
      const gridOverlay = document.getElementById('gridOverlay');

      if (data.visible) {
        gridOverlay.classList.add('visible');
        drawGrid();
      } else {
        gridOverlay.classList.remove('visible');
      }
    }

    function drawGrid() {
      const canvas = document.getElementById('gridOverlay');
      const ctx = canvas.getContext('2d');

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      if (!currentMap) return;

      const mapImage = document.getElementById('mapImage');
      const mapRect = mapImage.getBoundingClientRect();

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 1;

      // Draw vertical lines
      for (let x = mapRect.left; x < mapRect.right; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, mapRect.top);
        ctx.lineTo(x, mapRect.bottom);
        ctx.stroke();
      }

      // Draw horizontal lines
      for (let y = mapRect.top; y < mapRect.bottom; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(mapRect.left, y);
        ctx.lineTo(mapRect.right, y);
        ctx.stroke();
      }
    }

    // Redraw grid and tokens on window resize
    window.addEventListener('resize', () => {
      if (currentMap) {
        renderTokens();
        if (document.getElementById('gridOverlay').classList.contains('visible')) {
          drawGrid();
        }
      }
    });

    // localStorage fallback (for same-machine setup)
    function checkLocalStorage() {
      const mapData = localStorage.getItem('daggerheart-battle-map');
      const tokenData = localStorage.getItem('daggerheart-battle-tokens');
      const gridData = localStorage.getItem('daggerheart-battle-grid');

      if (mapData) {
        try {
          updateMap(JSON.parse(mapData));
        } catch (err) {
          console.error('Error parsing map data:', err);
        }
      }

      if (tokenData) {
        try {
          updateTokens(JSON.parse(tokenData));
        } catch (err) {
          console.error('Error parsing token data:', err);
        }
      }

      if (gridData) {
        try {
          updateGrid(JSON.parse(gridData));
        } catch (err) {
          console.error('Error parsing grid data:', err);
        }
      }
    }

    // Poll localStorage every 100ms as fallback
    setInterval(checkLocalStorage, 100);

    // Listen for storage events (cross-tab)
    window.addEventListener('storage', (e) => {
      if (e.key === 'daggerheart-battle-map' && e.newValue) {
        updateMap(JSON.parse(e.newValue));
      } else if (e.key === 'daggerheart-battle-tokens' && e.newValue) {
        updateTokens(JSON.parse(e.newValue));
      } else if (e.key === 'daggerheart-battle-grid' && e.newValue) {
        updateGrid(JSON.parse(e.newValue));
      }
    });
  </script>
</body>
</html>
