<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GM Control Panel - Streamlined</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Cinzel', serif;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
    }

    /* Header Bar - Always visible */
    .header-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 15px;
      background: rgba(0,0,0,0.4);
      border-bottom: 1px solid rgba(179, 136, 255, 0.3);
      flex-shrink: 0;
    }

    .header-title {
      font-size: 1rem;
      background: linear-gradient(180deg, #ffd700, #b8860b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .header-btn {
      padding: 6px 12px;
      border: 1px solid rgba(179, 136, 255, 0.4);
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .header-btn:hover {
      background: rgba(179, 136, 255, 0.2);
    }

    .header-btn.connected {
      border-color: #4CAF50;
      color: #4CAF50;
    }

    /* Quick Bar - Fear & Dice always visible */
    .quick-bar {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 10px 15px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      flex-shrink: 0;
    }

    .fear-compact {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .fear-label {
      font-size: 0.7rem;
      color: #888;
    }

    .fear-value {
      font-size: 1.5rem;
      font-weight: 900;
      color: #ffd700;
      min-width: 35px;
      text-align: center;
    }

    .fear-btns {
      display: flex;
      gap: 4px;
    }

    .fear-btn {
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    .fear-btn.add {
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      color: white;
    }

    .fear-btn.remove {
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
    }

    .fear-btn:hover { transform: scale(1.1); }

    .dice-compact {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
    }

    .dice-input {
      width: 100px;
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
    }

    .dice-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .roll-btn {
      padding: 6px 14px;
      border: none;
      border-radius: 4px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      font-weight: 700;
      cursor: pointer;
    }

    .roll-btn:hover { transform: scale(1.05); }

    .quick-dice-btns {
      display: flex;
      gap: 4px;
    }

    .qd-btn {
      padding: 4px 8px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: #aaa;
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      cursor: pointer;
    }

    .qd-btn:hover {
      background: rgba(179, 136, 255, 0.2);
      border-color: #b388ff;
      color: #e0e0e0;
    }

    .last-roll-display {
      padding: 4px 12px;
      background: rgba(0,0,0,0.4);
      border-radius: 4px;
      min-width: 60px;
      text-align: center;
    }

    .last-roll-result {
      font-size: 1.1rem;
      font-weight: 700;
      color: #ffd700;
    }

    /* Tab Navigation */
    .tab-nav {
      display: flex;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      flex-shrink: 0;
    }

    .tab-btn {
      flex: 1;
      padding: 10px 15px;
      border: none;
      background: transparent;
      color: #888;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: #e0e0e0;
      background: rgba(255,255,255,0.05);
    }

    .tab-btn.active {
      color: #ffd700;
      border-bottom-color: #ffd700;
      background: rgba(255,215,0,0.1);
    }

    /* Tab Content */
    .tab-content {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
    }

    .tab-panel {
      display: none;
      height: 100%;
    }

    .tab-panel.active {
      display: block;
    }

    /* Battle Tab */
    .battle-grid {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 15px;
      height: 100%;
    }

    .map-area {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    .map-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .map-header h3 {
      font-size: 0.9rem;
      color: #b388ff;
    }

    .map-controls {
      display: flex;
      gap: 8px;
    }

    .map-btn {
      padding: 5px 10px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: #e0e0e0;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .map-btn:hover {
      background: rgba(255,255,255,0.1);
    }

    .map-btn.active {
      background: rgba(179, 136, 255, 0.3);
      border-color: #b388ff;
    }

    .map-preview-area {
      flex: 1;
      background: rgba(0,0,0,0.4);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 200px;
      position: relative;
      overflow: hidden;
    }

    .map-preview-area img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .map-placeholder {
      color: #666;
      font-size: 0.85rem;
      text-align: center;
    }

    .token-area {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    .token-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .token-header h3 {
      font-size: 0.9rem;
      color: #b388ff;
    }

    .add-token-btn {
      padding: 4px 10px;
      border: 1px dashed rgba(76, 175, 80, 0.5);
      border-radius: 4px;
      background: transparent;
      color: #4CAF50;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .add-token-btn:hover {
      background: rgba(76, 175, 80, 0.1);
    }

    .token-list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .token-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      border-left: 3px solid #4CAF50;
    }

    .token-item.adversary {
      border-left-color: #f44336;
    }

    .token-item.hidden {
      opacity: 0.5;
    }

    .token-thumb {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      overflow: hidden;
    }

    .token-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .token-name {
      flex: 1;
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .token-actions {
      display: flex;
      gap: 4px;
    }

    .token-action-btn {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      color: #aaa;
      font-size: 0.7rem;
      cursor: pointer;
    }

    .token-action-btn:hover {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }

    .token-action-btn.visible-on {
      background: rgba(76, 175, 80, 0.3);
      color: #4CAF50;
    }

    /* Encounter Tab */
    .encounter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .encounter-title {
      font-size: 1rem;
      color: #ffd700;
    }

    .encounter-actions {
      display: flex;
      gap: 8px;
    }

    .encounter-btn {
      padding: 6px 12px;
      border: 1px solid rgba(255,136,0,0.5);
      border-radius: 4px;
      background: transparent;
      color: #ff9800;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .encounter-btn:hover {
      background: rgba(255,136,0,0.1);
    }

    .adversary-search {
      width: 100%;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      margin-bottom: 15px;
    }

    .adversary-search:focus {
      outline: none;
      border-color: #b388ff;
    }

    .adversary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 10px;
    }

    .adversary-card {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .adversary-card.spotlighted {
      border-color: #ffd700;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
    }

    .adv-header {
      display: flex;
      gap: 10px;
      margin-bottom: 8px;
    }

    .adv-portrait {
      width: 50px;
      height: 50px;
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      overflow: hidden;
      cursor: pointer;
      border: 2px solid rgba(255,255,255,0.1);
    }

    .adv-portrait:hover {
      border-color: #b388ff;
    }

    .adv-portrait img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .adv-info {
      flex: 1;
    }

    .adv-name {
      font-size: 0.9rem;
      font-weight: 700;
      margin-bottom: 2px;
    }

    .adv-tier {
      font-size: 0.7rem;
      color: #888;
    }

    .adv-actions {
      display: flex;
      gap: 4px;
    }

    .spotlight-btn {
      padding: 4px 10px;
      border: none;
      border-radius: 4px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-size: 0.7rem;
      font-weight: 700;
      cursor: pointer;
    }

    .spotlight-btn.active {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      color: #fff;
    }

    .adv-trackers {
      display: flex;
      gap: 10px;
      margin-bottom: 8px;
    }

    .tracker {
      flex: 1;
    }

    .tracker-label {
      font-size: 0.65rem;
      color: #888;
      margin-bottom: 3px;
    }

    .tracker-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .tracker-btn {
      width: 22px;
      height: 22px;
      border: none;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      color: #e0e0e0;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .tracker-btn:hover {
      background: rgba(255,255,255,0.2);
    }

    .tracker-value {
      flex: 1;
      text-align: center;
      font-size: 0.85rem;
      font-weight: 700;
    }

    .tracker-value.hp {
      color: #4CAF50;
    }

    .tracker-value.stress {
      color: #ff9800;
    }

    .tracker-value.low {
      color: #f44336;
    }

    .tracker-bar {
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      margin-top: 3px;
      overflow: hidden;
    }

    .tracker-fill {
      height: 100%;
      background: #4CAF50;
      transition: width 0.3s;
    }

    .tracker-fill.stress {
      background: #ff9800;
    }

    .adv-conditions {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .condition-badge {
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.65rem;
      cursor: pointer;
      background: rgba(255,255,255,0.1);
      color: #888;
      border: 1px solid transparent;
    }

    .condition-badge:hover {
      background: rgba(255,255,255,0.15);
    }

    .condition-badge.active {
      border-color: currentColor;
    }

    .condition-badge.hidden.active {
      background: rgba(158,158,158,0.3);
      color: #9e9e9e;
    }

    .condition-badge.restrained.active {
      background: rgba(33,150,243,0.3);
      color: #2196f3;
    }

    .condition-badge.vulnerable.active {
      background: rgba(244,67,54,0.3);
      color: #f44336;
    }

    .encounter-empty {
      text-align: center;
      color: #666;
      padding: 40px;
    }

    .hide-spotlight-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: rgba(255,68,68,0.8);
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      display: none;
      z-index: 100;
    }

    .hide-spotlight-btn.visible {
      display: block;
    }

    /* Settings Tab */
    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 15px;
    }

    .settings-section {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 15px;
    }

    .settings-section h3 {
      font-size: 0.9rem;
      color: #b388ff;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(179, 136, 255, 0.2);
    }

    .display-btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 10px;
    }

    .display-btn:hover {
      transform: scale(1.02);
    }

    .display-btn.player {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      color: white;
    }

    .display-btn.battlemap {
      background: linear-gradient(135deg, #1e88e5, #0d47a1);
      color: white;
    }

    .connection-info {
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      padding: 12px;
      margin-top: 10px;
    }

    .room-code-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .room-code-label {
      font-size: 0.75rem;
      color: #888;
    }

    .room-code-value {
      font-size: 1.1rem;
      font-weight: 700;
      color: #ffd700;
      letter-spacing: 2px;
    }

    .copy-btn {
      padding: 4px 10px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: #e0e0e0;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .copy-btn:hover {
      background: rgba(255,255,255,0.1);
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: #888;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #888;
    }

    .status-dot.connected {
      background: #4CAF50;
      box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
    }

    /* NPC Portrait Section */
    .npc-preview-small {
      width: 100%;
      height: 150px;
      background: rgba(0,0,0,0.4);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
      overflow: hidden;
    }

    .npc-preview-small img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .npc-controls {
      display: flex;
      gap: 8px;
    }

    .npc-btn {
      flex: 1;
      padding: 8px;
      border: 1px solid rgba(179, 136, 255, 0.4);
      border-radius: 4px;
      background: transparent;
      color: #b388ff;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .npc-btn:hover {
      background: rgba(179, 136, 255, 0.1);
    }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
      margin-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .toggle-label {
      font-size: 0.8rem;
    }

    .toggle-switch {
      position: relative;
      width: 44px;
      height: 22px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: #333;
      border-radius: 22px;
      transition: all 0.3s;
    }

    .toggle-slider::before {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      left: 2px;
      bottom: 2px;
      background: #888;
      border-radius: 50%;
      transition: all 0.3s;
    }

    .toggle-switch input:checked + .toggle-slider {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
    }

    .toggle-switch input:checked + .toggle-slider::before {
      transform: translateX(22px);
      background: #ffd700;
    }

    /* Autocomplete Dropdown */
    .autocomplete-container {
      position: relative;
    }

    .autocomplete-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      background: #2a2a3e;
      border: 1px solid #444;
      border-radius: 0 0 6px 6px;
      z-index: 1000;
      display: none;
    }

    .autocomplete-dropdown.visible {
      display: block;
    }

    .autocomplete-item {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.85rem;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
      background: rgba(179, 136, 255, 0.2);
    }

    .autocomplete-item small {
      color: #888;
      font-size: 0.7rem;
    }

    /* Token Positioning Modal */
    .positioning-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .positioning-modal.visible {
      display: flex;
    }

    .positioning-container {
      background: #1a1a2e;
      border-radius: 12px;
      max-width: 90vw;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .positioning-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      background: rgba(0,0,0,0.3);
    }

    .positioning-title {
      font-size: 0.9rem;
      color: #ffd700;
    }

    .positioning-close {
      background: none;
      border: none;
      color: #888;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .positioning-close:hover {
      color: #fff;
    }

    .positioning-map {
      position: relative;
      overflow: auto;
    }

    .positioning-map img {
      display: block;
      max-width: 80vw;
      max-height: 70vh;
    }

    .positioning-grid {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: auto;
      cursor: crosshair;
    }

    /* Image Dialog */
    .image-dialog-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .image-dialog-overlay.visible {
      display: flex;
    }

    .image-dialog {
      background: #1a1a2e;
      border-radius: 12px;
      padding: 20px;
      max-width: 400px;
      width: 90%;
    }

    .image-dialog h3 {
      margin-bottom: 15px;
      color: #ffd700;
    }

    .image-dialog-options {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 15px;
    }

    .image-dialog-btn {
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      color: #e0e0e0;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s;
    }

    .image-dialog-btn:hover {
      background: rgba(179, 136, 255, 0.1);
      border-color: #b388ff;
    }

    .url-input-section {
      display: none;
      margin-top: 15px;
    }

    .url-input-section.visible {
      display: block;
    }

    .url-input-section label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 5px;
    }

    .url-input-row {
      display: flex;
      gap: 8px;
    }

    .url-input-row input {
      flex: 1;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-size: 0.85rem;
    }

    .url-add-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background: #4CAF50;
      color: white;
      cursor: pointer;
    }

    .url-add-btn:disabled {
      background: #444;
      cursor: not-allowed;
    }

    .url-preview {
      margin-top: 10px;
      max-height: 100px;
      overflow: hidden;
      border-radius: 6px;
    }

    .url-preview img {
      max-width: 100%;
      max-height: 100px;
    }

    .image-dialog-cancel {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: transparent;
      color: #888;
      cursor: pointer;
    }

    /* Link to full version */
    .full-version-link {
      text-align: center;
      padding: 15px;
      border-top: 1px solid rgba(255,255,255,0.1);
      margin-top: 15px;
    }

    .full-version-link a {
      color: #888;
      font-size: 0.8rem;
      text-decoration: none;
    }

    .full-version-link a:hover {
      color: #b388ff;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.2);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.3);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .battle-grid {
        grid-template-columns: 1fr;
      }

      .quick-bar {
        flex-wrap: wrap;
      }

      .dice-compact {
        width: 100%;
        order: 1;
      }

      .quick-dice-btns {
        display: none;
      }
    }
  </style>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
</head>
<body>
  <!-- Header Bar -->
  <div class="header-bar">
    <div class="header-title">GM Control Panel</div>
    <div class="header-actions">
      <span id="connectionStatusText" style="font-size: 0.7rem; color: #888;">Initializing...</span>
      <button class="header-btn" id="connectionBtn" onclick="copyRoomCode()">Room: ----</button>
    </div>
  </div>

  <!-- Quick Bar - Always Visible -->
  <div class="quick-bar">
    <div class="fear-compact">
      <span class="fear-label">FEAR</span>
      <div class="fear-btns">
        <button class="fear-btn remove" onclick="adjustFear(-1)">-</button>
      </div>
      <div class="fear-value" id="fearDisplay">0</div>
      <div class="fear-btns">
        <button class="fear-btn add" onclick="adjustFear(1)">+</button>
      </div>
    </div>

    <div class="dice-compact">
      <input type="text" class="dice-input" id="diceNotation" placeholder="1d20+5" value="1d20">
      <button class="roll-btn" onclick="rollNotation()">Roll</button>
      <div class="quick-dice-btns">
        <button class="qd-btn" onclick="setNotation('1d20')">d20</button>
        <button class="qd-btn" onclick="setNotation('2d6')">2d6</button>
        <button class="qd-btn" onclick="setNotation('1d12')">d12</button>
        <button class="qd-btn" onclick="rollHopeFear()">H/F</button>
      </div>
      <div class="last-roll-display">
        <div class="last-roll-result" id="lastRoll">-</div>
      </div>
    </div>
  </div>

  <!-- Tab Navigation -->
  <div class="tab-nav">
    <button class="tab-btn active" onclick="switchTab('battle')">Battle</button>
    <button class="tab-btn" onclick="switchTab('encounter')">Encounter</button>
    <button class="tab-btn" onclick="switchTab('settings')">Settings</button>
  </div>

  <!-- Tab Content -->
  <div class="tab-content">
    <!-- Battle Tab -->
    <div class="tab-panel active" id="battleTab">
      <div class="battle-grid">
        <div class="map-area">
          <div class="map-header">
            <h3>Battle Map</h3>
            <div class="map-controls">
              <input type="file" id="mapImageInput" accept="image/*" style="display: none;" onchange="handleMapUpload(event)">
              <button class="map-btn" onclick="document.getElementById('mapImageInput').click()">Upload</button>
              <button class="map-btn" id="mapVisBtn" onclick="toggleMapVisibility()">Show</button>
              <button class="map-btn" id="gridBtn" onclick="toggleGrid()">Grid</button>
              <button class="map-btn" onclick="clearMap()">Clear</button>
            </div>
          </div>
          <div class="map-preview-area" id="mapPreviewArea">
            <img id="mapPreview" style="display: none;" alt="Map Preview">
            <div class="map-placeholder" id="mapPlaceholder">Click Upload to add a battle map</div>
          </div>
        </div>

        <div class="token-area">
          <div class="token-header">
            <h3>Tokens</h3>
            <button class="add-token-btn" onclick="addPlayerToken()">+ Player</button>
          </div>
          <div class="token-list" id="tokenList">
            <!-- Tokens rendered here -->
          </div>
        </div>
      </div>
    </div>

    <!-- Encounter Tab -->
    <div class="tab-panel" id="encounterTab">
      <div class="encounter-header">
        <div class="encounter-title" id="encounterTitle">No Encounter Loaded</div>
        <div class="encounter-actions">
          <input type="file" id="encounterFolderInput" webkitdirectory directory style="display: none;" onchange="handleEncounterFolderUpload(event)">
          <input type="file" id="encounterFileInput" accept=".json" style="display: none;" onchange="handleEncounterUpload(event)">
          <input type="file" id="adversaryImageInput" accept="image/*" style="display: none;" multiple onchange="handleAdversaryImageUpload(event)">
          <button class="encounter-btn" onclick="document.getElementById('encounterFolderInput').click()">Load Folder</button>
          <button class="encounter-btn" onclick="loadSampleEncounter()">Sample</button>
          <button class="encounter-btn" onclick="clearEncounter()">Clear</button>
        </div>
      </div>

      <div class="autocomplete-container">
        <input type="text"
               class="adversary-search"
               id="adversarySearchInput"
               placeholder="Search adversaries to add..."
               autocomplete="off">
        <div id="autocompleteDropdown" class="autocomplete-dropdown"></div>
      </div>

      <div id="encounterContainer">
        <div class="encounter-empty">
          No encounter loaded. Load a folder or use the search to add adversaries.
        </div>
      </div>

      <button class="hide-spotlight-btn" id="hideSpotlightBtn" onclick="hideSpotlight()">Hide Spotlight</button>
    </div>

    <!-- Settings Tab -->
    <div class="tab-panel" id="settingsTab">
      <div class="settings-grid">
        <div class="settings-section">
          <h3>Display Windows</h3>
          <button class="display-btn player" onclick="openPlayerDisplay()">Open Player Display</button>
          <button class="display-btn battlemap" onclick="openBattleMap()">Open Battle Map</button>

          <div class="connection-info">
            <div class="room-code-row">
              <span class="room-code-label">Room Code</span>
              <span class="room-code-value" id="roomCodeDisplay">----</span>
              <button class="copy-btn" onclick="copyRoomCode()">Copy</button>
            </div>
            <div class="connection-status">
              <div class="status-dot" id="connectionDot"></div>
              <span id="connectionText">Initializing...</span>
            </div>
          </div>
        </div>

        <div class="settings-section">
          <h3>NPC Portrait</h3>
          <div class="npc-preview-small" id="npcPreviewContainer">
            <img id="npcPreview" style="display: none;" alt="NPC Preview">
            <span id="npcPlaceholder" style="color: #666; font-size: 0.8rem;">No image</span>
          </div>
          <input type="file" id="npcImageInput" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
          <div class="npc-controls">
            <button class="npc-btn" onclick="document.getElementById('npcImageInput').click()">Upload</button>
            <button class="npc-btn" onclick="clearNpcImage()">Clear</button>
          </div>
          <div class="toggle-row">
            <span class="toggle-label">Show to Players</span>
            <label class="toggle-switch">
              <input type="checkbox" id="npcVisibilityToggle" onchange="toggleNpcVisibility()">
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>
      </div>

      <div class="full-version-link">
        <a href="gm-control-panel.html">Switch to Full GM Control Panel</a>
      </div>
    </div>
  </div>

  <!-- Token Positioning Modal -->
  <div id="positioningModal" class="positioning-modal" onclick="closePositioningModal(event)">
    <div class="positioning-container" onclick="event.stopPropagation()">
      <div class="positioning-header">
        <div class="positioning-title" id="positioningTitle">Position Token</div>
        <button class="positioning-close" onclick="closePositioningModal()">x</button>
      </div>
      <div class="positioning-map" id="positioningMapContainer">
        <img id="positioningMapImage" src="" alt="Map">
        <canvas id="positioningGrid" class="positioning-grid"></canvas>
      </div>
    </div>
  </div>

  <!-- Image Source Dialog -->
  <div id="imageSourceDialog" class="image-dialog-overlay" onclick="closeImageDialog(event)">
    <div class="image-dialog" onclick="event.stopPropagation()">
      <h3>Add Portrait Image</h3>
      <div class="image-dialog-options">
        <button class="image-dialog-btn" onclick="chooseFileUpload()">
          Upload from Computer
        </button>
        <button class="image-dialog-btn" onclick="showUrlInput()">
          Use Image URL
        </button>
      </div>
      <div id="urlInputSection" class="url-input-section">
        <label>Image URL:</label>
        <div class="url-input-row">
          <input type="url" id="imageUrlInput" placeholder="https://..." onkeyup="handleUrlKeyup(event)" oninput="previewUrlImage()">
          <button class="url-add-btn" id="urlAddBtn" onclick="addUrlPortrait()" disabled>Add</button>
        </div>
        <div id="urlPreview" class="url-preview"></div>
      </div>
      <button class="image-dialog-cancel" onclick="closeImageDialog()">Cancel</button>
    </div>
  </div>

  <!-- Player Token Image Upload -->
  <input type="file" id="playerTokenImageInput" accept="image/*" style="display: none;" onchange="handlePlayerTokenImageUpload(event)">

  <script>
    // ========== State ==========
    let currentFear = 0;
    let currentNpcImage = null;
    let npcVisible = false;
    let currentEncounter = null;
    let spotlightedAdversary = null;
    let pendingImageUploadAdversaryId = null;
    let currentMap = null;
    let mapVisible = false;
    let battleMapTokens = [];
    let gridVisible = false;
    let gridSize = 50;
    let nextPlayerTokenId = 1;
    let positioningTokenId = null;
    let pendingPlayerTokenImageId = null;
    let adversaryDatabase = [];
    let selectedAutocompleteIndex = -1;
    let peer = null;
    let playerConnection = null;
    let roomCode = null;

    // Default silhouette image
    const DEFAULT_NPC_IMAGE = `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
      <defs>
        <radialGradient id="shadowGlow" cx="50%" cy="50%" r="50%">
          <stop offset="0%" style="stop-color:#1a1a2e"/>
          <stop offset="70%" style="stop-color:#0d0d15"/>
          <stop offset="100%" style="stop-color:#050508"/>
        </radialGradient>
        <linearGradient id="silhouetteGrad" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" style="stop-color:#2d2d44"/>
          <stop offset="100%" style="stop-color:#15151f"/>
        </linearGradient>
      </defs>
      <rect width="200" height="200" fill="url(#shadowGlow)"/>
      <path d="M100 30 C75 30 60 50 60 75 C60 95 75 105 85 110 L75 115 C55 120 40 140 40 165 L40 190 L70 190 L75 150 L85 145 L90 190 L110 190 L115 145 L125 150 L130 190 L160 190 L160 165 C160 140 145 120 125 115 L115 110 C125 105 140 95 140 75 C140 50 125 30 100 30Z" fill="url(#silhouetteGrad)"/>
      <text x="100" y="120" font-family="Georgia, serif" font-size="48" font-weight="bold" fill="#6b5b95" text-anchor="middle" opacity="0.6">?</text>
    </svg>`)}`;

    function getDefaultImageForAdversary(adv) {
      return DEFAULT_NPC_IMAGE;
    }

    // ========== Tab Switching ==========
    function switchTab(tabName) {
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

      document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`).classList.add('active');
      document.getElementById(tabName + 'Tab').classList.add('active');
    }

    // ========== Fear Tracker ==========
    function adjustFear(amount) {
      currentFear = Math.max(0, currentFear + amount);
      updateFearDisplay();
      syncFear();
    }

    function resetFear() {
      currentFear = 0;
      updateFearDisplay();
      syncFear();
    }

    function updateFearDisplay() {
      document.getElementById('fearDisplay').textContent = currentFear;
      localStorage.setItem('daggerheart-fear', currentFear.toString());
    }

    function syncFear() {
      sendToPlayer({ type: 'fear', value: currentFear });
      localStorage.setItem('daggerheart-update', Date.now().toString());
    }

    // ========== Dice Roller ==========
    function setNotation(notation) {
      document.getElementById('diceNotation').value = notation;
    }

    function rollNotation() {
      const notation = document.getElementById('diceNotation').value.trim();
      if (!notation) return;

      const result = rollDice(notation);
      document.getElementById('lastRoll').textContent = result.total;

      const diceData = {
        notation: notation,
        total: result.total,
        breakdown: result.breakdown,
        timestamp: Date.now()
      };

      localStorage.setItem('daggerheart-dice', JSON.stringify(diceData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer({ type: 'dice', ...diceData });
    }

    function rollDice(notation) {
      const diceRegex = /(\d+)d(\d+)/gi;
      const modRegex = /[+-]\d+(?!d)/g;

      let total = 0;
      let breakdown = [];
      let match;

      while ((match = diceRegex.exec(notation)) !== null) {
        const numDice = parseInt(match[1]);
        const dieType = parseInt(match[2]);
        const rolls = [];

        for (let i = 0; i < numDice; i++) {
          const roll = Math.floor(Math.random() * dieType) + 1;
          rolls.push(roll);
          total += roll;
        }
        breakdown.push(`${numDice}d${dieType}: [${rolls.join(', ')}]`);
      }

      const modMatches = notation.match(modRegex);
      if (modMatches) {
        modMatches.forEach(mod => {
          const value = parseInt(mod);
          total += value;
          breakdown.push(`Modifier: ${value >= 0 ? '+' : ''}${value}`);
        });
      }

      return { total, breakdown };
    }

    function rollHopeFear() {
      const roll = Math.floor(Math.random() * 12) + 1;
      const roll2 = Math.floor(Math.random() * 12) + 1;
      const result = roll >= roll2 ? `Hope (${roll} vs ${roll2})` : `Fear (${roll} vs ${roll2})`;
      document.getElementById('lastRoll').textContent = roll >= roll2 ? 'HOPE' : 'FEAR';

      const diceData = {
        notation: 'Hope/Fear',
        total: result,
        breakdown: [`Hope: ${roll}`, `Fear: ${roll2}`],
        timestamp: Date.now()
      };

      localStorage.setItem('daggerheart-dice', JSON.stringify(diceData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer({ type: 'dice', ...diceData });
    }

    // ========== Battle Map ==========
    function handleMapUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        currentMap = {
          mapImage: e.target.result,
          gridSize: gridSize
        };

        document.getElementById('mapPreview').src = e.target.result;
        document.getElementById('mapPreview').style.display = 'block';
        document.getElementById('mapPlaceholder').style.display = 'none';

        syncBattleMap();
      };
      reader.readAsDataURL(file);
    }

    function toggleMapVisibility() {
      mapVisible = !mapVisible;
      const btn = document.getElementById('mapVisBtn');
      btn.classList.toggle('active', mapVisible);
      btn.textContent = mapVisible ? 'Hide' : 'Show';
      syncBattleMap();
    }

    function toggleGrid() {
      gridVisible = !gridVisible;
      document.getElementById('gridBtn').classList.toggle('active', gridVisible);
      syncBattleMap();
    }

    function clearMap() {
      currentMap = null;
      mapVisible = false;
      document.getElementById('mapPreview').style.display = 'none';
      document.getElementById('mapPlaceholder').style.display = 'block';
      document.getElementById('mapVisBtn').classList.remove('active');
      document.getElementById('mapVisBtn').textContent = 'Show';
      syncBattleMap();
    }

    function syncBattleMap() {
      const mapData = {
        type: 'mapSync',
        map: currentMap ? {
          type: 'map',
          visible: mapVisible,
          mapImage: mapVisible ? currentMap.mapImage : null,
          gridSize: currentMap.gridSize
        } : null,
        tokens: { type: 'tokens', tokens: battleMapTokens },
        grid: { type: 'grid', visible: gridVisible },
        timestamp: Date.now()
      };

      sendToBattleMap(mapData);

      localStorage.setItem('daggerheart-battle-map-state', JSON.stringify({
        visible: mapVisible,
        gridSize: gridSize
      }));
      localStorage.setItem('daggerheart-battle-tokens', JSON.stringify(battleMapTokens));
      localStorage.setItem('daggerheart-battle-grid', JSON.stringify({ visible: gridVisible }));
      localStorage.setItem('daggerheart-update', Date.now().toString());
    }

    // ========== Tokens ==========
    function addPlayerToken() {
      const name = prompt('Enter player name:');
      if (!name) return;

      const token = {
        id: 'player-' + nextPlayerTokenId++,
        name: name,
        type: 'player',
        x: 0,
        y: 0,
        image: null,
        conditions: { hidden: false, restrained: false, vulnerable: false },
        visible: true
      };

      battleMapTokens.push(token);
      renderTokenList();
      syncBattleMap();
    }

    function addAdversaryToken(adversary) {
      const existingToken = battleMapTokens.find(t => t.id === adversary.id);
      if (existingToken) return;

      const hasPortrait = adversary.portraits && adversary.portraits.length > 0;
      const token = {
        id: adversary.id,
        name: adversary.name,
        type: 'adversary',
        x: 0,
        y: 0,
        image: hasPortrait ? adversary.portraits[adversary.activePortraitIndex || 0] : getDefaultImageForAdversary(adversary),
        conditions: adversary.conditions || { hidden: false, restrained: false, vulnerable: false },
        visible: true
      };

      battleMapTokens.push(token);
      renderTokenList();
      syncBattleMap();
    }

    function removeToken(tokenId) {
      battleMapTokens = battleMapTokens.filter(t => t.id !== tokenId);
      renderTokenList();
      syncBattleMap();
    }

    function toggleTokenVisibility(tokenId) {
      const token = battleMapTokens.find(t => t.id === tokenId);
      if (token) {
        token.visible = !token.visible;
        renderTokenList();
        syncBattleMap();
      }
    }

    function openPositioningModal(tokenId) {
      if (!currentMap) {
        alert('Please upload a map first');
        return;
      }

      positioningTokenId = tokenId;
      const token = battleMapTokens.find(t => t.id === tokenId);

      document.getElementById('positioningTitle').textContent = `Position: ${token.name}`;
      document.getElementById('positioningMapImage').src = currentMap.mapImage;
      document.getElementById('positioningModal').classList.add('visible');

      setTimeout(() => {
        const img = document.getElementById('positioningMapImage');
        const canvas = document.getElementById('positioningGrid');
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        canvas.style.width = img.width + 'px';
        canvas.style.height = img.height + 'px';
        drawPositioningGrid();
      }, 100);
    }

    function drawPositioningGrid() {
      const canvas = document.getElementById('positioningGrid');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;

      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw current token position
      const token = battleMapTokens.find(t => t.id === positioningTokenId);
      if (token) {
        const x = token.x * gridSize + gridSize / 2;
        const y = token.y * gridSize + gridSize / 2;
        ctx.fillStyle = token.type === 'player' ? '#4CAF50' : '#f44336';
        ctx.beginPath();
        ctx.arc(x, y, gridSize / 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    document.getElementById('positioningGrid').addEventListener('click', (e) => {
      if (!positioningTokenId) return;

      const canvas = e.target;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      const x = Math.floor((e.clientX - rect.left) * scaleX / gridSize);
      const y = Math.floor((e.clientY - rect.top) * scaleY / gridSize);

      const token = battleMapTokens.find(t => t.id === positioningTokenId);
      if (token) {
        token.x = x;
        token.y = y;
        drawPositioningGrid();
        syncBattleMap();
      }
    });

    function closePositioningModal(event) {
      if (event && event.target !== document.getElementById('positioningModal')) return;
      document.getElementById('positioningModal').classList.remove('visible');
      positioningTokenId = null;
    }

    function renderTokenList() {
      const container = document.getElementById('tokenList');

      if (battleMapTokens.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px; font-size: 0.8rem;">No tokens. Add players or load an encounter.</div>';
        return;
      }

      container.innerHTML = battleMapTokens.map(token => `
        <div class="token-item ${token.type} ${token.visible ? '' : 'hidden'}">
          <div class="token-thumb" onclick="openPositioningModal('${token.id}')" title="Click to position">
            ${token.image ? `<img src="${token.image}" alt="${token.name}">` : ''}
          </div>
          <span class="token-name">${token.name}</span>
          <div class="token-actions">
            <button class="token-action-btn ${token.visible ? 'visible-on' : ''}" onclick="toggleTokenVisibility('${token.id}')" title="${token.visible ? 'Hide' : 'Show'}">
              ${token.visible ? 'üëÅ' : 'üëÅ‚Äçüó®'}
            </button>
            <button class="token-action-btn" onclick="removeToken('${token.id}')" title="Remove">‚úï</button>
          </div>
        </div>
      `).join('');
    }

    // ========== Encounters ==========
    function handleEncounterFolderUpload(event) {
      const files = Array.from(event.target.files);
      const jsonFile = files.find(f => f.name === 'encounter.json');

      if (!jsonFile) {
        alert('No encounter.json found in folder');
        return;
      }

      const imageFiles = files.filter(f => /\.(png|jpg|jpeg|gif|webp)$/i.test(f.name));
      const imageMap = {};

      let imagesLoaded = 0;
      const totalImages = imageFiles.length;

      const processEncounter = () => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            currentEncounter = {
              name: data.name || 'Encounter',
              adversaries: (data.adversaries || []).map(adv => ({
                ...adv,
                id: adv.id || 'adv-' + Math.random().toString(36).substr(2, 9),
                currentHp: adv.currentHp ?? adv.hp,
                currentStress: adv.currentStress ?? adv.stress,
                conditions: adv.conditions || { hidden: false, restrained: false, vulnerable: false },
                portraits: [],
                activePortraitIndex: 0
              }))
            };

            // Assign portraits from images
            currentEncounter.adversaries.forEach(adv => {
              if (adv.portrait && imageMap[adv.portrait]) {
                adv.portraits.push(imageMap[adv.portrait]);
              }
            });

            renderEncounter();
            saveEncounterState();

            // Add tokens for all adversaries
            currentEncounter.adversaries.forEach(adv => addAdversaryToken(adv));
          } catch (err) {
            alert('Error parsing encounter.json: ' + err.message);
          }
        };
        reader.readAsText(jsonFile);
      };

      if (totalImages === 0) {
        processEncounter();
      } else {
        imageFiles.forEach(file => {
          const imgReader = new FileReader();
          imgReader.onload = (e) => {
            imageMap[file.name] = e.target.result;
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              processEncounter();
            }
          };
          imgReader.readAsDataURL(file);
        });
      }
    }

    function handleEncounterUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          currentEncounter = {
            name: data.name || 'Encounter',
            adversaries: (data.adversaries || []).map(adv => ({
              ...adv,
              id: adv.id || 'adv-' + Math.random().toString(36).substr(2, 9),
              currentHp: adv.currentHp ?? adv.hp,
              currentStress: adv.currentStress ?? adv.stress,
              conditions: adv.conditions || { hidden: false, restrained: false, vulnerable: false },
              portraits: adv.portraits || [],
              activePortraitIndex: 0
            }))
          };

          renderEncounter();
          saveEncounterState();
          currentEncounter.adversaries.forEach(adv => addAdversaryToken(adv));
        } catch (err) {
          alert('Error parsing JSON: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    function loadSampleEncounter() {
      currentEncounter = {
        name: 'Sample Encounter',
        adversaries: [
          {
            id: 'sample-1',
            name: 'Skeleton Warrior',
            tier: 1,
            hp: 6,
            currentHp: 6,
            stress: 3,
            currentStress: 3,
            role: 'Minion',
            conditions: { hidden: false, restrained: false, vulnerable: false },
            portraits: [],
            activePortraitIndex: 0
          },
          {
            id: 'sample-2',
            name: 'Skeleton Archer',
            tier: 1,
            hp: 4,
            currentHp: 4,
            stress: 2,
            currentStress: 2,
            role: 'Minion',
            conditions: { hidden: false, restrained: false, vulnerable: false },
            portraits: [],
            activePortraitIndex: 0
          },
          {
            id: 'sample-3',
            name: 'Necromancer',
            tier: 2,
            hp: 15,
            currentHp: 15,
            stress: 8,
            currentStress: 8,
            role: 'Solo',
            conditions: { hidden: false, restrained: false, vulnerable: false },
            portraits: [],
            activePortraitIndex: 0
          }
        ]
      };

      renderEncounter();
      saveEncounterState();
      currentEncounter.adversaries.forEach(adv => addAdversaryToken(adv));
    }

    function clearEncounter() {
      // Remove adversary tokens
      if (currentEncounter) {
        currentEncounter.adversaries.forEach(adv => {
          battleMapTokens = battleMapTokens.filter(t => t.id !== adv.id);
        });
      }

      currentEncounter = null;
      spotlightedAdversary = null;
      renderEncounter();
      renderTokenList();
      syncBattleMap();

      localStorage.removeItem('daggerheart-encounter');
      localStorage.removeItem('daggerheart-spotlight');
      updateSpotlightUI();
    }

    function renderEncounter() {
      const container = document.getElementById('encounterContainer');
      const titleEl = document.getElementById('encounterTitle');

      if (!currentEncounter || currentEncounter.adversaries.length === 0) {
        titleEl.textContent = 'No Encounter Loaded';
        container.innerHTML = '<div class="encounter-empty">No encounter loaded. Load a folder or use the search to add adversaries.</div>';
        return;
      }

      titleEl.textContent = currentEncounter.name;

      container.innerHTML = `
        <div class="adversary-grid">
          ${currentEncounter.adversaries.map(adv => {
            const hpPercent = adv.hp ? (adv.currentHp / adv.hp) * 100 : 100;
            const stressPercent = adv.stress ? (adv.currentStress / adv.stress) * 100 : 100;
            const isSpotlighted = spotlightedAdversary === adv.id;
            const hasPortrait = adv.portraits && adv.portraits.length > 0;
            const portraitSrc = hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : getDefaultImageForAdversary(adv);

            return `
              <div class="adversary-card ${isSpotlighted ? 'spotlighted' : ''}">
                <div class="adv-header">
                  <div class="adv-portrait" onclick="openImageDialog('${adv.id}')">
                    <img src="${portraitSrc}" alt="${adv.name}">
                  </div>
                  <div class="adv-info">
                    <div class="adv-name">${adv.name}</div>
                    <div class="adv-tier">Tier ${adv.tier || 1} ${adv.role || ''}</div>
                  </div>
                  <div class="adv-actions">
                    <button class="spotlight-btn ${isSpotlighted ? 'active' : ''}" onclick="setSpotlight('${adv.id}')">
                      ${isSpotlighted ? 'On' : 'Show'}
                    </button>
                  </div>
                </div>

                <div class="adv-trackers">
                  <div class="tracker">
                    <div class="tracker-label">HP</div>
                    <div class="tracker-row">
                      <button class="tracker-btn" onclick="adjustHp('${adv.id}', -1)">-</button>
                      <span class="tracker-value hp ${adv.currentHp <= (adv.hp * 0.25) ? 'low' : ''}">${adv.currentHp}/${adv.hp}</span>
                      <button class="tracker-btn" onclick="adjustHp('${adv.id}', 1)">+</button>
                    </div>
                    <div class="tracker-bar"><div class="tracker-fill" style="width: ${hpPercent}%"></div></div>
                  </div>
                  <div class="tracker">
                    <div class="tracker-label">Stress</div>
                    <div class="tracker-row">
                      <button class="tracker-btn" onclick="adjustStress('${adv.id}', -1)">-</button>
                      <span class="tracker-value stress ${adv.currentStress <= (adv.stress * 0.25) ? 'low' : ''}">${adv.currentStress}/${adv.stress}</span>
                      <button class="tracker-btn" onclick="adjustStress('${adv.id}', 1)">+</button>
                    </div>
                    <div class="tracker-bar"><div class="tracker-fill stress" style="width: ${stressPercent}%"></div></div>
                  </div>
                </div>

                <div class="adv-conditions">
                  <span class="condition-badge hidden ${adv.conditions.hidden ? 'active' : ''}" onclick="toggleCondition('${adv.id}', 'hidden')">Hidden</span>
                  <span class="condition-badge restrained ${adv.conditions.restrained ? 'active' : ''}" onclick="toggleCondition('${adv.id}', 'restrained')">Restrained</span>
                  <span class="condition-badge vulnerable ${adv.conditions.vulnerable ? 'active' : ''}" onclick="toggleCondition('${adv.id}', 'vulnerable')">Vulnerable</span>
                </div>
              </div>
            `;
          }).join('')}
        </div>
      `;
    }

    function adjustHp(advId, amount) {
      const adv = currentEncounter?.adversaries.find(a => a.id === advId);
      if (!adv) return;

      adv.currentHp = Math.max(0, Math.min(adv.hp, adv.currentHp + amount));
      renderEncounter();
      saveEncounterState();

      if (spotlightedAdversary === advId) {
        syncSpotlight();
      }
    }

    function adjustStress(advId, amount) {
      const adv = currentEncounter?.adversaries.find(a => a.id === advId);
      if (!adv) return;

      adv.currentStress = Math.max(0, Math.min(adv.stress, adv.currentStress + amount));
      renderEncounter();
      saveEncounterState();
    }

    function toggleCondition(advId, condition) {
      const adv = currentEncounter?.adversaries.find(a => a.id === advId);
      if (!adv) return;

      adv.conditions[condition] = !adv.conditions[condition];
      renderEncounter();
      saveEncounterState();

      // Update token conditions
      const token = battleMapTokens.find(t => t.id === advId);
      if (token) {
        token.conditions = { ...adv.conditions };
        syncBattleMap();
      }

      if (spotlightedAdversary === advId) {
        syncSpotlight();
      }
    }

    function setSpotlight(advId) {
      if (spotlightedAdversary === advId) {
        hideSpotlight();
        return;
      }

      spotlightedAdversary = advId;
      renderEncounter();
      updateSpotlightUI();
      syncSpotlight();
    }

    function hideSpotlight() {
      spotlightedAdversary = null;
      renderEncounter();
      updateSpotlightUI();

      const spotlightData = { visible: false, timestamp: Date.now() };
      localStorage.setItem('daggerheart-spotlight', JSON.stringify(spotlightData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer({ type: 'spotlight', ...spotlightData });
    }

    function updateSpotlightUI() {
      const btn = document.getElementById('hideSpotlightBtn');
      btn.classList.toggle('visible', spotlightedAdversary !== null);
    }

    function syncSpotlight() {
      if (!spotlightedAdversary || !currentEncounter) return;

      const adv = currentEncounter.adversaries.find(a => a.id === spotlightedAdversary);
      if (!adv) return;

      const isDefeated = adv.hp !== undefined && adv.currentHp <= 0;
      const hasPortrait = adv.portraits && adv.portraits.length > 0;
      const imageToShow = hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : getDefaultImageForAdversary(adv);

      const spotlightData = {
        visible: true,
        adversaryId: adv.id,
        name: adv.name,
        image: imageToShow,
        isDefaultImage: !hasPortrait,
        defeated: isDefeated,
        conditions: adv.conditions || {},
        timestamp: Date.now()
      };

      localStorage.setItem('daggerheart-spotlight', JSON.stringify(spotlightData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer({ type: 'spotlight', ...spotlightData });
    }

    function saveEncounterState() {
      if (currentEncounter) {
        localStorage.setItem('daggerheart-encounter', JSON.stringify({ encounter: currentEncounter }));
      }
    }

    // ========== Adversary Search ==========
    const searchInput = document.getElementById('adversarySearchInput');
    const dropdown = document.getElementById('autocompleteDropdown');

    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim().toLowerCase();
      if (query.length < 2) {
        dropdown.classList.remove('visible');
        return;
      }

      const matches = adversaryDatabase.filter(adv =>
        adv.name.toLowerCase().includes(query) ||
        (adv.role && adv.role.toLowerCase().includes(query)) ||
        (adv.themes && adv.themes.some(t => t.toLowerCase().includes(query)))
      ).slice(0, 10);

      if (matches.length === 0) {
        dropdown.classList.remove('visible');
        return;
      }

      dropdown.innerHTML = matches.map((adv, i) => `
        <div class="autocomplete-item ${i === selectedAutocompleteIndex ? 'selected' : ''}"
             onclick="selectAutocompleteItem('${adv.name.replace(/'/g, "\\'")}')">
          ${adv.name}
          <small>T${adv.tier || 1} ${adv.role || ''}</small>
        </div>
      `).join('');

      dropdown.classList.add('visible');
    });

    searchInput.addEventListener('keydown', (e) => {
      const items = dropdown.querySelectorAll('.autocomplete-item');

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, items.length - 1);
        updateAutocompleteSelection();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, -1);
        updateAutocompleteSelection();
      } else if (e.key === 'Enter' && selectedAutocompleteIndex >= 0) {
        e.preventDefault();
        const item = items[selectedAutocompleteIndex];
        if (item) item.click();
      } else if (e.key === 'Escape') {
        dropdown.classList.remove('visible');
        selectedAutocompleteIndex = -1;
      }
    });

    function updateAutocompleteSelection() {
      const items = dropdown.querySelectorAll('.autocomplete-item');
      items.forEach((item, i) => {
        item.classList.toggle('selected', i === selectedAutocompleteIndex);
      });
    }

    function selectAutocompleteItem(name) {
      const adv = adversaryDatabase.find(a => a.name === name);
      if (!adv) return;

      if (!currentEncounter) {
        currentEncounter = { name: 'Custom Encounter', adversaries: [] };
      }

      const newAdv = {
        ...adv,
        id: 'adv-' + Math.random().toString(36).substr(2, 9),
        currentHp: adv.hp,
        currentStress: adv.stress,
        conditions: { hidden: false, restrained: false, vulnerable: false },
        portraits: [],
        activePortraitIndex: 0
      };

      currentEncounter.adversaries.push(newAdv);
      addAdversaryToken(newAdv);

      searchInput.value = '';
      dropdown.classList.remove('visible');
      selectedAutocompleteIndex = -1;

      renderEncounter();
      saveEncounterState();
    }

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.autocomplete-container')) {
        dropdown.classList.remove('visible');
        selectedAutocompleteIndex = -1;
      }
    });

    // ========== Image Dialog ==========
    function openImageDialog(advId) {
      pendingImageUploadAdversaryId = advId;
      document.getElementById('imageSourceDialog').classList.add('visible');
      document.getElementById('urlInputSection').classList.remove('visible');
      document.getElementById('imageUrlInput').value = '';
      document.getElementById('urlPreview').innerHTML = '';
    }

    function closeImageDialog(event) {
      if (event && event.target !== document.getElementById('imageSourceDialog')) return;
      document.getElementById('imageSourceDialog').classList.remove('visible');
      pendingImageUploadAdversaryId = null;
    }

    function chooseFileUpload() {
      document.getElementById('imageSourceDialog').classList.remove('visible');
      document.getElementById('adversaryImageInput').click();
    }

    function showUrlInput() {
      document.getElementById('urlInputSection').classList.add('visible');
    }

    function previewUrlImage() {
      const url = document.getElementById('imageUrlInput').value.trim();
      const preview = document.getElementById('urlPreview');
      const addBtn = document.getElementById('urlAddBtn');

      if (!url) {
        preview.innerHTML = '';
        addBtn.disabled = true;
        return;
      }

      preview.innerHTML = `<img src="${url}" alt="Preview" onerror="this.parentElement.innerHTML='Invalid URL'" onload="document.getElementById('urlAddBtn').disabled=false">`;
    }

    function handleUrlKeyup(event) {
      if (event.key === 'Enter') {
        addUrlPortrait();
      }
    }

    function addUrlPortrait() {
      const url = document.getElementById('imageUrlInput').value.trim();
      if (!url || !pendingImageUploadAdversaryId) return;

      const adv = currentEncounter?.adversaries.find(a => a.id === pendingImageUploadAdversaryId);
      if (adv) {
        if (!adv.portraits) adv.portraits = [];
        adv.portraits.push(url);
        adv.activePortraitIndex = adv.portraits.length - 1;

        // Update token image
        const token = battleMapTokens.find(t => t.id === adv.id);
        if (token) {
          token.image = url;
          syncBattleMap();
        }

        renderEncounter();
        saveEncounterState();

        if (spotlightedAdversary === adv.id) {
          syncSpotlight();
        }
      }

      closeImageDialog();
    }

    function handleAdversaryImageUpload(event) {
      const files = event.target.files;
      if (!files.length || !pendingImageUploadAdversaryId) return;

      const adv = currentEncounter?.adversaries.find(a => a.id === pendingImageUploadAdversaryId);
      if (!adv) return;

      Array.from(files).forEach(file => {
        const reader = new FileReader();
        reader.onload = (e) => {
          if (!adv.portraits) adv.portraits = [];
          adv.portraits.push(e.target.result);
          adv.activePortraitIndex = adv.portraits.length - 1;

          const token = battleMapTokens.find(t => t.id === adv.id);
          if (token) {
            token.image = e.target.result;
            syncBattleMap();
          }

          renderEncounter();
          saveEncounterState();

          if (spotlightedAdversary === adv.id) {
            syncSpotlight();
          }
        };
        reader.readAsDataURL(file);
      });

      pendingImageUploadAdversaryId = null;
    }

    // ========== NPC Portrait ==========
    function handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        currentNpcImage = e.target.result;
        updateNpcPreview();
        saveNpcState();
      };
      reader.readAsDataURL(file);
    }

    function clearNpcImage() {
      currentNpcImage = null;
      npcVisible = false;
      updateNpcPreview();
      saveNpcState();
    }

    function toggleNpcVisibility() {
      npcVisible = document.getElementById('npcVisibilityToggle').checked;
      saveNpcState();
    }

    function updateNpcPreview() {
      const preview = document.getElementById('npcPreview');
      const placeholder = document.getElementById('npcPlaceholder');
      const toggle = document.getElementById('npcVisibilityToggle');

      if (currentNpcImage) {
        preview.src = currentNpcImage;
        preview.style.display = 'block';
        placeholder.style.display = 'none';
        toggle.disabled = false;
      } else {
        preview.style.display = 'none';
        placeholder.style.display = 'block';
        toggle.disabled = true;
        toggle.checked = false;
      }
    }

    function saveNpcState() {
      const npcData = {
        image: currentNpcImage,
        visible: npcVisible
      };
      localStorage.setItem('daggerheart-npc', JSON.stringify(npcData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer({ type: 'npc', ...npcData });
    }

    // ========== Player Token Image ==========
    function handlePlayerTokenImageUpload(event) {
      const file = event.target.files[0];
      if (!file || !pendingPlayerTokenImageId) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const token = battleMapTokens.find(t => t.id === pendingPlayerTokenImageId);
        if (token) {
          token.image = e.target.result;
          renderTokenList();
          syncBattleMap();
        }
        pendingPlayerTokenImageId = null;
      };
      reader.readAsDataURL(file);
    }

    // ========== PeerJS Connection ==========
    function generateRoomCode() {
      const adjectives = ['RED', 'BLUE', 'GOLD', 'DARK', 'WILD', 'IRON', 'FIRE', 'FROST', 'STORM', 'SHADOW'];
      const nouns = ['WOLF', 'HAWK', 'BEAR', 'LION', 'RAVEN', 'DRAGON', 'SWORD', 'CROWN', 'FLAME', 'BLADE'];
      const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
      const noun = nouns[Math.floor(Math.random() * nouns.length)];
      const num = Math.floor(Math.random() * 100).toString().padStart(2, '0');
      return `${adj}-${noun}-${num}`;
    }

    function copyRoomCode() {
      if (roomCode) {
        navigator.clipboard.writeText(roomCode).then(() => {
          const btn = document.getElementById('connectionBtn');
          btn.textContent = 'Copied!';
          setTimeout(() => { btn.textContent = 'Room: ' + roomCode; }, 1500);
        });
      }
    }

    function initPeerHost() {
      roomCode = generateRoomCode();
      document.getElementById('roomCodeDisplay').textContent = roomCode;
      document.getElementById('connectionBtn').textContent = 'Room: ' + roomCode;

      const dot = document.getElementById('connectionDot');
      const text = document.getElementById('connectionText');
      const statusText = document.getElementById('connectionStatusText');

      peer = new Peer('dh-' + roomCode, {
        debug: 2,
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        }
      });

      peer.on('open', () => {
        text.textContent = 'Waiting for connection...';
        statusText.textContent = 'Ready';
      });

      peer.on('connection', (conn) => {
        conn.on('open', () => {
          playerConnection = conn;
          dot.classList.add('connected');
          text.textContent = 'Connected!';
          statusText.textContent = 'Connected';
          document.getElementById('connectionBtn').classList.add('connected');
          sendFullSync();
        });

        conn.on('data', (data) => {
          if (data && data.type === 'battleMapConnected') {
            syncBattleMap();
          }
        });

        conn.on('close', () => {
          playerConnection = null;
          dot.classList.remove('connected');
          text.textContent = 'Disconnected';
          statusText.textContent = 'Disconnected';
          document.getElementById('connectionBtn').classList.remove('connected');
        });
      });

      peer.on('error', (err) => {
        console.error('PeerJS error:', err);
        if (err.type === 'unavailable-id') {
          roomCode = generateRoomCode();
          document.getElementById('roomCodeDisplay').textContent = roomCode;
          document.getElementById('connectionBtn').textContent = 'Room: ' + roomCode;
          peer.destroy();
          setTimeout(initPeerHost, 1000);
        }
      });
    }

    function sendToPlayer(data) {
      if (playerConnection && playerConnection.open) {
        try {
          playerConnection.send(data);
        } catch (e) {
          console.error('Failed to send:', e);
        }
      }
    }

    function sendToBattleMap(data) {
      sendToPlayer(data);
    }

    function sendFullSync() {
      if (!playerConnection || !playerConnection.open) return;

      const syncData = {
        type: 'sync',
        fear: currentFear,
        spotlight: null
      };

      if (spotlightedAdversary && currentEncounter) {
        const adv = currentEncounter.adversaries.find(a => a.id === spotlightedAdversary);
        if (adv) {
          const isDefeated = adv.hp !== undefined && adv.currentHp <= 0;
          const hasPortrait = adv.portraits && adv.portraits.length > 0;

          syncData.spotlight = {
            visible: true,
            adversaryId: adv.id,
            name: adv.name,
            image: hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : getDefaultImageForAdversary(adv),
            isDefaultImage: !hasPortrait,
            defeated: isDefeated,
            conditions: adv.conditions || {},
            timestamp: Date.now()
          };
        }
      }

      sendToPlayer(syncData);
      syncBattleMap();
    }

    // ========== Display Windows ==========
    function openPlayerDisplay() {
      const width = 1200;
      const height = 800;
      const left = (screen.width - width) / 2;
      const top = (screen.height - height) / 2;
      window.open('player-display.html', 'PlayerDisplay', `width=${width},height=${height},left=${left},top=${top}`);
    }

    function openBattleMap() {
      const width = 1200;
      const height = 800;
      const left = (screen.width - width) / 2;
      const top = (screen.height - height) / 2;
      window.open('battle-map.html', 'BattleMap', `width=${width},height=${height},left=${left},top=${top}`);
    }

    // ========== Adversary Database ==========
    function loadAdversaryDatabase() {
      // Embedded adversary data (subset for the simplified panel)
      adversaryDatabase = [
        { name: 'Skeleton Warrior', tier: 1, role: 'Minion', hp: 6, stress: 3, themes: ['Undead'] },
        { name: 'Skeleton Archer', tier: 1, role: 'Minion', hp: 4, stress: 2, themes: ['Undead'] },
        { name: 'Zombie', tier: 1, role: 'Minion', hp: 8, stress: 2, themes: ['Undead'] },
        { name: 'Ghost', tier: 2, role: 'Standard', hp: 12, stress: 6, themes: ['Undead', 'Spirit'] },
        { name: 'Goblin Scout', tier: 1, role: 'Minion', hp: 4, stress: 2, themes: ['Goblinoid'] },
        { name: 'Goblin Warrior', tier: 1, role: 'Minion', hp: 6, stress: 3, themes: ['Goblinoid'] },
        { name: 'Hobgoblin', tier: 2, role: 'Standard', hp: 15, stress: 6, themes: ['Goblinoid'] },
        { name: 'Orc Berserker', tier: 2, role: 'Standard', hp: 18, stress: 8, themes: ['Orc'] },
        { name: 'Wolf', tier: 1, role: 'Minion', hp: 6, stress: 3, themes: ['Beast'] },
        { name: 'Dire Wolf', tier: 2, role: 'Standard', hp: 14, stress: 6, themes: ['Beast'] },
        { name: 'Bear', tier: 2, role: 'Standard', hp: 20, stress: 8, themes: ['Beast'] },
        { name: 'Giant Spider', tier: 2, role: 'Standard', hp: 12, stress: 5, themes: ['Beast', 'Vermin'] },
        { name: 'Bandit', tier: 1, role: 'Minion', hp: 5, stress: 3, themes: ['Humanoid'] },
        { name: 'Bandit Captain', tier: 2, role: 'Leader', hp: 16, stress: 7, themes: ['Humanoid'] },
        { name: 'Cultist', tier: 1, role: 'Minion', hp: 4, stress: 4, themes: ['Humanoid', 'Cult'] },
        { name: 'Cult Fanatic', tier: 2, role: 'Standard', hp: 12, stress: 8, themes: ['Humanoid', 'Cult'] },
        { name: 'Necromancer', tier: 2, role: 'Solo', hp: 15, stress: 10, themes: ['Humanoid', 'Undead'] },
        { name: 'Young Dragon', tier: 3, role: 'Solo', hp: 40, stress: 15, themes: ['Dragon'] },
        { name: 'Troll', tier: 3, role: 'Standard', hp: 35, stress: 10, themes: ['Giant'] },
        { name: 'Ogre', tier: 2, role: 'Standard', hp: 25, stress: 8, themes: ['Giant'] },
        { name: 'Wraith', tier: 3, role: 'Standard', hp: 20, stress: 12, themes: ['Undead', 'Spirit'] },
        { name: 'Vampire Spawn', tier: 2, role: 'Standard', hp: 18, stress: 8, themes: ['Undead', 'Vampire'] },
        { name: 'Elemental', tier: 2, role: 'Standard', hp: 16, stress: 6, themes: ['Elemental'] },
        { name: 'Demon', tier: 3, role: 'Standard', hp: 30, stress: 12, themes: ['Fiend'] },
        { name: 'Devil', tier: 3, role: 'Standard', hp: 28, stress: 14, themes: ['Fiend'] }
      ];
    }

    // ========== Initialize ==========
    function init() {
      // Load fear
      const storedFear = localStorage.getItem('daggerheart-fear');
      if (storedFear) {
        currentFear = parseInt(storedFear) || 0;
        updateFearDisplay();
      }

      // Load NPC
      const npcData = localStorage.getItem('daggerheart-npc');
      if (npcData) {
        const parsed = JSON.parse(npcData);
        currentNpcImage = parsed.image;
        npcVisible = parsed.visible || false;
        updateNpcPreview();
        document.getElementById('npcVisibilityToggle').checked = npcVisible;
      }

      // Load encounter
      const encounterData = localStorage.getItem('daggerheart-encounter');
      if (encounterData) {
        const parsed = JSON.parse(encounterData);
        currentEncounter = parsed.encounter;
        renderEncounter();
      }

      // Load spotlight
      const spotlightData = localStorage.getItem('daggerheart-spotlight');
      if (spotlightData) {
        const parsed = JSON.parse(spotlightData);
        if (parsed.visible && parsed.adversaryId && currentEncounter) {
          spotlightedAdversary = parsed.adversaryId;
          updateSpotlightUI();
        }
      }

      // Load tokens
      const tokensData = localStorage.getItem('daggerheart-battle-tokens');
      if (tokensData) {
        battleMapTokens = JSON.parse(tokensData);
        renderTokenList();
      }

      // Load adversary database
      loadAdversaryDatabase();

      // Initialize PeerJS
      initPeerHost();

      // Render initial state
      renderTokenList();
    }

    // Start
    init();
  </script>
</body>
</html>
