<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GM Control Panel - Streamlined</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Cinzel', serif;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
    }

    /* Header Bar - Always visible */
    .header-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 15px;
      background: rgba(0,0,0,0.4);
      border-bottom: 1px solid rgba(179, 136, 255, 0.3);
      flex-shrink: 0;
    }

    .header-title {
      font-size: 1rem;
      background: linear-gradient(180deg, #ffd700, #b8860b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .header-btn {
      padding: 6px 12px;
      border: 1px solid rgba(179, 136, 255, 0.4);
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .header-btn:hover {
      background: rgba(179, 136, 255, 0.2);
    }

    .header-btn.connected {
      border-color: #4CAF50;
      color: #4CAF50;
    }

    /* Quick Bar - Fear & Dice always visible */
    .quick-bar {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 10px 15px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      flex-shrink: 0;
    }

    .fear-compact {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .fear-label {
      font-size: 0.7rem;
      color: #888;
    }

    .fear-value {
      font-size: 1.5rem;
      font-weight: 900;
      color: #ffd700;
      min-width: 35px;
      text-align: center;
    }

    .fear-btns {
      display: flex;
      gap: 4px;
    }

    .fear-btn {
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    .fear-btn.add {
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      color: white;
    }

    .fear-btn.remove {
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
    }

    .fear-btn:hover { transform: scale(1.1); }

    .dice-compact {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
    }

    .dice-input {
      width: 100px;
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
    }

    .dice-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .roll-btn {
      padding: 6px 14px;
      border: none;
      border-radius: 4px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      font-weight: 700;
      cursor: pointer;
    }

    .roll-btn:hover { transform: scale(1.05); }

    .quick-dice-btns {
      display: flex;
      gap: 4px;
    }

    .qd-btn {
      padding: 4px 8px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: #aaa;
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      cursor: pointer;
    }

    .qd-btn:hover {
      background: rgba(179, 136, 255, 0.2);
      border-color: #b388ff;
      color: #e0e0e0;
    }

    .last-roll-display {
      padding: 4px 12px;
      background: rgba(0,0,0,0.4);
      border-radius: 4px;
      min-width: 60px;
      text-align: center;
    }

    .last-roll-result {
      font-size: 1.1rem;
      font-weight: 700;
      color: #ffd700;
    }

    /* Tab Navigation */
    .tab-nav {
      display: flex;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      flex-shrink: 0;
    }

    .tab-btn {
      flex: 1;
      padding: 10px 15px;
      border: none;
      background: transparent;
      color: #888;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: #e0e0e0;
      background: rgba(255,255,255,0.05);
    }

    .tab-btn.active {
      color: #ffd700;
      border-bottom-color: #ffd700;
      background: rgba(255,215,0,0.1);
    }

    .tab-badge {
      display: inline-block;
      min-width: 18px;
      height: 18px;
      padding: 0 5px;
      margin-left: 5px;
      background: rgba(255,255,255,0.2);
      border-radius: 9px;
      font-size: 0.7rem;
      line-height: 18px;
      text-align: center;
    }

    .tab-btn.active .tab-badge {
      background: rgba(255,215,0,0.3);
    }

    .tab-badge.updated {
      background: #4CAF50;
      color: white;
      animation: badge-pulse 0.5s ease;
    }

    @keyframes badge-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }

    /* Tab Content */
    .tab-content {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
    }

    .tab-panel {
      display: none;
      height: 100%;
    }

    .tab-panel.active {
      display: block;
    }

    /* Battle Tab */
    .battle-grid {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 15px;
      height: 100%;
    }

    .map-area {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    .map-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .map-header h3 {
      font-size: 0.9rem;
      color: #b388ff;
    }

    .map-controls {
      display: flex;
      gap: 8px;
    }

    .map-btn {
      padding: 5px 10px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: #e0e0e0;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .map-btn:hover {
      background: rgba(255,255,255,0.1);
    }

    .map-btn.active {
      background: rgba(179, 136, 255, 0.3);
      border-color: #b388ff;
    }

    .map-preview-area {
      flex: 1;
      background: rgba(0,0,0,0.4);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 200px;
      position: relative;
      overflow: hidden;
    }

    .map-preview-area img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .map-placeholder {
      color: #666;
      font-size: 0.85rem;
      text-align: center;
    }

    .map-preview-wrapper {
      position: relative;
      display: inline-block;
      max-width: 100%;
      max-height: 100%;
    }

    .map-preview-grid {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .map-preview-token-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .map-preview-token {
      position: absolute;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid #4CAF50;
      background-size: cover;
      background-position: center;
      cursor: pointer;
      pointer-events: auto;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      transform: translate(-50%, -50%);
      z-index: 10;
    }

    .map-preview-token.adversary {
      border-color: #f44336;
    }

    .map-preview-token:hover {
      transform: translate(-50%, -50%) scale(1.15);
      z-index: 20;
    }

    .map-preview-token.selected {
      box-shadow: 0 0 0 3px rgba(179, 136, 255, 0.8), 0 0 12px rgba(179, 136, 255, 0.6);
      z-index: 30;
    }

    .map-preview-token .token-label {
      position: absolute;
      bottom: -16px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 9px;
      color: #fff;
      background: rgba(0,0,0,0.7);
      padding: 1px 4px;
      border-radius: 3px;
      white-space: nowrap;
      max-width: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .map-preview-token .token-conditions-mini {
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      gap: 1px;
    }

    .map-preview-token .condition-mini {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      font-size: 7px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
    }

    .map-preview-token .condition-mini.hidden-cond {
      background: linear-gradient(135deg, #666, #444);
    }

    .map-preview-token .condition-mini.restrained-cond {
      background: linear-gradient(135deg, #2196F3, #1565C0);
    }

    .map-preview-token .condition-mini.vulnerable-cond {
      background: linear-gradient(135deg, #f44336, #c62828);
    }

    .position-mode-indicator {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(179, 136, 255, 0.9);
      color: #fff;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .cancel-position-btn {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .cancel-position-btn:hover {
      background: rgba(255,255,255,0.3);
    }

    .map-preview-area.positioning-active {
      cursor: crosshair;
    }

    .map-preview-area.positioning-active .map-preview-token-layer {
      pointer-events: auto;
    }

    .token-area {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    .token-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .token-header h3 {
      font-size: 0.9rem;
      color: #b388ff;
    }

    .add-token-btn {
      padding: 4px 10px;
      border: 1px dashed rgba(76, 175, 80, 0.5);
      border-radius: 4px;
      background: transparent;
      color: #4CAF50;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .add-token-btn:hover {
      background: rgba(76, 175, 80, 0.1);
    }

    .token-list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .token-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      border-left: 3px solid #4CAF50;
    }

    .token-item.adversary {
      border-left-color: #f44336;
    }

    .token-item.hidden {
      opacity: 0.5;
    }

    .token-thumb {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      overflow: hidden;
    }

    .token-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .token-name {
      flex: 1;
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .token-actions {
      display: flex;
      gap: 4px;
    }

    .token-action-btn {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      color: #aaa;
      font-size: 0.7rem;
      cursor: pointer;
    }

    .token-action-btn:hover {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }

    .token-action-btn.visible-on {
      background: rgba(76, 175, 80, 0.3);
      color: #4CAF50;
    }

    /* Token control buttons for battlemap section */
    .token-controls {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,0.1);
      width: 100%;
    }

    .token-controls-row {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .token-spotlight-btn {
      padding: 3px 8px;
      border: none;
      border-radius: 3px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-family: 'Cinzel', serif;
      font-size: 0.6rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .token-spotlight-btn:hover {
      transform: scale(1.05);
    }

    .token-spotlight-btn.active {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      color: #fff;
    }

    .token-condition-btn {
      padding: 2px 6px;
      border: 1px solid;
      border-radius: 3px;
      background: transparent;
      font-family: 'Cinzel', serif;
      font-size: 0.55rem;
      font-weight: 700;
      cursor: pointer;
      text-transform: uppercase;
    }

    .token-condition-btn.hidden-btn {
      border-color: rgba(106, 90, 205, 0.4);
      color: #9370db;
    }

    .token-condition-btn.hidden-btn.active {
      background: rgba(106, 90, 205, 0.3);
      border-color: #9370db;
    }

    .token-condition-btn.restrained-btn {
      border-color: rgba(112, 128, 144, 0.4);
      color: #b0c4de;
    }

    .token-condition-btn.restrained-btn.active {
      background: rgba(112, 128, 144, 0.3);
      border-color: #b0c4de;
    }

    .token-condition-btn.vulnerable-btn {
      border-color: rgba(218, 165, 32, 0.4);
      color: #ffd700;
    }

    .token-condition-btn.vulnerable-btn.active {
      background: rgba(218, 165, 32, 0.3);
      border-color: #ffd700;
    }

    .token-hp-tracker {
      display: flex;
      align-items: center;
      gap: 4px;
      background: rgba(0,0,0,0.3);
      padding: 2px 6px;
      border-radius: 3px;
    }

    .token-hp-label {
      font-size: 0.55rem;
      color: #ff6b6b;
      text-transform: uppercase;
    }

    .token-hp-btn {
      width: 16px;
      height: 16px;
      border: none;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      color: #ccc;
      font-size: 0.75rem;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .token-hp-btn.minus:hover {
      background: rgba(255,68,68,0.3);
      color: #ff6b6b;
    }

    .token-hp-btn.plus:hover {
      background: rgba(102,187,106,0.3);
      color: #66bb6a;
    }

    .token-hp-value {
      font-size: 0.7rem;
      font-weight: 700;
      color: #ff6b6b;
      min-width: 35px;
      text-align: center;
    }

    .token-hp-value.critical {
      color: #ff4444;
      animation: pulse 1s infinite;
    }

    .token-hp-value.defeated {
      color: #666;
      text-decoration: line-through;
    }

    .token-item.spotlighted {
      border-color: #ffd700;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
    }

    /* Encounter Tab */
    .encounter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .encounter-title {
      font-size: 1rem;
      color: #ffd700;
    }

    .encounter-actions {
      display: flex;
      gap: 8px;
    }

    .encounter-btn {
      padding: 6px 12px;
      border: 1px solid rgba(255,136,0,0.5);
      border-radius: 4px;
      background: transparent;
      color: #ff9800;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .encounter-btn:hover {
      background: rgba(255,136,0,0.1);
    }

    .adversary-search {
      width: 100%;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      margin-bottom: 15px;
    }

    .adversary-search:focus {
      outline: none;
      border-color: #b388ff;
    }

    .adversary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 10px;
    }

    .adversary-card {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .adversary-card.spotlighted {
      border-color: #ffd700;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
    }

    .adv-header {
      display: flex;
      gap: 10px;
      margin-bottom: 8px;
    }

    .adv-portrait {
      width: 50px;
      height: 50px;
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      overflow: hidden;
      cursor: pointer;
      border: 2px solid rgba(255,255,255,0.1);
    }

    .adv-portrait:hover {
      border-color: #b388ff;
    }

    .adv-portrait img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .adv-info {
      flex: 1;
    }

    .adv-name {
      font-size: 0.9rem;
      font-weight: 700;
      margin-bottom: 2px;
    }

    .adv-tier {
      font-size: 0.7rem;
      color: #888;
    }

    .adv-actions {
      display: flex;
      gap: 4px;
    }

    .spotlight-btn {
      padding: 4px 10px;
      border: none;
      border-radius: 4px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-size: 0.7rem;
      font-weight: 700;
      cursor: pointer;
    }

    .spotlight-btn.active {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      color: #fff;
    }

    .adv-trackers {
      display: flex;
      gap: 10px;
      margin-bottom: 8px;
    }

    .tracker {
      flex: 1;
    }

    .tracker-label {
      font-size: 0.65rem;
      color: #888;
      margin-bottom: 3px;
    }

    .tracker-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .tracker-btn {
      width: 22px;
      height: 22px;
      border: none;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      color: #e0e0e0;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .tracker-btn:hover {
      background: rgba(255,255,255,0.2);
    }

    .tracker-value {
      flex: 1;
      text-align: center;
      font-size: 0.85rem;
      font-weight: 700;
    }

    .tracker-value.hp {
      color: #4CAF50;
    }

    .tracker-value.stress {
      color: #ff9800;
    }

    .tracker-value.low {
      color: #f44336;
    }

    .tracker-bar {
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      margin-top: 3px;
      overflow: hidden;
    }

    .tracker-fill {
      height: 100%;
      background: #4CAF50;
      transition: width 0.3s;
    }

    .tracker-fill.stress {
      background: #ff9800;
    }

    .adv-conditions {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .condition-badge {
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.65rem;
      cursor: pointer;
      background: rgba(255,255,255,0.1);
      color: #888;
      border: 1px solid transparent;
    }

    .condition-badge:hover {
      background: rgba(255,255,255,0.15);
    }

    .condition-badge.active {
      border-color: currentColor;
    }

    .condition-badge.hidden.active {
      background: rgba(158,158,158,0.3);
      color: #9e9e9e;
    }

    .condition-badge.restrained.active {
      background: rgba(33,150,243,0.3);
      color: #2196f3;
    }

    .condition-badge.vulnerable.active {
      background: rgba(244,67,54,0.3);
      color: #f44336;
    }

    /* Stat Block Styles */
    .adv-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      margin: 8px 0;
      padding: 8px;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-label {
      font-size: 0.6rem;
      color: #888;
      text-transform: uppercase;
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 0.85rem;
      font-weight: 700;
      color: #e0e0e0;
    }

    .stat-value.attack {
      color: #ef5350;
    }

    .stat-value.defense {
      color: #42a5f5;
    }

    .adv-thresholds {
      display: flex;
      gap: 8px;
      margin: 8px 0;
    }

    .threshold {
      flex: 1;
      padding: 6px;
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
      text-align: center;
    }

    .threshold-label {
      font-size: 0.6rem;
      color: #888;
      text-transform: uppercase;
    }

    .threshold-value {
      font-size: 0.9rem;
      font-weight: 700;
    }

    .threshold.major .threshold-value {
      color: #ffa726;
    }

    .threshold.severe .threshold-value {
      color: #ef5350;
    }

    .adv-traits {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin: 8px 0;
    }

    .trait-tag {
      padding: 2px 8px;
      background: rgba(124, 77, 255, 0.2);
      border: 1px solid rgba(124, 77, 255, 0.4);
      border-radius: 12px;
      font-size: 0.65rem;
      color: #b388ff;
    }

    .adv-abilities {
      margin: 8px 0;
      padding: 8px;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
    }

    .abilities-header {
      font-size: 0.65rem;
      color: #888;
      text-transform: uppercase;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 4px;
    }

    .ability-item {
      font-size: 0.75rem;
      color: #ccc;
      margin-bottom: 6px;
      padding-left: 8px;
      border-left: 2px solid rgba(124, 77, 255, 0.4);
    }

    .ability-item:last-child {
      margin-bottom: 0;
    }

    .ability-name {
      color: #b388ff;
      font-weight: 600;
    }

    .encounter-empty {
      text-align: center;
      color: #666;
      padding: 40px;
    }

    .hide-spotlight-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: rgba(255,68,68,0.8);
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      display: none;
      z-index: 100;
    }

    .hide-spotlight-btn.visible {
      display: block;
    }

    /* Settings Tab */
    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 15px;
    }

    .settings-section {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 15px;
    }

    .settings-section h3 {
      font-size: 0.9rem;
      color: #b388ff;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(179, 136, 255, 0.2);
    }

    .display-btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 10px;
    }

    .display-btn:hover {
      transform: scale(1.02);
    }

    .display-btn.player {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      color: white;
    }

    .display-btn.battlemap {
      background: linear-gradient(135deg, #1e88e5, #0d47a1);
      color: white;
    }

    .connection-info {
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      padding: 12px;
      margin-top: 10px;
    }

    .room-code-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .room-code-label {
      font-size: 0.75rem;
      color: #888;
    }

    .room-code-value {
      font-size: 1.1rem;
      font-weight: 700;
      color: #ffd700;
      letter-spacing: 2px;
    }

    .copy-btn {
      padding: 4px 10px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: #e0e0e0;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .copy-btn:hover {
      background: rgba(255,255,255,0.1);
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: #888;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #888;
    }

    .status-dot.connected {
      background: #4CAF50;
      box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
    }

    /* NPC Portrait Section */
    .npc-preview-small {
      width: 100%;
      height: 150px;
      background: rgba(0,0,0,0.4);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
      overflow: hidden;
    }

    .npc-preview-small img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .npc-controls {
      display: flex;
      gap: 8px;
    }

    .npc-btn {
      flex: 1;
      padding: 8px;
      border: 1px solid rgba(179, 136, 255, 0.4);
      border-radius: 4px;
      background: transparent;
      color: #b388ff;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .npc-btn:hover {
      background: rgba(179, 136, 255, 0.1);
    }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
      margin-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .toggle-label {
      font-size: 0.8rem;
    }

    .toggle-switch {
      position: relative;
      width: 44px;
      height: 22px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: #333;
      border-radius: 22px;
      transition: all 0.3s;
    }

    .toggle-slider::before {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      left: 2px;
      bottom: 2px;
      background: #888;
      border-radius: 50%;
      transition: all 0.3s;
    }

    .toggle-switch input:checked + .toggle-slider {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
    }

    .toggle-switch input:checked + .toggle-slider::before {
      transform: translateX(22px);
      background: #ffd700;
    }

    /* Reference Tab */
    .reference-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 10px;
    }

    .reference-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px 15px;
      flex-shrink: 0;
    }

    .reference-header h3 {
      font-size: 0.9rem;
      color: #b388ff;
      margin: 0;
    }

    .reference-controls {
      display: flex;
      gap: 8px;
    }

    .reference-btn {
      padding: 6px 12px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: rgba(179, 136, 255, 0.2);
      color: #e0e0e0;
      font-size: 0.8rem;
      font-family: 'Cinzel', serif;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .reference-btn:hover {
      background: rgba(179, 136, 255, 0.4);
      transform: scale(1.02);
    }

    .reference-pdf-wrapper {
      flex: 1;
      min-height: 0;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      overflow: hidden;
    }

    .reference-pdf-frame {
      width: 100%;
      height: 100%;
      border: none;
      background: #fff;
    }

    /* Autocomplete Dropdown */
    .autocomplete-container {
      position: relative;
    }

    .autocomplete-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      background: #2a2a3e;
      border: 1px solid #444;
      border-radius: 0 0 6px 6px;
      z-index: 1000;
      display: none;
    }

    .autocomplete-dropdown.visible {
      display: block;
    }

    .autocomplete-item {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.85rem;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
      background: rgba(179, 136, 255, 0.2);
    }

    .autocomplete-item small {
      color: #888;
      font-size: 0.7rem;
    }

    /* Token Positioning Modal */
    .positioning-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .positioning-modal.visible {
      display: flex;
    }

    .positioning-container {
      background: #1a1a2e;
      border-radius: 12px;
      max-width: 90vw;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .positioning-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      background: rgba(0,0,0,0.3);
    }

    .positioning-title {
      font-size: 0.9rem;
      color: #ffd700;
    }

    .positioning-close {
      background: none;
      border: none;
      color: #888;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .positioning-close:hover {
      color: #fff;
    }

    .positioning-map {
      position: relative;
      overflow: auto;
    }

    .positioning-map img {
      display: block;
      max-width: 80vw;
      max-height: 70vh;
    }

    .positioning-grid {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: auto;
      cursor: crosshair;
    }

    /* Image Dialog */
    .image-dialog-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .image-dialog-overlay.visible {
      display: flex;
    }

    .image-dialog {
      background: #1a1a2e;
      border-radius: 12px;
      padding: 20px;
      max-width: 400px;
      width: 90%;
    }

    .image-dialog h3 {
      margin-bottom: 15px;
      color: #ffd700;
    }

    .image-dialog-options {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 15px;
    }

    .image-dialog-btn {
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      color: #e0e0e0;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s;
    }

    .image-dialog-btn:hover {
      background: rgba(179, 136, 255, 0.1);
      border-color: #b388ff;
    }

    .url-input-section {
      display: none;
      margin-top: 15px;
    }

    .url-input-section.visible {
      display: block;
    }

    .url-input-section label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 5px;
    }

    .url-input-row {
      display: flex;
      gap: 8px;
    }

    .url-input-row input {
      flex: 1;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-size: 0.85rem;
    }

    .url-add-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background: #4CAF50;
      color: white;
      cursor: pointer;
    }

    .url-add-btn:disabled {
      background: #444;
      cursor: not-allowed;
    }

    .url-preview {
      margin-top: 10px;
      max-height: 100px;
      overflow: hidden;
      border-radius: 6px;
    }

    .url-preview img {
      max-width: 100%;
      max-height: 100px;
    }

    .image-dialog-cancel {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: transparent;
      color: #888;
      cursor: pointer;
    }

    /* Link to full version */
    .full-version-link {
      text-align: center;
      padding: 15px;
      border-top: 1px solid rgba(255,255,255,0.1);
      margin-top: 15px;
    }

    .full-version-link a {
      color: #888;
      font-size: 0.8rem;
      text-decoration: none;
    }

    .full-version-link a:hover {
      color: #b388ff;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.2);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.3);
    }

    /* Battle Queue Styles */
    .queue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .queue-title {
      font-size: 1rem;
      color: #ffd700;
    }

    .queue-actions {
      display: flex;
      gap: 8px;
    }

    .queue-btn {
      padding: 6px 12px;
      border: 1px solid rgba(76, 175, 80, 0.5);
      border-radius: 4px;
      background: transparent;
      color: #4CAF50;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .queue-btn:hover {
      background: rgba(76, 175, 80, 0.1);
    }

    .queue-btn.primary {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      border-color: transparent;
      color: white;
    }

    .queue-btn.primary:hover {
      transform: scale(1.02);
    }

    .queue-btn.danger {
      border-color: rgba(244, 67, 54, 0.5);
      color: #f44336;
    }

    .queue-btn.danger:hover {
      background: rgba(244, 67, 54, 0.1);
    }

    .queue-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .queue-empty {
      text-align: center;
      color: #666;
      padding: 40px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      border: 2px dashed rgba(255,255,255,0.1);
    }

    .queue-empty-icon {
      font-size: 2rem;
      margin-bottom: 10px;
      opacity: 0.5;
    }

    .staged-battle-card {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
      overflow: hidden;
      transition: all 0.2s;
    }

    .staged-battle-card:hover {
      border-color: rgba(179, 136, 255, 0.4);
    }

    .staged-battle-card.drag-over {
      border-color: #ffd700;
      background: rgba(255, 215, 0, 0.1);
    }

    .staged-battle-header {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      background: rgba(0,0,0,0.2);
      cursor: grab;
    }

    .staged-battle-header:active {
      cursor: grabbing;
    }

    .staged-battle-order {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      font-weight: 700;
      margin-right: 10px;
      flex-shrink: 0;
    }

    .staged-battle-info {
      flex: 1;
      min-width: 0;
    }

    .staged-battle-name {
      font-size: 0.9rem;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .staged-battle-meta {
      font-size: 0.7rem;
      color: #888;
      display: flex;
      gap: 10px;
      margin-top: 2px;
    }

    .staged-battle-actions {
      display: flex;
      gap: 4px;
    }

    .staged-action-btn {
      padding: 6px 10px;
      border: none;
      border-radius: 4px;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .staged-action-btn.load {
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-weight: 700;
    }

    .staged-action-btn.load:hover {
      transform: scale(1.05);
    }

    .staged-action-btn.preview {
      background: rgba(179, 136, 255, 0.2);
      color: #b388ff;
    }

    .staged-action-btn.edit {
      background: rgba(255,255,255,0.1);
      color: #aaa;
    }

    .staged-action-btn.delete {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }

    .staged-battle-preview {
      display: none;
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,0.05);
    }

    .staged-battle-preview.visible {
      display: block;
    }

    .preview-grid {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 10px;
    }

    .preview-map {
      width: 120px;
      height: 80px;
      background: rgba(0,0,0,0.4);
      border-radius: 4px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .preview-map img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .preview-map-placeholder {
      color: #555;
      font-size: 0.7rem;
    }

    .preview-details {
      font-size: 0.75rem;
    }

    .preview-section {
      margin-bottom: 6px;
    }

    .preview-section-title {
      color: #888;
      font-size: 0.65rem;
      margin-bottom: 2px;
    }

    .preview-adversaries {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .preview-adv-tag {
      padding: 2px 6px;
      background: rgba(244, 67, 54, 0.2);
      border-radius: 3px;
      font-size: 0.65rem;
      color: #f44336;
    }

    .preview-tokens {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .preview-token-tag {
      padding: 2px 6px;
      background: rgba(76, 175, 80, 0.2);
      border-radius: 3px;
      font-size: 0.65rem;
      color: #4CAF50;
    }

    .preview-token-tag.adversary {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }

    .preview-notes {
      color: #aaa;
      font-style: italic;
      max-height: 40px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Stage Battle Modal */
    .stage-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .stage-modal.visible {
      display: flex;
    }

    .stage-modal-content {
      background: #1a1a2e;
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .stage-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .stage-modal-title {
      font-size: 1rem;
      color: #ffd700;
    }

    .stage-modal-close {
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      color: #aaa;
      font-size: 1rem;
      cursor: pointer;
    }

    .stage-modal-body {
      padding: 15px;
    }

    .stage-form-group {
      margin-bottom: 15px;
    }

    .stage-form-label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 6px;
    }

    .stage-form-input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
    }

    .stage-form-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .stage-form-textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      resize: vertical;
      min-height: 80px;
    }

    .stage-form-textarea:focus {
      outline: none;
      border-color: #b388ff;
    }

    .stage-summary {
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 15px;
    }

    .stage-summary-title {
      font-size: 0.75rem;
      color: #888;
      margin-bottom: 8px;
    }

    .stage-summary-item {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      padding: 4px 0;
    }

    .stage-summary-value {
      color: #ffd700;
    }

    .stage-modal-footer {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      padding: 15px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .stage-cancel-btn {
      padding: 10px 20px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: transparent;
      color: #aaa;
      font-family: 'Cinzel', serif;
      cursor: pointer;
    }

    .stage-save-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: white;
      font-family: 'Cinzel', serif;
      font-weight: 700;
      cursor: pointer;
    }

    .stage-save-btn:hover {
      transform: scale(1.02);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .battle-grid {
        grid-template-columns: 1fr;
      }

      .quick-bar {
        flex-wrap: wrap;
      }

      .dice-compact {
        width: 100%;
        order: 1;
      }

      .quick-dice-btns {
        display: none;
      }

      .preview-grid {
        grid-template-columns: 1fr;
      }

      .preview-map {
        width: 100%;
        height: 100px;
      }
    }
  </style>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
</head>
<body>
  <!-- Header Bar -->
  <div class="header-bar">
    <div class="header-title">GM Control Panel</div>
    <div class="header-actions">
      <a href="encounter-generator.html" class="header-btn" style="text-decoration: none;" title="Build encounters">Encounter Builder</a>
      <span id="connectionStatusText" style="font-size: 0.7rem; color: #888;">Initializing...</span>
      <button class="header-btn" id="connectionBtn" onclick="copyRoomCode()">Room: ----</button>
    </div>
  </div>

  <!-- Quick Bar - Always Visible -->
  <div class="quick-bar">
    <div class="fear-compact">
      <span class="fear-label">FEAR</span>
      <div class="fear-btns">
        <button class="fear-btn remove" onclick="adjustFear(-1)">-</button>
      </div>
      <div class="fear-value" id="fearDisplay">0</div>
      <div class="fear-btns">
        <button class="fear-btn add" onclick="adjustFear(1)">+</button>
      </div>
    </div>

    <div class="dice-compact">
      <input type="text" class="dice-input" id="diceNotation" placeholder="1d20+5" value="1d20">
      <button class="roll-btn" onclick="rollNotation()">Roll</button>
      <div class="quick-dice-btns">
        <button class="qd-btn" onclick="setNotation('1d20')">d20</button>
        <button class="qd-btn" onclick="setNotation('2d6')">2d6</button>
        <button class="qd-btn" onclick="setNotation('1d12')">d12</button>
        <button class="qd-btn" onclick="rollHopeFear()">H/F</button>
      </div>
      <div class="last-roll-display">
        <div class="last-roll-result" id="lastRoll">-</div>
      </div>
    </div>
  </div>

  <!-- Tab Navigation -->
  <div class="tab-nav">
    <button class="tab-btn active" onclick="switchTab('battle')">Battle <span class="tab-badge" id="battleBadge">0</span></button>
    <button class="tab-btn" onclick="switchTab('encounter')">Encounter <span class="tab-badge" id="encounterBadge">0</span></button>
    <button class="tab-btn" onclick="switchTab('queue')">Queue <span class="tab-badge" id="queueBadge">0</span></button>
    <button class="tab-btn" onclick="switchTab('settings')">Settings</button>
    <button class="tab-btn" onclick="switchTab('reference')">Reference</button>
  </div>

  <!-- Tab Content -->
  <div class="tab-content">
    <!-- Battle Tab -->
    <div class="tab-panel active" id="battleTab">
      <div class="battle-grid">
        <div class="map-area">
          <div class="map-header">
            <h3>Battle Map</h3>
            <div class="map-controls">
              <input type="file" id="mapImageInput" accept="image/*" style="display: none;" onchange="handleMapUpload(event)">
              <button class="map-btn" onclick="showMapImageDialog()">Upload</button>
              <button class="map-btn" id="mapVisBtn" onclick="toggleMapVisibility()">Show</button>
              <button class="map-btn" id="gridBtn" onclick="toggleGrid()">Grid</button>
              <button class="map-btn" onclick="clearMap()">Clear</button>
            </div>
          </div>
          <div class="map-preview-area" id="mapPreviewArea">
            <div class="map-preview-wrapper" id="mapPreviewWrapper">
              <img id="mapPreview" style="display: none;" alt="Map Preview">
              <canvas id="mapPreviewGrid" class="map-preview-grid"></canvas>
              <div id="mapPreviewTokenLayer" class="map-preview-token-layer"></div>
            </div>
            <div class="map-placeholder" id="mapPlaceholder">Click Upload to add a battle map</div>
            <div class="position-mode-indicator" id="positionModeIndicator" style="display: none;">
              <span>Positioning: <strong id="positioningTokenName"></strong></span>
              <button class="cancel-position-btn" onclick="cancelPositionMode()">Cancel</button>
            </div>
          </div>
        </div>

        <div class="token-area">
          <div class="token-header">
            <h3>Tokens</h3>
            <button class="add-token-btn" onclick="addPlayerToken()">+ Player</button>
          </div>
          <div class="token-list" id="tokenList">
            <!-- Tokens rendered here -->
          </div>
        </div>
      </div>
    </div>

    <!-- Encounter Tab -->
    <div class="tab-panel" id="encounterTab">
      <div class="encounter-header">
        <div class="encounter-title" id="encounterTitle">No Encounter Loaded</div>
        <div class="encounter-actions">
          <input type="file" id="encounterFolderInput" webkitdirectory directory style="display: none;" onchange="handleEncounterFolderUpload(event)">
          <input type="file" id="encounterFileInput" accept=".json" style="display: none;" onchange="handleEncounterUpload(event)">
          <input type="file" id="adversaryImageInput" accept="image/*" style="display: none;" multiple onchange="handleAdversaryImageUpload(event)">
          <button class="encounter-btn" onclick="document.getElementById('encounterFolderInput').click()">Load Folder</button>
          <button class="encounter-btn" onclick="loadSampleEncounter()">Sample</button>
          <button class="encounter-btn" onclick="clearEncounter()">Clear</button>
        </div>
      </div>

      <div class="autocomplete-container">
        <input type="text"
               class="adversary-search"
               id="adversarySearchInput"
               placeholder="Search adversaries to add..."
               autocomplete="off">
        <div id="autocompleteDropdown" class="autocomplete-dropdown"></div>
      </div>

      <div id="encounterContainer">
        <div class="encounter-empty">
          No encounter loaded. Load a folder or use the search to add adversaries.
        </div>
      </div>

      <button class="hide-spotlight-btn" id="hideSpotlightBtn" onclick="hideSpotlight()">Hide Spotlight</button>
    </div>

    <!-- Queue Tab -->
    <div class="tab-panel" id="queueTab">
      <div class="queue-header">
        <div class="queue-title">Battle Queue</div>
        <div class="queue-actions">
          <button class="queue-btn primary" onclick="openStageBattleModal()">+ Stage Current Battle</button>
          <input type="file" id="importQueueInput" accept=".json" style="display: none;" onchange="handleImportQueue(event)">
          <button class="queue-btn" onclick="document.getElementById('importQueueInput').click()">Import</button>
          <button class="queue-btn" onclick="exportQueue()">Export</button>
          <button class="queue-btn danger" onclick="clearQueue()">Clear All</button>
        </div>
      </div>

      <div id="queueContainer" class="queue-list">
        <div class="queue-empty">
          <div class="queue-empty-icon">&#9876;</div>
          <div>No battles staged yet.</div>
          <div style="margin-top: 8px; font-size: 0.8rem;">
            Set up your battle map, tokens, and encounter, then click "Stage Current Battle" to save it to the queue.
          </div>
        </div>
      </div>
    </div>

    <!-- Settings Tab -->
    <div class="tab-panel" id="settingsTab">
      <div class="settings-grid">
        <div class="settings-section">
          <h3>Display Windows</h3>
          <button class="display-btn player" onclick="openPlayerDisplay()">Open Player Display</button>
          <button class="display-btn battlemap" onclick="openBattleMap()">Open Battle Map</button>

          <div class="connection-info">
            <div class="room-code-row">
              <span class="room-code-label">Room Code</span>
              <span class="room-code-value" id="roomCodeDisplay">----</span>
              <button class="copy-btn" onclick="copyRoomCode()">Copy</button>
            </div>
            <div class="connection-status">
              <div class="status-dot" id="connectionDot"></div>
              <span id="connectionText">Initializing...</span>
            </div>
          </div>
        </div>

        <div class="settings-section">
          <h3>NPC Portrait</h3>
          <div class="npc-preview-small" id="npcPreviewContainer">
            <img id="npcPreview" style="display: none;" alt="NPC Preview">
            <span id="npcPlaceholder" style="color: #666; font-size: 0.8rem;">No image</span>
          </div>
          <input type="file" id="npcImageInput" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
          <div class="npc-controls">
            <button class="npc-btn" onclick="document.getElementById('npcImageInput').click()">Upload</button>
            <button class="npc-btn" onclick="clearNpcImage()">Clear</button>
          </div>
          <div class="toggle-row">
            <span class="toggle-label">Show to Players</span>
            <label class="toggle-switch">
              <input type="checkbox" id="npcVisibilityToggle" onchange="toggleNpcVisibility()">
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>
      </div>

      <div class="full-version-link">
        <a href="gm-control-panel.html">Switch to Full GM Control Panel</a>
      </div>
    </div>

    <!-- Reference Tab -->
    <div class="tab-panel" id="referenceTab">
      <div class="reference-container">
        <div class="reference-header">
          <h3>Daggerheart SRD Reference</h3>
          <div class="reference-controls">
            <a href="https://www.daggerheart.com/wp-content/uploads/2025/05/DH-SRD-May202025.pdf"
               target="_blank"
               class="reference-btn">
              Open in New Tab
            </a>
          </div>
        </div>
        <div class="reference-pdf-wrapper">
          <iframe
            id="srdPdfViewer"
            src="https://www.daggerheart.com/wp-content/uploads/2025/05/DH-SRD-May202025.pdf"
            class="reference-pdf-frame"
            title="Daggerheart SRD PDF">
          </iframe>
        </div>
      </div>
    </div>
  </div>

  <!-- Token Positioning Modal -->
  <div id="positioningModal" class="positioning-modal" onclick="closePositioningModal(event)">
    <div class="positioning-container" onclick="event.stopPropagation()">
      <div class="positioning-header">
        <div class="positioning-title" id="positioningTitle">Position Token</div>
        <button class="positioning-close" onclick="closePositioningModal()">x</button>
      </div>
      <div class="positioning-map" id="positioningMapContainer">
        <img id="positioningMapImage" src="" alt="Map">
        <canvas id="positioningGrid" class="positioning-grid"></canvas>
      </div>
    </div>
  </div>

  <!-- Image Source Dialog -->
  <div id="imageSourceDialog" class="image-dialog-overlay" onclick="closeImageDialog(event)">
    <div class="image-dialog" onclick="event.stopPropagation()">
      <h3>Add Portrait Image</h3>
      <div class="image-dialog-options">
        <button class="image-dialog-btn" onclick="chooseFileUpload()">
          Upload from Computer
        </button>
        <button class="image-dialog-btn" onclick="showUrlInput()">
          Use Image URL
        </button>
      </div>
      <div id="urlInputSection" class="url-input-section">
        <label>Image URL:</label>
        <div class="url-input-row">
          <input type="url" id="imageUrlInput" placeholder="https://..." onkeyup="handleUrlKeyup(event)" oninput="previewUrlImage()">
          <button class="url-add-btn" id="urlAddBtn" onclick="addUrlPortrait()" disabled>Add</button>
        </div>
        <div id="urlPreview" class="url-preview"></div>
      </div>
      <button class="image-dialog-cancel" onclick="closeImageDialog()">Cancel</button>
    </div>
  </div>

  <!-- Battle Map Image Source Dialog -->
  <div id="mapImageSourceDialog" class="image-dialog-overlay" onclick="closeMapImageDialog(event)">
    <div class="image-dialog" onclick="event.stopPropagation()">
      <h3>Add Battle Map</h3>
      <div class="image-dialog-options">
        <button class="image-dialog-btn" onclick="chooseMapFileUpload()">
          Upload from Computer
        </button>
        <button class="image-dialog-btn" onclick="showMapUrlInput()">
          Use Image URL (CDN)
        </button>
      </div>
      <div id="mapUrlInputSection" class="url-input-section">
        <label>Image URL:</label>
        <div class="url-input-row">
          <input type="url" id="mapImageUrlInput" placeholder="https://..." onkeyup="handleMapUrlKeyup(event)" oninput="previewMapUrlImage()">
          <button class="url-add-btn" id="mapUrlAddBtn" onclick="addMapUrl()" disabled>Add</button>
        </div>
        <div id="mapUrlPreview" class="url-preview"></div>
      </div>
      <button class="image-dialog-cancel" onclick="closeMapImageDialog()">Cancel</button>
    </div>
  </div>

  <!-- Player Token Image Source Dialog -->
  <div id="playerTokenImageSourceDialog" class="image-dialog-overlay" onclick="closePlayerTokenImageDialog(event)">
    <div class="image-dialog" onclick="event.stopPropagation()">
      <h3>Add Token Image</h3>
      <div class="image-dialog-options">
        <button class="image-dialog-btn" onclick="choosePlayerTokenFileUpload()">
          Upload from Computer
        </button>
        <button class="image-dialog-btn" onclick="showPlayerTokenUrlInput()">
          Use Image URL (CDN)
        </button>
      </div>
      <div id="playerTokenUrlInputSection" class="url-input-section">
        <label>Image URL:</label>
        <div class="url-input-row">
          <input type="url" id="playerTokenImageUrlInput" placeholder="https://..." onkeyup="handlePlayerTokenUrlKeyup(event)" oninput="previewPlayerTokenUrlImage()">
          <button class="url-add-btn" id="playerTokenUrlAddBtn" onclick="addPlayerTokenUrl()" disabled>Add</button>
        </div>
        <div id="playerTokenUrlPreview" class="url-preview"></div>
      </div>
      <button class="image-dialog-cancel" onclick="closePlayerTokenImageDialog()">Cancel</button>
    </div>
  </div>

  <!-- Player Token Image Upload -->
  <input type="file" id="playerTokenImageInput" accept="image/*" style="display: none;" onchange="handlePlayerTokenImageUpload(event)">

  <!-- Stage Battle Modal -->
  <div id="stageBattleModal" class="stage-modal" onclick="closeStageBattleModal(event)">
    <div class="stage-modal-content" onclick="event.stopPropagation()">
      <div class="stage-modal-header">
        <div class="stage-modal-title" id="stageModalTitle">Stage Current Battle</div>
        <button class="stage-modal-close" onclick="closeStageBattleModal()">x</button>
      </div>
      <div class="stage-modal-body">
        <div class="stage-form-group">
          <label class="stage-form-label">Battle Name</label>
          <input type="text" class="stage-form-input" id="stageBattleName" placeholder="e.g., Goblin Ambush, Boss Fight...">
        </div>

        <div class="stage-summary">
          <div class="stage-summary-title">What will be staged:</div>
          <div class="stage-summary-item">
            <span>Battle Map</span>
            <span class="stage-summary-value" id="stageSummaryMap">None</span>
          </div>
          <div class="stage-summary-item">
            <span>Adversaries</span>
            <span class="stage-summary-value" id="stageSummaryAdversaries">0</span>
          </div>
          <div class="stage-summary-item">
            <span>Tokens</span>
            <span class="stage-summary-value" id="stageSummaryTokens">0</span>
          </div>
          <div class="stage-summary-item">
            <span>Positioned Tokens</span>
            <span class="stage-summary-value" id="stageSummaryPositioned">0</span>
          </div>
        </div>

        <div class="stage-form-group">
          <label class="stage-form-label">Notes (optional)</label>
          <textarea class="stage-form-textarea" id="stageBattleNotes" placeholder="Add any GM notes for this battle..."></textarea>
        </div>
      </div>
      <div class="stage-modal-footer">
        <button class="stage-cancel-btn" onclick="closeStageBattleModal()">Cancel</button>
        <button class="stage-save-btn" id="stageSaveBtn" onclick="saveStagedBattle()">Stage Battle</button>
      </div>
    </div>
  </div>

  <script>
    // ========== State ==========
    let currentFear = 0;
    let currentNpcImage = null;
    let npcVisible = false;
    let currentEncounter = null;
    let spotlightedAdversary = null;
    let pendingImageUploadAdversaryId = null;
    let currentMap = null;
    let mapVisible = false;
    let battleMapTokens = [];
    let gridVisible = false;
    let gridSize = 50;
    let nextPlayerTokenId = 1;
    let positioningTokenId = null;
    let pendingPlayerTokenImageId = null;
    let adversaryDatabase = [];
    let selectedAutocompleteIndex = -1;
    let peer = null;
    let playerConnection = null;
    let roomCode = null;
    let stagedBattles = [];
    let editingStagedBattleId = null;

    // Default silhouette image
    const DEFAULT_NPC_IMAGE = `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
      <defs>
        <radialGradient id="shadowGlow" cx="50%" cy="50%" r="50%">
          <stop offset="0%" style="stop-color:#1a1a2e"/>
          <stop offset="70%" style="stop-color:#0d0d15"/>
          <stop offset="100%" style="stop-color:#050508"/>
        </radialGradient>
        <linearGradient id="silhouetteGrad" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" style="stop-color:#2d2d44"/>
          <stop offset="100%" style="stop-color:#15151f"/>
        </linearGradient>
      </defs>
      <rect width="200" height="200" fill="url(#shadowGlow)"/>
      <path d="M100 30 C75 30 60 50 60 75 C60 95 75 105 85 110 L75 115 C55 120 40 140 40 165 L40 190 L70 190 L75 150 L85 145 L90 190 L110 190 L115 145 L125 150 L130 190 L160 190 L160 165 C160 140 145 120 125 115 L115 110 C125 105 140 95 140 75 C140 50 125 30 100 30Z" fill="url(#silhouetteGrad)"/>
      <text x="100" y="120" font-family="Georgia, serif" font-size="48" font-weight="bold" fill="#6b5b95" text-anchor="middle" opacity="0.6">?</text>
    </svg>`)}`;

    function getDefaultImageForAdversary(adv) {
      return DEFAULT_NPC_IMAGE;
    }

    // ========== Tab Switching ==========
    function switchTab(tabName) {
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

      document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`).classList.add('active');
      document.getElementById(tabName + 'Tab').classList.add('active');

      // Refresh lists when switching tabs to ensure sync
      if (tabName === 'battle') {
        renderTokenList();
      } else if (tabName === 'encounter') {
        renderEncounter();
      } else if (tabName === 'queue') {
        renderQueueList();
      }

      // Clear update indicator on the tab we're switching to
      const badge = document.getElementById(tabName + 'Badge');
      if (badge) {
        badge.classList.remove('updated');
      }
    }

    function updateTabBadges() {
      const battleBadge = document.getElementById('battleBadge');
      const encounterBadge = document.getElementById('encounterBadge');
      const queueBadge = document.getElementById('queueBadge');

      if (battleBadge) {
        battleBadge.textContent = battleMapTokens.length;
      }

      if (encounterBadge) {
        const count = currentEncounter ? currentEncounter.adversaries.length : 0;
        encounterBadge.textContent = count;
      }

      if (queueBadge) {
        queueBadge.textContent = stagedBattles.length;
      }
    }

    function flashTabBadge(tabName) {
      const badge = document.getElementById(tabName + 'Badge');
      if (badge) {
        badge.classList.add('updated');
        setTimeout(() => badge.classList.remove('updated'), 1000);
      }
    }

    // ========== Fear Tracker ==========
    function adjustFear(amount) {
      currentFear = Math.max(0, Math.min(12, currentFear + amount));
      updateFearDisplay();
      syncFear();
    }

    function resetFear() {
      currentFear = 0;
      updateFearDisplay();
      syncFear();
    }

    function updateFearDisplay() {
      document.getElementById('fearDisplay').textContent = currentFear;
      localStorage.setItem('daggerheart-fear', currentFear.toString());
    }

    function syncFear() {
      sendToPlayer({ type: 'fear', value: currentFear });
      localStorage.setItem('daggerheart-update', Date.now().toString());
    }

    // ========== Dice Roller ==========
    function setNotation(notation) {
      document.getElementById('diceNotation').value = notation;
      rollNotation(); // Auto-roll when clicking quick dice buttons
    }

    function rollNotation() {
      const notationInput = document.getElementById('diceNotation');
      const notation = notationInput.value.trim();
      if (!notation) return;

      const result = rollDice(notation);
      const lastRollEl = document.getElementById('lastRoll');

      // Visual feedback - flash the result
      lastRollEl.textContent = result.total;
      lastRollEl.style.transform = 'scale(1.3)';
      lastRollEl.style.color = '#4CAF50';
      setTimeout(() => {
        lastRollEl.style.transform = 'scale(1)';
        lastRollEl.style.color = '#ffd700';
      }, 200);

      const diceData = {
        notation: notation,
        total: result.total,
        breakdown: result.breakdown,
        timestamp: Date.now()
      };

      localStorage.setItem('daggerheart-dice', JSON.stringify(diceData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer({ type: 'dice', ...diceData });

      console.log('Dice roll:', notation, '=', result.total, result.breakdown);
    }

    function rollDice(notation) {
      let total = 0;
      let breakdown = [];

      // Parse dice notation like "2d6+1d8+5"
      const parts = notation.replace(/\s/g, '').match(/([+-]?)(\d+d\d+|\d+)/gi) || [];

      parts.forEach(part => {
        // Check if it's a dice roll (contains 'd')
        if (part.toLowerCase().includes('d')) {
          const isNegative = part.startsWith('-');
          const cleanPart = part.replace(/^[+-]/, '');
          const [numDice, dieType] = cleanPart.toLowerCase().split('d').map(Number);
          const rolls = [];

          for (let i = 0; i < numDice; i++) {
            const roll = Math.floor(Math.random() * dieType) + 1;
            rolls.push(roll);
          }

          const subtotal = rolls.reduce((a, b) => a + b, 0);
          total += isNegative ? -subtotal : subtotal;
          breakdown.push(`${isNegative ? '-' : ''}${numDice}d${dieType}: [${rolls.join(', ')}]`);
        } else {
          // It's a modifier
          const value = parseInt(part);
          if (!isNaN(value)) {
            total += value;
            if (value !== 0) {
              breakdown.push(`Modifier: ${value >= 0 ? '+' : ''}${value}`);
            }
          }
        }
      });

      return { total, breakdown };
    }

    function rollHopeFear() {
      const hope = Math.floor(Math.random() * 12) + 1;
      const fear = Math.floor(Math.random() * 12) + 1;
      const sum = hope + fear;
      const winner = hope >= fear ? 'Hope' : 'Fear';
      const isDoubles = hope === fear;
      const lastRollEl = document.getElementById('lastRoll');

      if (isDoubles) {
        lastRollEl.textContent = `Critical!`;
        lastRollEl.style.color = '#ffd700';
      } else {
        lastRollEl.textContent = `${sum} ${winner}`;
        lastRollEl.style.color = winner === 'Hope' ? '#4CAF50' : '#f44336';
      }
      lastRollEl.style.transform = 'scale(1.3)';
      setTimeout(() => {
        lastRollEl.style.transform = 'scale(1)';
        lastRollEl.style.color = '#ffd700';
      }, 200);

      // Send to player display (localStorage for same-browser, PeerJS for remote)
      const diceData = {
        type: 'hopefear',
        hope: hope,
        fear: fear,
        sum: sum,
        winner: winner,
        critical: isDoubles,
        timestamp: Date.now()
      };

      localStorage.setItem('daggerheart-dice', JSON.stringify(diceData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer({ type: 'dice', ...diceData });

      console.log('Hope/Fear roll:', hope, '+', fear, '=', sum, winner, isDoubles ? '(Critical!)' : '');
    }

    // ========== Battle Map ==========
    function handleMapUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        currentMap = {
          mapImage: e.target.result,
          gridSize: gridSize
        };

        const mapPreview = document.getElementById('mapPreview');
        mapPreview.src = e.target.result;
        mapPreview.style.display = 'block';
        document.getElementById('mapPlaceholder').style.display = 'none';

        // Wait for image to load to get dimensions, then render tokens and grid
        mapPreview.onload = () => {
          setTimeout(() => {
            drawMapPreviewGrid();
            renderMapPreviewTokens();
          }, 50);
        };

        syncBattleMap();
      };
      reader.readAsDataURL(file);
    }

    function toggleMapVisibility() {
      mapVisible = !mapVisible;
      const btn = document.getElementById('mapVisBtn');
      btn.classList.toggle('active', mapVisible);
      btn.textContent = mapVisible ? 'Hide' : 'Show';
      syncBattleMap();
    }

    function toggleGrid() {
      gridVisible = !gridVisible;
      document.getElementById('gridBtn').classList.toggle('active', gridVisible);
      drawMapPreviewGrid();
      syncBattleMap();
    }

    function clearMap() {
      currentMap = null;
      mapVisible = false;
      document.getElementById('mapPreview').style.display = 'none';
      document.getElementById('mapPlaceholder').style.display = 'block';
      document.getElementById('mapVisBtn').classList.remove('active');
      document.getElementById('mapVisBtn').textContent = 'Show';
      cancelPositionMode();
      renderMapPreviewTokens();
      drawMapPreviewGrid();
      syncBattleMap();
    }

    function syncBattleMap() {
      const mapData = {
        type: 'mapSync',
        map: currentMap ? {
          type: 'map',
          visible: mapVisible,
          mapImage: mapVisible ? currentMap.mapImage : null,
          gridSize: currentMap.gridSize
        } : null,
        tokens: { type: 'tokens', tokens: battleMapTokens },
        grid: { type: 'grid', visible: gridVisible },
        timestamp: Date.now()
      };

      sendToBattleMap(mapData);

      // Store state in localStorage but strip large base64 images
      localStorage.setItem('daggerheart-battle-map-state', JSON.stringify({
        visible: mapVisible,
        gridSize: gridSize
      }));

      // Strip base64 images from tokens before storing (keep URL images)
      // Format must match what battle-map.html expects: { type: 'tokens', tokens: [...] }
      const tokensForStorage = battleMapTokens.map(token => ({
        ...token,
        image: token.image && (token.image.startsWith('http://') || token.image.startsWith('https://'))
          ? token.image
          : null
      }));
      localStorage.setItem('daggerheart-battle-tokens', JSON.stringify({
        type: 'tokens',
        tokens: tokensForStorage,
        timestamp: Date.now()
      }));

      localStorage.setItem('daggerheart-battle-grid', JSON.stringify({ visible: gridVisible }));
      localStorage.setItem('daggerheart-update', Date.now().toString());
    }

    // ========== Tokens ==========
    function addPlayerToken() {
      const name = prompt('Enter player name:');
      if (!name) return;

      const token = {
        id: 'player-' + nextPlayerTokenId++,
        name: name,
        type: 'player',
        x: 0,
        y: 0,
        image: null,
        conditions: { hidden: false, restrained: false, vulnerable: false },
        visible: true
      };

      battleMapTokens.push(token);
      renderTokenList();
      syncBattleMap();
      updateTabBadges();
    }

    function addAdversaryToken(adversary) {
      const existingToken = battleMapTokens.find(t => t.id === adversary.id);
      if (existingToken) return;

      const hasPortrait = adversary.portraits && adversary.portraits.length > 0;
      const token = {
        id: adversary.id,
        name: adversary.name,
        type: 'adversary',
        x: 0,
        y: 0,
        image: hasPortrait ? adversary.portraits[adversary.activePortraitIndex || 0] : getDefaultImageForAdversary(adversary),
        conditions: adversary.conditions || { hidden: false, restrained: false, vulnerable: false },
        visible: true
      };

      battleMapTokens.push(token);
      renderTokenList();
      syncBattleMap();
      updateTabBadges();
      flashTabBadge('battle'); // Flash to show token was added
    }

    function removeToken(tokenId) {
      battleMapTokens = battleMapTokens.filter(t => t.id !== tokenId);
      renderTokenList();
      syncBattleMap();
      updateTabBadges();
    }

    function toggleTokenVisibility(tokenId) {
      const token = battleMapTokens.find(t => t.id === tokenId);
      if (token) {
        token.visible = !token.visible;
        renderTokenList();
        syncBattleMap();
      }
    }

    function openPositioningModal(tokenId) {
      if (!currentMap) {
        alert('Please upload a map first');
        return;
      }

      // Use the inline positioning mode on the map preview
      selectTokenForPositioning(tokenId);
    }

    function drawPositioningGrid() {
      const canvas = document.getElementById('positioningGrid');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;

      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw current token position
      const token = battleMapTokens.find(t => t.id === positioningTokenId);
      if (token) {
        const x = token.x * gridSize + gridSize / 2;
        const y = token.y * gridSize + gridSize / 2;
        ctx.fillStyle = token.type === 'player' ? '#4CAF50' : '#f44336';
        ctx.beginPath();
        ctx.arc(x, y, gridSize / 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    document.getElementById('positioningGrid').addEventListener('click', (e) => {
      if (!positioningTokenId) return;

      const canvas = e.target;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      const x = Math.floor((e.clientX - rect.left) * scaleX / gridSize);
      const y = Math.floor((e.clientY - rect.top) * scaleY / gridSize);

      const token = battleMapTokens.find(t => t.id === positioningTokenId);
      if (token) {
        token.x = x;
        token.y = y;
        drawPositioningGrid();
        syncBattleMap();
      }
    });

    function closePositioningModal(event) {
      if (event && event.target !== document.getElementById('positioningModal')) return;
      document.getElementById('positioningModal').classList.remove('visible');
      positioningTokenId = null;
    }

    // ===== Map Preview Token Rendering =====
    let selectedTokenForPositioning = null;

    function renderMapPreviewTokens() {
      const tokenLayer = document.getElementById('mapPreviewTokenLayer');
      const mapPreview = document.getElementById('mapPreview');

      if (!tokenLayer || !mapPreview || mapPreview.style.display === 'none' || !currentMap) {
        if (tokenLayer) tokenLayer.innerHTML = '';
        return;
      }

      // Get the displayed size of the map image
      const imgRect = mapPreview.getBoundingClientRect();
      const wrapperRect = document.getElementById('mapPreviewWrapper').getBoundingClientRect();

      // Calculate scale factor between natural and displayed size
      const scaleX = mapPreview.width / mapPreview.naturalWidth;
      const scaleY = mapPreview.height / mapPreview.naturalHeight;

      tokenLayer.innerHTML = '';

      battleMapTokens.forEach(token => {
        const tokenEl = document.createElement('div');
        tokenEl.className = `map-preview-token ${token.type}${!token.visible ? ' hidden-token' : ''}`;
        tokenEl.id = `preview-token-${token.id}`;

        if (selectedTokenForPositioning === token.id) {
          tokenEl.classList.add('selected');
        }

        // Calculate pixel position based on grid coordinates and scale
        const pixelX = (token.x * gridSize + gridSize / 2) * scaleX;
        const pixelY = (token.y * gridSize + gridSize / 2) * scaleY;

        tokenEl.style.left = `${pixelX}px`;
        tokenEl.style.top = `${pixelY}px`;

        // Set token image or default color
        if (token.image) {
          tokenEl.style.backgroundImage = `url(${token.image})`;
        } else {
          tokenEl.style.backgroundColor = token.type === 'player' ? '#4CAF50' : '#f44336';
        }

        // Add token name label
        const labelEl = document.createElement('div');
        labelEl.className = 'token-label';
        labelEl.textContent = token.name;
        tokenEl.appendChild(labelEl);

        // Add condition badges
        const conditions = getTokenConditions(token);
        if (conditions.hidden || conditions.restrained || conditions.vulnerable) {
          const conditionsEl = document.createElement('div');
          conditionsEl.className = 'token-conditions-mini';

          if (conditions.hidden) {
            const badge = document.createElement('div');
            badge.className = 'condition-mini hidden-cond';
            badge.textContent = 'H';
            conditionsEl.appendChild(badge);
          }
          if (conditions.restrained) {
            const badge = document.createElement('div');
            badge.className = 'condition-mini restrained-cond';
            badge.textContent = 'R';
            conditionsEl.appendChild(badge);
          }
          if (conditions.vulnerable) {
            const badge = document.createElement('div');
            badge.className = 'condition-mini vulnerable-cond';
            badge.textContent = 'V';
            conditionsEl.appendChild(badge);
          }

          tokenEl.appendChild(conditionsEl);
        }

        // Click handler to select token for positioning
        tokenEl.addEventListener('click', (e) => {
          e.stopPropagation();
          selectTokenForPositioning(token.id);
        });

        tokenLayer.appendChild(tokenEl);
      });
    }

    function getTokenConditions(token) {
      // For adversaries, get conditions from the encounter data
      if (token.type === 'adversary' && currentEncounter && currentEncounter.adversaries) {
        const adversary = currentEncounter.adversaries.find(a => a.id === token.id);
        if (adversary && adversary.conditions) {
          return adversary.conditions;
        }
      }
      return token.conditions || { hidden: false, restrained: false, vulnerable: false };
    }

    function selectTokenForPositioning(tokenId) {
      const token = battleMapTokens.find(t => t.id === tokenId);
      if (!token) return;

      selectedTokenForPositioning = tokenId;

      // Show position mode indicator
      document.getElementById('positioningTokenName').textContent = token.name;
      document.getElementById('positionModeIndicator').style.display = 'flex';
      document.getElementById('mapPreviewArea').classList.add('positioning-active');

      // Update visual selection
      renderMapPreviewTokens();
    }

    function cancelPositionMode() {
      selectedTokenForPositioning = null;
      document.getElementById('positionModeIndicator').style.display = 'none';
      document.getElementById('mapPreviewArea').classList.remove('positioning-active');
      renderMapPreviewTokens();
    }

    function drawMapPreviewGrid() {
      const canvas = document.getElementById('mapPreviewGrid');
      const mapPreview = document.getElementById('mapPreview');

      if (!canvas || !mapPreview || mapPreview.style.display === 'none' || !currentMap) {
        if (canvas) {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        return;
      }

      // Set canvas size to match the displayed map size
      canvas.width = mapPreview.width;
      canvas.height = mapPreview.height;
      canvas.style.width = mapPreview.width + 'px';
      canvas.style.height = mapPreview.height + 'px';

      // Calculate scale factor
      const scaleX = mapPreview.width / mapPreview.naturalWidth;
      const scaleY = mapPreview.height / mapPreview.naturalHeight;
      const scaledGridSize = gridSize * scaleX;

      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Only draw if grid is enabled
      if (!gridVisible) return;

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 1;

      // Draw vertical lines
      for (let x = 0; x <= canvas.width; x += scaledGridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      // Draw horizontal lines
      for (let y = 0; y <= canvas.height; y += scaledGridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    // Click handler for positioning on the map preview
    document.getElementById('mapPreviewWrapper').addEventListener('click', (e) => {
      if (!selectedTokenForPositioning || !currentMap) return;

      const mapPreview = document.getElementById('mapPreview');
      const rect = mapPreview.getBoundingClientRect();

      // Calculate click position relative to the map image
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      // Calculate scale factor
      const scaleX = mapPreview.width / mapPreview.naturalWidth;
      const scaleY = mapPreview.height / mapPreview.naturalHeight;

      // Convert to grid coordinates
      const gridX = Math.floor(clickX / (gridSize * scaleX));
      const gridY = Math.floor(clickY / (gridSize * scaleY));

      // Update token position
      const token = battleMapTokens.find(t => t.id === selectedTokenForPositioning);
      if (token) {
        token.x = gridX;
        token.y = gridY;
        renderMapPreviewTokens();
        renderTokenList();
        syncBattleMap();
      }
    });

    // Update map preview when window resizes
    window.addEventListener('resize', () => {
      if (currentMap) {
        setTimeout(() => {
          drawMapPreviewGrid();
          renderMapPreviewTokens();
        }, 100);
      }
    });

    function renderTokenList() {
      const container = document.getElementById('tokenList');
      if (!container) return;

      if (battleMapTokens.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px; font-size: 0.8rem;">No tokens. Add players or load an encounter.</div>';
        renderMapPreviewTokens();
        return;
      }

      container.innerHTML = battleMapTokens.map(token => {
        // Get adversary data for HP and conditions if this is an adversary token
        let adversary = null;
        let isSpotlighted = false;
        if (token.type === 'adversary' && currentEncounter && currentEncounter.adversaries) {
          adversary = currentEncounter.adversaries.find(a => a.id === token.id);
          isSpotlighted = spotlightedAdversary === token.id;
        }

        // Build adversary controls HTML
        let adversaryControlsHtml = '';
        if (adversary) {
          const conditions = adversary.conditions || {};
          const hpValueClass = adversary.currentHp <= 0 ? 'defeated' : (adversary.hp && adversary.currentHp <= adversary.hp * 0.25 ? 'critical' : '');

          adversaryControlsHtml = `
            <div class="token-controls">
              <div class="token-controls-row">
                <button class="token-spotlight-btn ${isSpotlighted ? 'active' : ''}" onclick="setSpotlight('${token.id}')" title="Show to players">
                  ${isSpotlighted ? '' : ''}
                </button>
                ${adversary.hp !== undefined ? `
                  <div class="token-hp-tracker">
                    <span class="token-hp-label">HP</span>
                    <button class="token-hp-btn minus" onclick="adjustHp('${token.id}', -1)"></button>
                    <span class="token-hp-value ${hpValueClass}">${adversary.currentHp}/${adversary.hp}</span>
                    <button class="token-hp-btn plus" onclick="adjustHp('${token.id}', 1)">+</button>
                  </div>
                ` : ''}
              </div>
              <div class="token-controls-row">
                <button class="token-condition-btn hidden-btn ${conditions.hidden ? 'active' : ''}" onclick="toggleCondition('${token.id}', 'hidden')" title="Hidden"></button>
                <button class="token-condition-btn restrained-btn ${conditions.restrained ? 'active' : ''}" onclick="toggleCondition('${token.id}', 'restrained')" title="Restrained"></button>
                <button class="token-condition-btn vulnerable-btn ${conditions.vulnerable ? 'active' : ''}" onclick="toggleCondition('${token.id}', 'vulnerable')" title="Vulnerable"></button>
              </div>
            </div>
          `;
        }

        return `
          <div class="token-item ${token.type} ${token.visible ? '' : 'hidden'} ${isSpotlighted ? 'spotlighted' : ''}">
            <div class="token-thumb" onclick="${token.type === 'player' && !token.image ? `uploadPlayerTokenImage('${token.id}')` : `openPositioningModal('${token.id}')`}" title="${token.type === 'player' && !token.image ? 'Click to add image' : 'Click to position on map'}">
              ${token.image ? `<img src="${token.image}" alt="${token.name}">` : `<span style="font-size: 1.2rem;">${token.type === 'player' ? '' : ''}</span>`}
            </div>
            <div style="flex: 1; min-width: 0;">
              <div style="display: flex; align-items: center; gap: 6px;">
                <span class="token-name">${token.name}</span>
                <span class="token-pos" style="font-size: 0.65rem; color: #888;">(${token.x},${token.y})</span>
              </div>
              ${adversaryControlsHtml}
            </div>
            <div class="token-actions">
              <button class="token-action-btn" onclick="openPositioningModal('${token.id}')" title="Position on map"></button>
              ${token.type === 'player' ? `<button class="token-action-btn" onclick="uploadPlayerTokenImage('${token.id}')" title="Set image"></button>` : ''}
              <button class="token-action-btn ${token.visible ? 'visible-on' : ''}" onclick="toggleTokenVisibility('${token.id}')" title="${token.visible ? 'Hide' : 'Show'}">
                ${token.visible ? '' : ''}
              </button>
              <button class="token-action-btn" onclick="removeToken('${token.id}')" title="Remove"></button>
            </div>
          </div>
        `;
      }).join('');

      // Also update tokens on the map preview
      renderMapPreviewTokens();
    }

    // ========== Encounters ==========
    function handleEncounterFolderUpload(event) {
      const files = Array.from(event.target.files);
      const jsonFile = files.find(f => f.name === 'encounter.json');

      if (!jsonFile) {
        alert('No encounter.json found in folder');
        return;
      }

      const imageFiles = files.filter(f => /\.(png|jpg|jpeg|gif|webp)$/i.test(f.name));
      const imageMap = {};

      let imagesLoaded = 0;
      const totalImages = imageFiles.length;

      const processEncounter = () => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            currentEncounter = {
              name: data.name || 'Encounter',
              adversaries: (data.adversaries || []).map(adv => ({
                ...adv,
                id: adv.id || 'adv-' + Math.random().toString(36).substr(2, 9),
                currentHp: adv.currentHp ?? adv.hp,
                currentStress: adv.currentStress ?? adv.stress,
                conditions: adv.conditions || { hidden: false, restrained: false, vulnerable: false },
                portraits: [],
                activePortraitIndex: 0
              }))
            };

            // Assign portraits from images
            currentEncounter.adversaries.forEach(adv => {
              if (adv.portrait && imageMap[adv.portrait]) {
                adv.portraits.push(imageMap[adv.portrait]);
              }
            });

            renderEncounter();
            saveEncounterState();

            // Add tokens for all adversaries
            currentEncounter.adversaries.forEach(adv => addAdversaryToken(adv));
          } catch (err) {
            alert('Error parsing encounter.json: ' + err.message);
          }
        };
        reader.readAsText(jsonFile);
      };

      if (totalImages === 0) {
        processEncounter();
      } else {
        imageFiles.forEach(file => {
          const imgReader = new FileReader();
          imgReader.onload = (e) => {
            imageMap[file.name] = e.target.result;
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              processEncounter();
            }
          };
          imgReader.readAsDataURL(file);
        });
      }
    }

    function handleEncounterUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          currentEncounter = {
            name: data.name || 'Encounter',
            adversaries: (data.adversaries || []).map(adv => ({
              ...adv,
              id: adv.id || 'adv-' + Math.random().toString(36).substr(2, 9),
              currentHp: adv.currentHp ?? adv.hp,
              currentStress: adv.currentStress ?? adv.stress,
              conditions: adv.conditions || { hidden: false, restrained: false, vulnerable: false },
              portraits: adv.portraits || [],
              activePortraitIndex: 0
            }))
          };

          renderEncounter();
          saveEncounterState();
          currentEncounter.adversaries.forEach(adv => addAdversaryToken(adv));
        } catch (err) {
          alert('Error parsing JSON: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    function loadSampleEncounter() {
      currentEncounter = {
        name: 'Sample Encounter',
        adversaries: [
          {
            id: 'sample-1',
            name: 'Skeleton Warrior',
            tier: 1,
            hp: 6,
            currentHp: 6,
            stress: 3,
            currentStress: 3,
            role: 'Minion',
            conditions: { hidden: false, restrained: false, vulnerable: false },
            portraits: [],
            activePortraitIndex: 0
          },
          {
            id: 'sample-2',
            name: 'Skeleton Archer',
            tier: 1,
            hp: 4,
            currentHp: 4,
            stress: 2,
            currentStress: 2,
            role: 'Minion',
            conditions: { hidden: false, restrained: false, vulnerable: false },
            portraits: [],
            activePortraitIndex: 0
          },
          {
            id: 'sample-3',
            name: 'Necromancer',
            tier: 2,
            hp: 15,
            currentHp: 15,
            stress: 8,
            currentStress: 8,
            role: 'Solo',
            conditions: { hidden: false, restrained: false, vulnerable: false },
            portraits: [],
            activePortraitIndex: 0
          }
        ]
      };

      renderEncounter();
      saveEncounterState();
      currentEncounter.adversaries.forEach(adv => addAdversaryToken(adv));
    }

    function clearEncounter() {
      // Remove adversary tokens
      if (currentEncounter) {
        currentEncounter.adversaries.forEach(adv => {
          battleMapTokens = battleMapTokens.filter(t => t.id !== adv.id);
        });
      }

      currentEncounter = null;
      spotlightedAdversary = null;
      renderEncounter();
      renderTokenList();
      syncBattleMap();
      updateTabBadges();

      localStorage.removeItem('daggerheart-encounter');
      localStorage.removeItem('daggerheart-spotlight');
      updateSpotlightUI();
    }

    function renderEncounter() {
      const container = document.getElementById('encounterContainer');
      const titleEl = document.getElementById('encounterTitle');

      if (!currentEncounter || currentEncounter.adversaries.length === 0) {
        titleEl.textContent = 'No Encounter Loaded';
        container.innerHTML = '<div class="encounter-empty">No encounter loaded. Load a folder or use the search to add adversaries.</div>';
        return;
      }

      titleEl.textContent = currentEncounter.name;

      container.innerHTML = `
        <div class="adversary-grid">
          ${currentEncounter.adversaries.map(adv => {
            const hpPercent = adv.hp ? (adv.currentHp / adv.hp) * 100 : 100;
            const stressPercent = adv.stress ? (adv.currentStress / adv.stress) * 100 : 100;
            const isSpotlighted = spotlightedAdversary === adv.id;
            const hasPortrait = adv.portraits && adv.portraits.length > 0;
            const portraitSrc = hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : getDefaultImageForAdversary(adv);

            return `
              <div class="adversary-card ${isSpotlighted ? 'spotlighted' : ''}">
                <div class="adv-header">
                  <div class="adv-portrait" onclick="openImageDialog('${adv.id}')">
                    <img src="${portraitSrc}" alt="${adv.name}">
                  </div>
                  <div class="adv-info">
                    <div class="adv-name">${adv.name}</div>
                    <div class="adv-tier">Tier ${adv.tier || 1} ${adv.role || ''}</div>
                  </div>
                  <div class="adv-actions">
                    <button class="spotlight-btn ${isSpotlighted ? 'active' : ''}" onclick="setSpotlight('${adv.id}')">
                      ${isSpotlighted ? 'On' : 'Show'}
                    </button>
                  </div>
                </div>

                <div class="adv-trackers">
                  <div class="tracker">
                    <div class="tracker-label">HP</div>
                    <div class="tracker-row">
                      <button class="tracker-btn" onclick="adjustHp('${adv.id}', -1)">-</button>
                      <span class="tracker-value hp ${adv.currentHp <= (adv.hp * 0.25) ? 'low' : ''}">${adv.currentHp}/${adv.hp}</span>
                      <button class="tracker-btn" onclick="adjustHp('${adv.id}', 1)">+</button>
                    </div>
                    <div class="tracker-bar"><div class="tracker-fill" style="width: ${hpPercent}%"></div></div>
                  </div>
                  <div class="tracker">
                    <div class="tracker-label">Stress</div>
                    <div class="tracker-row">
                      <button class="tracker-btn" onclick="adjustStress('${adv.id}', -1)">-</button>
                      <span class="tracker-value stress ${adv.currentStress <= (adv.stress * 0.25) ? 'low' : ''}">${adv.currentStress}/${adv.stress}</span>
                      <button class="tracker-btn" onclick="adjustStress('${adv.id}', 1)">+</button>
                    </div>
                    <div class="tracker-bar"><div class="tracker-fill stress" style="width: ${stressPercent}%"></div></div>
                  </div>
                </div>

                <div class="adv-conditions">
                  <span class="condition-badge hidden ${adv.conditions.hidden ? 'active' : ''}" onclick="toggleCondition('${adv.id}', 'hidden')">Hidden</span>
                  <span class="condition-badge restrained ${adv.conditions.restrained ? 'active' : ''}" onclick="toggleCondition('${adv.id}', 'restrained')">Restrained</span>
                  <span class="condition-badge vulnerable ${adv.conditions.vulnerable ? 'active' : ''}" onclick="toggleCondition('${adv.id}', 'vulnerable')">Vulnerable</span>
                </div>

                <div class="adv-stats">
                  <div class="stat-item">
                    <div class="stat-label">Attack</div>
                    <div class="stat-value attack">${adv.attack || '-'}</div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-label">Defense</div>
                    <div class="stat-value defense">${adv.defense || '-'}</div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-label">Type</div>
                    <div class="stat-value">${adv.type || adv.role || '-'}</div>
                  </div>
                </div>

                ${adv.thresholds ? `
                <div class="adv-thresholds">
                  <div class="threshold major">
                    <div class="threshold-label">Major</div>
                    <div class="threshold-value">${adv.thresholds.major}+</div>
                  </div>
                  <div class="threshold severe">
                    <div class="threshold-label">Severe</div>
                    <div class="threshold-value">${adv.thresholds.severe}+</div>
                  </div>
                </div>
                ` : ''}

                ${adv.traits && adv.traits.length > 0 ? `
                <div class="adv-traits">
                  ${adv.traits.map(trait => `<span class="trait-tag">${trait}</span>`).join('')}
                </div>
                ` : ''}

                ${adv.abilities && adv.abilities.length > 0 ? `
                <div class="adv-abilities">
                  <div class="abilities-header">Abilities</div>
                  ${adv.abilities.map(ability => {
                    const colonIndex = ability.indexOf(':');
                    if (colonIndex > -1) {
                      const name = ability.substring(0, colonIndex);
                      const desc = ability.substring(colonIndex + 1).trim();
                      return `<div class="ability-item"><span class="ability-name">${name}:</span> ${desc}</div>`;
                    }
                    return `<div class="ability-item">${ability}</div>`;
                  }).join('')}
                </div>
                ` : ''}
              </div>
            `;
          }).join('')}
        </div>
      `;
    }

    function adjustHp(advId, amount) {
      const adv = currentEncounter?.adversaries.find(a => a.id === advId);
      if (!adv) return;

      adv.currentHp = Math.max(0, Math.min(adv.hp, adv.currentHp + amount));

      // Update both views immediately
      renderEncounter();
      requestAnimationFrame(() => renderTokenList());
      saveEncounterState();

      if (spotlightedAdversary === advId) {
        syncSpotlight();
      }
    }

    function adjustStress(advId, amount) {
      const adv = currentEncounter?.adversaries.find(a => a.id === advId);
      if (!adv) return;

      adv.currentStress = Math.max(0, Math.min(adv.stress, adv.currentStress + amount));
      renderEncounter();
      saveEncounterState();
    }

    function toggleCondition(advId, condition) {
      const adv = currentEncounter?.adversaries.find(a => a.id === advId);
      if (!adv) return;

      adv.conditions[condition] = !adv.conditions[condition];
      renderEncounter();
      requestAnimationFrame(() => renderTokenList());
      saveEncounterState();

      // Update token conditions
      const token = battleMapTokens.find(t => t.id === advId);
      if (token) {
        token.conditions = { ...adv.conditions };
        syncBattleMap();
      }

      if (spotlightedAdversary === advId) {
        syncSpotlight();
      }
    }

    function setSpotlight(advId) {
      if (spotlightedAdversary === advId) {
        hideSpotlight();
        return;
      }

      spotlightedAdversary = advId;

      // Debug: log the adversary being spotlighted
      if (currentEncounter) {
        const adv = currentEncounter.adversaries.find(a => a.id === advId);
        if (adv) {
          console.log('Setting spotlight on:', adv.name);
          console.log('Portraits:', adv.portraits ? adv.portraits.length : 0);
          if (adv.portraits && adv.portraits.length > 0) {
            console.log('Portrait type:', typeof adv.portraits[0], adv.portraits[0].substring(0, 50) + '...');
          }
        }
      }

      renderEncounter();
      requestAnimationFrame(() => renderTokenList());
      updateSpotlightUI();
      syncSpotlight();
    }

    function hideSpotlight() {
      spotlightedAdversary = null;
      renderEncounter();
      requestAnimationFrame(() => renderTokenList());
      updateSpotlightUI();

      const spotlightData = { visible: false, timestamp: Date.now() };
      localStorage.setItem('daggerheart-spotlight', JSON.stringify(spotlightData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer({ type: 'spotlight', ...spotlightData });
    }

    function updateSpotlightUI() {
      const btn = document.getElementById('hideSpotlightBtn');
      btn.classList.toggle('visible', spotlightedAdversary !== null);
    }

    function syncSpotlight() {
      if (!spotlightedAdversary || !currentEncounter) return;

      const adv = currentEncounter.adversaries.find(a => a.id === spotlightedAdversary);
      if (!adv) return;

      const isDefeated = adv.hp !== undefined && adv.currentHp <= 0;
      const hasPortrait = adv.portraits && adv.portraits.length > 0;
      const imageToShow = hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : getDefaultImageForAdversary(adv);

      const spotlightData = {
        visible: true,
        adversaryId: adv.id,
        name: adv.name,
        image: imageToShow,
        isDefaultImage: !hasPortrait,
        defeated: isDefeated,
        conditions: adv.conditions || {},
        timestamp: Date.now()
      };

      // If PeerJS is connected, send via binary (handles large images well)
      if (playerConnection && playerConnection.open) {
        sendToPlayer({ type: 'spotlight', ...spotlightData });
        console.log('Spotlight sent via PeerJS:', adv.name, hasPortrait ? 'with portrait' : 'default image');

        // Save non-image data to localStorage for persistence
        const spotlightMetadata = { ...spotlightData, image: null };
        try {
          localStorage.setItem('daggerheart-spotlight', JSON.stringify(spotlightMetadata));
          localStorage.setItem('daggerheart-update', Date.now().toString());
        } catch (e) {
          console.error('Failed to save spotlight metadata:', e);
        }
      } else {
        // No PeerJS - try localStorage (for same-browser fallback)
        // Use URL images only, skip base64 to avoid quota issues
        const isUrlImage = imageToShow && (imageToShow.startsWith('http://') || imageToShow.startsWith('https://'));
        const storageData = {
          ...spotlightData,
          image: isUrlImage ? imageToShow : getDefaultImageForAdversary(adv) // Use default for base64
        };

        try {
          localStorage.setItem('daggerheart-spotlight', JSON.stringify(storageData));
          localStorage.setItem('daggerheart-update', Date.now().toString());
          console.log('Spotlight saved to localStorage:', adv.name);
        } catch (e) {
          console.error('Failed to sync spotlight to localStorage:', e);
        }
      }
    }

    function saveEncounterState() {
      if (currentEncounter) {
        try {
          // Strip large image data before saving to localStorage to avoid quota issues
          // Images are sent via PeerJS only (which handles binary data well)
          const encounterForStorage = {
            name: currentEncounter.name,
            adversaries: currentEncounter.adversaries.map(adv => ({
              ...adv,
              // Don't store base64 portraits in localStorage - they're too large
              // Only store URL-based portraits (they're small strings)
              portraits: (adv.portraits || []).filter(p =>
                typeof p === 'string' && (p.startsWith('http://') || p.startsWith('https://'))
              )
            }))
          };
          localStorage.setItem('daggerheart-encounter', JSON.stringify({ encounter: encounterForStorage }));
        } catch (e) {
          console.error('Failed to save encounter to localStorage:', e);
        }
      }
      updateTabBadges();
    }

    // ========== Adversary Search ==========
    const searchInput = document.getElementById('adversarySearchInput');
    const dropdown = document.getElementById('autocompleteDropdown');

    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim().toLowerCase();
      if (query.length < 2) {
        dropdown.classList.remove('visible');
        return;
      }

      const matches = adversaryDatabase.filter(adv =>
        adv.name.toLowerCase().includes(query) ||
        (adv.role && adv.role.toLowerCase().includes(query)) ||
        (adv.themes && adv.themes.some(t => t.toLowerCase().includes(query)))
      ).slice(0, 10);

      if (matches.length === 0) {
        dropdown.classList.remove('visible');
        return;
      }

      dropdown.innerHTML = matches.map((adv, i) => `
        <div class="autocomplete-item ${i === selectedAutocompleteIndex ? 'selected' : ''}"
             onclick="selectAutocompleteItem('${adv.name.replace(/'/g, "\\'")}')">
          ${adv.name}
          <small>T${adv.tier || 1} ${adv.role || ''}</small>
        </div>
      `).join('');

      dropdown.classList.add('visible');
    });

    searchInput.addEventListener('keydown', (e) => {
      const items = dropdown.querySelectorAll('.autocomplete-item');

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, items.length - 1);
        updateAutocompleteSelection();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, -1);
        updateAutocompleteSelection();
      } else if (e.key === 'Enter' && selectedAutocompleteIndex >= 0) {
        e.preventDefault();
        const item = items[selectedAutocompleteIndex];
        if (item) item.click();
      } else if (e.key === 'Escape') {
        dropdown.classList.remove('visible');
        selectedAutocompleteIndex = -1;
      }
    });

    function updateAutocompleteSelection() {
      const items = dropdown.querySelectorAll('.autocomplete-item');
      items.forEach((item, i) => {
        item.classList.toggle('selected', i === selectedAutocompleteIndex);
      });
    }

    function selectAutocompleteItem(name) {
      const adv = adversaryDatabase.find(a => a.name === name);
      if (!adv) return;

      if (!currentEncounter) {
        currentEncounter = { name: 'Custom Encounter', adversaries: [] };
      }

      const newAdv = {
        ...adv,
        id: 'adv-' + Math.random().toString(36).substr(2, 9),
        currentHp: adv.hp,
        currentStress: adv.stress,
        conditions: { hidden: false, restrained: false, vulnerable: false },
        portraits: [],
        activePortraitIndex: 0
      };

      currentEncounter.adversaries.push(newAdv);
      addAdversaryToken(newAdv);

      searchInput.value = '';
      dropdown.classList.remove('visible');
      selectedAutocompleteIndex = -1;

      renderEncounter();
      saveEncounterState();
    }

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.autocomplete-container')) {
        dropdown.classList.remove('visible');
        selectedAutocompleteIndex = -1;
      }
    });

    // ========== Image Dialog ==========
    function openImageDialog(advId) {
      pendingImageUploadAdversaryId = advId;
      document.getElementById('imageSourceDialog').classList.add('visible');
      document.getElementById('urlInputSection').classList.remove('visible');
      document.getElementById('imageUrlInput').value = '';
      document.getElementById('urlPreview').innerHTML = '';
    }

    function closeImageDialog(event) {
      if (event && event.target !== document.getElementById('imageSourceDialog')) return;
      document.getElementById('imageSourceDialog').classList.remove('visible');
      pendingImageUploadAdversaryId = null;
    }

    function chooseFileUpload() {
      document.getElementById('imageSourceDialog').classList.remove('visible');
      document.getElementById('adversaryImageInput').click();
    }

    function showUrlInput() {
      document.getElementById('urlInputSection').classList.add('visible');
    }

    function previewUrlImage() {
      const url = document.getElementById('imageUrlInput').value.trim();
      const preview = document.getElementById('urlPreview');
      const addBtn = document.getElementById('urlAddBtn');

      if (!url) {
        preview.innerHTML = '';
        addBtn.disabled = true;
        return;
      }

      preview.innerHTML = `<img src="${url}" alt="Preview" onerror="this.parentElement.innerHTML='Invalid URL'" onload="document.getElementById('urlAddBtn').disabled=false">`;
    }

    function handleUrlKeyup(event) {
      if (event.key === 'Enter') {
        addUrlPortrait();
      }
    }

    function addUrlPortrait() {
      const url = document.getElementById('imageUrlInput').value.trim();
      if (!url || !pendingImageUploadAdversaryId) return;

      const adv = currentEncounter?.adversaries.find(a => a.id === pendingImageUploadAdversaryId);
      if (adv) {
        if (!adv.portraits) adv.portraits = [];
        adv.portraits.push(url);
        adv.activePortraitIndex = adv.portraits.length - 1;

        // Update token image
        const token = battleMapTokens.find(t => t.id === adv.id);
        if (token) {
          token.image = url;
          syncBattleMap();
        }

        renderEncounter();
        saveEncounterState();

        if (spotlightedAdversary === adv.id) {
          syncSpotlight();
        }
      }

      closeImageDialog();
    }

    // ===== Battle Map Image Dialog Functions =====
    function showMapImageDialog() {
      document.getElementById('mapUrlInputSection').classList.remove('visible');
      document.getElementById('mapImageUrlInput').value = '';
      document.getElementById('mapUrlPreview').innerHTML = '';
      document.getElementById('mapUrlAddBtn').disabled = true;
      document.getElementById('mapImageSourceDialog').classList.add('visible');
    }

    function closeMapImageDialog(event) {
      if (event && event.target !== document.getElementById('mapImageSourceDialog')) return;
      document.getElementById('mapImageSourceDialog').classList.remove('visible');
    }

    function chooseMapFileUpload() {
      document.getElementById('mapImageSourceDialog').classList.remove('visible');
      document.getElementById('mapImageInput').click();
    }

    function showMapUrlInput() {
      document.getElementById('mapUrlInputSection').classList.add('visible');
      document.getElementById('mapImageUrlInput').focus();
    }

    function handleMapUrlKeyup(event) {
      if (event.key === 'Enter' && !document.getElementById('mapUrlAddBtn').disabled) {
        addMapUrl();
      }
    }

    function previewMapUrlImage() {
      const url = document.getElementById('mapImageUrlInput').value.trim();
      const preview = document.getElementById('mapUrlPreview');
      const addBtn = document.getElementById('mapUrlAddBtn');

      if (!url) {
        preview.innerHTML = '';
        addBtn.disabled = true;
        return;
      }

      preview.innerHTML = `<img src="${url}" alt="Preview" onerror="this.parentElement.innerHTML='Invalid URL'" onload="document.getElementById('mapUrlAddBtn').disabled=false">`;
    }

    function addMapUrl() {
      const url = document.getElementById('mapImageUrlInput').value.trim();
      if (!url) return;

      currentMap = { mapImage: url, gridSize: gridSize };

      const mapPreview = document.getElementById('mapPreview');
      mapPreview.src = url;
      mapPreview.style.display = 'block';
      document.getElementById('mapPlaceholder').style.display = 'none';
      document.getElementById('mapVisBtn').textContent = mapVisible ? 'Hide' : 'Show';

      // Wait for image to load to get dimensions, then render tokens and grid
      mapPreview.onload = () => {
        setTimeout(() => {
          drawMapPreviewGrid();
          renderMapPreviewTokens();
        }, 50);
      };

      if (mapVisible) {
        syncBattleMap();
      }

      closeMapImageDialog();
    }

    // ===== Player Token Image Dialog Functions =====
    function showPlayerTokenImageDialog() {
      document.getElementById('playerTokenUrlInputSection').classList.remove('visible');
      document.getElementById('playerTokenImageUrlInput').value = '';
      document.getElementById('playerTokenUrlPreview').innerHTML = '';
      document.getElementById('playerTokenUrlAddBtn').disabled = true;
      document.getElementById('playerTokenImageSourceDialog').classList.add('visible');
    }

    function closePlayerTokenImageDialog(event) {
      if (event && event.target !== document.getElementById('playerTokenImageSourceDialog')) return;
      document.getElementById('playerTokenImageSourceDialog').classList.remove('visible');
      pendingPlayerTokenImageId = null;
    }

    function choosePlayerTokenFileUpload() {
      document.getElementById('playerTokenImageSourceDialog').classList.remove('visible');
      document.getElementById('playerTokenImageInput').click();
    }

    function showPlayerTokenUrlInput() {
      document.getElementById('playerTokenUrlInputSection').classList.add('visible');
      document.getElementById('playerTokenImageUrlInput').focus();
    }

    function handlePlayerTokenUrlKeyup(event) {
      if (event.key === 'Enter' && !document.getElementById('playerTokenUrlAddBtn').disabled) {
        addPlayerTokenUrl();
      }
    }

    function previewPlayerTokenUrlImage() {
      const url = document.getElementById('playerTokenImageUrlInput').value.trim();
      const preview = document.getElementById('playerTokenUrlPreview');
      const addBtn = document.getElementById('playerTokenUrlAddBtn');

      if (!url) {
        preview.innerHTML = '';
        addBtn.disabled = true;
        return;
      }

      preview.innerHTML = `<img src="${url}" alt="Preview" onerror="this.parentElement.innerHTML='Invalid URL'" onload="document.getElementById('playerTokenUrlAddBtn').disabled=false">`;
    }

    function addPlayerTokenUrl() {
      const url = document.getElementById('playerTokenImageUrlInput').value.trim();
      if (!url || !pendingPlayerTokenImageId) return;

      const token = battleMapTokens.find(t => t.id === pendingPlayerTokenImageId);
      if (token) {
        token.image = url;
        renderTokenList();
        syncBattleMap();
      }
      pendingPlayerTokenImageId = null;

      closePlayerTokenImageDialog();
    }

    function uploadPlayerTokenImage(tokenId) {
      pendingPlayerTokenImageId = tokenId;
      showPlayerTokenImageDialog();
    }

    function handleAdversaryImageUpload(event) {
      const files = event.target.files;
      if (!files.length || !pendingImageUploadAdversaryId) return;

      const adv = currentEncounter?.adversaries.find(a => a.id === pendingImageUploadAdversaryId);
      if (!adv) return;

      Array.from(files).forEach(file => {
        const reader = new FileReader();
        reader.onload = (e) => {
          if (!adv.portraits) adv.portraits = [];
          adv.portraits.push(e.target.result);
          adv.activePortraitIndex = adv.portraits.length - 1;

          const token = battleMapTokens.find(t => t.id === adv.id);
          if (token) {
            token.image = e.target.result;
            syncBattleMap();
          }

          renderEncounter();
          saveEncounterState();

          if (spotlightedAdversary === adv.id) {
            syncSpotlight();
          }
        };
        reader.readAsDataURL(file);
      });

      pendingImageUploadAdversaryId = null;
    }

    // ========== NPC Portrait ==========
    function handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Check file size (limit to 5MB for localStorage)
      if (file.size > 5 * 1024 * 1024) {
        alert('Image too large. Please select an image under 5MB.');
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        currentNpcImage = e.target.result;
        updateNpcPreview();
        syncNpcToStorage();
      };
      reader.readAsDataURL(file);
    }

    function clearNpcImage() {
      currentNpcImage = null;
      npcVisible = false;
      document.getElementById('npcImageInput').value = '';
      updateNpcPreview();
      syncNpcToStorage();
    }

    function toggleNpcVisibility() {
      npcVisible = document.getElementById('npcVisibilityToggle').checked;
      syncNpcToStorage();
    }

    function updateNpcPreview() {
      const preview = document.getElementById('npcPreview');
      const placeholder = document.getElementById('npcPlaceholder');
      const toggle = document.getElementById('npcVisibilityToggle');

      if (currentNpcImage) {
        preview.src = currentNpcImage;
        preview.style.display = 'block';
        placeholder.style.display = 'none';
        toggle.disabled = false;
      } else {
        preview.style.display = 'none';
        placeholder.style.display = 'block';
        toggle.disabled = true;
        toggle.checked = false;
      }
    }

    // Sync NPC data to localStorage and PeerJS
    function syncNpcToStorage() {
      const npcData = {
        image: currentNpcImage,
        visible: npcVisible,
        timestamp: Date.now()
      };

      // If PeerJS connected, send via binary (handles large images)
      if (playerConnection && playerConnection.open) {
        sendToPlayer({ type: 'npc', ...npcData });

        // Save metadata only to localStorage
        const metadataOnly = { ...npcData, image: null };
        try {
          localStorage.setItem('daggerheart-npc', JSON.stringify(metadataOnly));
        } catch (e) {
          console.error('Failed to save NPC metadata:', e);
        }
      } else {
        // No PeerJS - save to localStorage (may fail for large images)
        try {
          localStorage.setItem('daggerheart-npc', JSON.stringify(npcData));
        } catch (e) {
          console.error('Failed to save NPC to localStorage:', e);
          if (e.name === 'QuotaExceededError' || e.code === 22) {
            alert('Image too large for localStorage. Connect via room code for remote display.');
          }
        }
      }
      localStorage.setItem('daggerheart-update', Date.now().toString());
    }

    // ========== Player Token Image ==========
    function handlePlayerTokenImageUpload(event) {
      const file = event.target.files[0];
      if (!file || !pendingPlayerTokenImageId) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const token = battleMapTokens.find(t => t.id === pendingPlayerTokenImageId);
        if (token) {
          token.image = e.target.result;
          renderTokenList();
          syncBattleMap();
        }
        pendingPlayerTokenImageId = null;
      };
      reader.readAsDataURL(file);
    }

    // ========== PeerJS Connection ==========
    function generateRoomCode() {
      const adjectives = ['RED', 'BLUE', 'GOLD', 'DARK', 'WILD', 'IRON', 'FIRE', 'FROST', 'STORM', 'SHADOW'];
      const nouns = ['WOLF', 'HAWK', 'BEAR', 'LION', 'RAVEN', 'DRAGON', 'SWORD', 'CROWN', 'FLAME', 'BLADE'];
      const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
      const noun = nouns[Math.floor(Math.random() * nouns.length)];
      const num = Math.floor(Math.random() * 100).toString().padStart(2, '0');
      return `${adj}-${noun}-${num}`;
    }

    function copyRoomCode() {
      if (roomCode) {
        navigator.clipboard.writeText(roomCode).then(() => {
          const btn = document.getElementById('connectionBtn');
          btn.textContent = 'Copied!';
          setTimeout(() => { btn.textContent = 'Room: ' + roomCode; }, 1500);
        });
      }
    }

    function initPeerHost() {
      roomCode = generateRoomCode();
      document.getElementById('roomCodeDisplay').textContent = roomCode;
      document.getElementById('connectionBtn').textContent = 'Room: ' + roomCode;

      const dot = document.getElementById('connectionDot');
      const text = document.getElementById('connectionText');
      const statusText = document.getElementById('connectionStatusText');

      // Check if PeerJS is loaded
      if (typeof Peer === 'undefined') {
        text.textContent = 'PeerJS not loaded';
        statusText.textContent = 'Offline';
        console.error('PeerJS library not loaded');
        return;
      }

      try {
        peer = new Peer('dh-' + roomCode, {
          debug: 2,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              { urls: 'stun:stun2.l.google.com:19302' },
              { urls: 'stun:stun3.l.google.com:19302' },
              { urls: 'stun:stun4.l.google.com:19302' }
            ]
          }
        });

        // Set a timeout for connection
        const connectionTimeout = setTimeout(() => {
          if (!peer || peer.disconnected) {
            text.textContent = 'Connection timeout - using local only';
            statusText.textContent = 'Local Mode';
          }
        }, 10000);

        peer.on('open', (id) => {
          clearTimeout(connectionTimeout);
          console.log('GM hosting with room code:', roomCode);
          text.textContent = 'Waiting for connection...';
          statusText.textContent = 'Ready';
        });

        peer.on('connection', (conn) => {
          console.log('Connection received, waiting for data channel...');

          conn.on('open', () => {
            console.log('Data channel open!');
            playerConnection = conn;
            dot.classList.add('connected');
            text.textContent = 'Connected!';
            statusText.textContent = 'Connected';
            document.getElementById('connectionBtn').classList.add('connected');
            sendFullSync();
          });

          conn.on('data', (data) => {
            if (data && data.type === 'battleMapConnected') {
              syncBattleMap();
            }
          });

          conn.on('close', () => {
            playerConnection = null;
            dot.classList.remove('connected');
            text.textContent = 'Disconnected';
            statusText.textContent = 'Disconnected';
            document.getElementById('connectionBtn').classList.remove('connected');
          });

          conn.on('error', (err) => {
            console.error('Connection error:', err);
          });
        });

        peer.on('disconnected', () => {
          console.log('Disconnected from signaling server');
          text.textContent = 'Reconnecting...';
          statusText.textContent = 'Reconnecting';
          setTimeout(() => {
            if (peer && !peer.destroyed) {
              peer.reconnect();
            }
          }, 2000);
        });

        peer.on('error', (err) => {
          console.error('PeerJS error:', err);
          if (err.type === 'unavailable-id') {
            roomCode = generateRoomCode();
            document.getElementById('roomCodeDisplay').textContent = roomCode;
            document.getElementById('connectionBtn').textContent = 'Room: ' + roomCode;
            peer.destroy();
            setTimeout(initPeerHost, 1000);
          } else if (err.type === 'network' || err.type === 'server-error') {
            text.textContent = 'Network error - local mode';
            statusText.textContent = 'Local Mode';
          } else {
            text.textContent = 'Error: ' + err.type;
            statusText.textContent = 'Error';
          }
        });
      } catch (e) {
        console.error('Failed to initialize PeerJS:', e);
        text.textContent = 'Init failed - local mode';
        statusText.textContent = 'Local Mode';
      }
    }

    function sendToPlayer(data) {
      if (playerConnection && playerConnection.open) {
        try {
          playerConnection.send(data);
        } catch (e) {
          console.error('Failed to send:', e);
        }
      }
    }

    function sendToBattleMap(data) {
      // Send to all connected battle map displays
      if (peer && peer.connections) {
        for (const peerId in peer.connections) {
          const connections = peer.connections[peerId];
          if (connections && connections.length > 0) {
            connections.forEach(conn => {
              if (conn.open && conn.metadata && conn.metadata.type === 'battleMap') {
                try {
                  conn.send(data);
                } catch (err) {
                  console.error('Error sending to battle map:', err);
                }
              }
            });
          }
        }
      }

      // Also broadcast to all connections (battle map will filter)
      if (playerConnection && playerConnection.open) {
        try {
          playerConnection.send(data);
        } catch (err) {
          console.error('Error broadcasting battle map data:', err);
        }
      }
    }

    function sendFullSync() {
      if (!playerConnection || !playerConnection.open) return;

      const syncData = {
        type: 'sync',
        fear: currentFear,
        spotlight: null
      };

      if (spotlightedAdversary && currentEncounter) {
        const adv = currentEncounter.adversaries.find(a => a.id === spotlightedAdversary);
        if (adv) {
          const isDefeated = adv.hp !== undefined && adv.currentHp <= 0;
          const hasPortrait = adv.portraits && adv.portraits.length > 0;

          syncData.spotlight = {
            visible: true,
            adversaryId: adv.id,
            name: adv.name,
            image: hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : getDefaultImageForAdversary(adv),
            isDefaultImage: !hasPortrait,
            defeated: isDefeated,
            conditions: adv.conditions || {},
            timestamp: Date.now()
          };
        }
      }

      sendToPlayer(syncData);
      syncBattleMap();
    }

    // ========== Display Windows ==========
    function openPlayerDisplay() {
      const width = 1200;
      const height = 800;
      const left = (screen.width - width) / 2;
      const top = (screen.height - height) / 2;
      window.open('player-display.html', 'PlayerDisplay', `width=${width},height=${height},left=${left},top=${top}`);
    }

    function openBattleMap() {
      const width = 1200;
      const height = 800;
      const left = (screen.width - width) / 2;
      const top = (screen.height - height) / 2;
      window.open('battle-map.html', 'BattleMap', `width=${width},height=${height},left=${left},top=${top}`);
    }

    // ========== Adversary Database ==========
    function loadAdversaryDatabase() {
      // Embedded adversary data (subset for the simplified panel)
      adversaryDatabase = [
        { name: 'Skeleton Warrior', tier: 1, role: 'Minion', hp: 6, stress: 3, themes: ['Undead'] },
        { name: 'Skeleton Archer', tier: 1, role: 'Minion', hp: 4, stress: 2, themes: ['Undead'] },
        { name: 'Zombie', tier: 1, role: 'Minion', hp: 8, stress: 2, themes: ['Undead'] },
        { name: 'Ghost', tier: 2, role: 'Standard', hp: 12, stress: 6, themes: ['Undead', 'Spirit'] },
        { name: 'Goblin Scout', tier: 1, role: 'Minion', hp: 4, stress: 2, themes: ['Goblinoid'] },
        { name: 'Goblin Warrior', tier: 1, role: 'Minion', hp: 6, stress: 3, themes: ['Goblinoid'] },
        { name: 'Hobgoblin', tier: 2, role: 'Standard', hp: 15, stress: 6, themes: ['Goblinoid'] },
        { name: 'Orc Berserker', tier: 2, role: 'Standard', hp: 18, stress: 8, themes: ['Orc'] },
        { name: 'Wolf', tier: 1, role: 'Minion', hp: 6, stress: 3, themes: ['Beast'] },
        { name: 'Dire Wolf', tier: 2, role: 'Standard', hp: 14, stress: 6, themes: ['Beast'] },
        { name: 'Bear', tier: 2, role: 'Standard', hp: 20, stress: 8, themes: ['Beast'] },
        { name: 'Giant Spider', tier: 2, role: 'Standard', hp: 12, stress: 5, themes: ['Beast', 'Vermin'] },
        { name: 'Bandit', tier: 1, role: 'Minion', hp: 5, stress: 3, themes: ['Humanoid'] },
        { name: 'Bandit Captain', tier: 2, role: 'Leader', hp: 16, stress: 7, themes: ['Humanoid'] },
        { name: 'Cultist', tier: 1, role: 'Minion', hp: 4, stress: 4, themes: ['Humanoid', 'Cult'] },
        { name: 'Cult Fanatic', tier: 2, role: 'Standard', hp: 12, stress: 8, themes: ['Humanoid', 'Cult'] },
        { name: 'Necromancer', tier: 2, role: 'Solo', hp: 15, stress: 10, themes: ['Humanoid', 'Undead'] },
        { name: 'Young Dragon', tier: 3, role: 'Solo', hp: 40, stress: 15, themes: ['Dragon'] },
        { name: 'Troll', tier: 3, role: 'Standard', hp: 35, stress: 10, themes: ['Giant'] },
        { name: 'Ogre', tier: 2, role: 'Standard', hp: 25, stress: 8, themes: ['Giant'] },
        { name: 'Wraith', tier: 3, role: 'Standard', hp: 20, stress: 12, themes: ['Undead', 'Spirit'] },
        { name: 'Vampire Spawn', tier: 2, role: 'Standard', hp: 18, stress: 8, themes: ['Undead', 'Vampire'] },
        { name: 'Elemental', tier: 2, role: 'Standard', hp: 16, stress: 6, themes: ['Elemental'] },
        { name: 'Demon', tier: 3, role: 'Standard', hp: 30, stress: 12, themes: ['Fiend'] },
        { name: 'Devil', tier: 3, role: 'Standard', hp: 28, stress: 14, themes: ['Fiend'] }
      ];
    }

    // ========== Battle Queue ==========
    function openStageBattleModal(battleId = null) {
      editingStagedBattleId = battleId;
      const modal = document.getElementById('stageBattleModal');

      if (battleId) {
        // Editing existing battle
        const battle = stagedBattles.find(b => b.id === battleId);
        if (battle) {
          document.getElementById('stageModalTitle').textContent = 'Edit Staged Battle';
          document.getElementById('stageBattleName').value = battle.name;
          document.getElementById('stageBattleNotes').value = battle.notes || '';
          document.getElementById('stageSaveBtn').textContent = 'Update Battle';
        }
      } else {
        // New battle
        document.getElementById('stageModalTitle').textContent = 'Stage Current Battle';
        document.getElementById('stageBattleName').value = currentEncounter?.name || '';
        document.getElementById('stageBattleNotes').value = '';
        document.getElementById('stageSaveBtn').textContent = 'Stage Battle';
      }

      // Update summary
      document.getElementById('stageSummaryMap').textContent = currentMap ? 'Yes' : 'None';
      document.getElementById('stageSummaryAdversaries').textContent = currentEncounter?.adversaries?.length || 0;
      document.getElementById('stageSummaryTokens').textContent = battleMapTokens.length;
      const positionedTokens = battleMapTokens.filter(t => t.x !== undefined && t.y !== undefined).length;
      document.getElementById('stageSummaryPositioned').textContent = positionedTokens;

      modal.classList.add('visible');
      document.getElementById('stageBattleName').focus();
    }

    function closeStageBattleModal(event) {
      if (event && event.target !== document.getElementById('stageBattleModal')) return;
      document.getElementById('stageBattleModal').classList.remove('visible');
      editingStagedBattleId = null;
    }

    function saveStagedBattle() {
      const name = document.getElementById('stageBattleName').value.trim();
      if (!name) {
        alert('Please enter a battle name.');
        return;
      }

      const notes = document.getElementById('stageBattleNotes').value.trim();

      if (editingStagedBattleId) {
        // Update existing battle
        const battle = stagedBattles.find(b => b.id === editingStagedBattleId);
        if (battle) {
          battle.name = name;
          battle.notes = notes;
          battle.updatedAt = Date.now();
        }
      } else {
        // Create new staged battle
        const stagedBattle = {
          id: 'battle-' + Math.random().toString(36).substr(2, 9),
          name: name,
          notes: notes,
          encounter: currentEncounter ? JSON.parse(JSON.stringify(currentEncounter)) : null,
          map: currentMap ? {
            mapImage: currentMap.mapImage,
            gridSize: currentMap.gridSize || gridSize
          } : null,
          mapVisible: mapVisible,
          gridVisible: gridVisible,
          tokens: JSON.parse(JSON.stringify(battleMapTokens)),
          createdAt: Date.now(),
          order: stagedBattles.length
        };

        stagedBattles.push(stagedBattle);
      }

      saveStagedBattles();
      renderQueueList();
      updateTabBadges();
      closeStageBattleModal();
    }

    function loadStagedBattle(battleId) {
      const battle = stagedBattles.find(b => b.id === battleId);
      if (!battle) return;

      if (!confirm(`Load "${battle.name}"? This will replace your current battle setup.`)) {
        return;
      }

      // Clear current state
      currentEncounter = null;
      currentMap = null;
      mapVisible = false;
      gridVisible = false;
      battleMapTokens = [];
      spotlightedAdversary = null;

      // Load battle state
      if (battle.encounter) {
        currentEncounter = JSON.parse(JSON.stringify(battle.encounter));
        // Reset HP/stress to starting values for fresh battle
        currentEncounter.adversaries.forEach(adv => {
          adv.currentHp = adv.hp;
          adv.currentStress = adv.stress;
          adv.conditions = { hidden: false, restrained: false, vulnerable: false };
        });
      }

      if (battle.map) {
        currentMap = {
          mapImage: battle.map.mapImage,
          gridSize: battle.map.gridSize || 50
        };
        gridSize = currentMap.gridSize;

        // Update map preview
        const preview = document.getElementById('mapPreview');
        const placeholder = document.getElementById('mapPlaceholder');
        if (preview && placeholder) {
          preview.src = currentMap.mapImage;
          preview.style.display = 'block';
          placeholder.style.display = 'none';

          // Wait for image to load, then render grid and tokens
          preview.onload = () => {
            setTimeout(() => {
              drawMapPreviewGrid();
              renderMapPreviewTokens();
            }, 50);
          };
        }
      } else {
        const preview = document.getElementById('mapPreview');
        const placeholder = document.getElementById('mapPlaceholder');
        if (preview && placeholder) {
          preview.style.display = 'none';
          placeholder.style.display = 'block';
        }
        drawMapPreviewGrid();
        renderMapPreviewTokens();
      }

      mapVisible = battle.mapVisible || false;
      gridVisible = battle.gridVisible || false;

      // Update visibility buttons
      const mapVisBtn = document.getElementById('mapVisBtn');
      const gridBtn = document.getElementById('gridBtn');
      if (mapVisBtn) {
        mapVisBtn.textContent = mapVisible ? 'Hide' : 'Show';
        mapVisBtn.classList.toggle('active', mapVisible);
      }
      if (gridBtn) {
        gridBtn.classList.toggle('active', gridVisible);
      }

      if (battle.tokens) {
        battleMapTokens = JSON.parse(JSON.stringify(battle.tokens));
      }

      // Update all UIs
      renderEncounter();
      renderTokenList();
      saveEncounterState();
      syncBattleMap();
      updateTabBadges();

      // Switch to Battle tab
      switchTab('battle');

      console.log(`Loaded staged battle: ${battle.name}`);
    }

    function deleteStagedBattle(battleId) {
      const battle = stagedBattles.find(b => b.id === battleId);
      if (!battle) return;

      if (!confirm(`Delete "${battle.name}" from the queue?`)) {
        return;
      }

      stagedBattles = stagedBattles.filter(b => b.id !== battleId);
      // Re-number remaining battles
      stagedBattles.forEach((b, i) => b.order = i);

      saveStagedBattles();
      renderQueueList();
      updateTabBadges();
    }

    function toggleBattlePreview(battleId) {
      const previewEl = document.getElementById(`preview-${battleId}`);
      if (previewEl) {
        previewEl.classList.toggle('visible');
      }
    }

    function moveBattleUp(battleId) {
      const index = stagedBattles.findIndex(b => b.id === battleId);
      if (index > 0) {
        [stagedBattles[index - 1], stagedBattles[index]] = [stagedBattles[index], stagedBattles[index - 1]];
        stagedBattles.forEach((b, i) => b.order = i);
        saveStagedBattles();
        renderQueueList();
      }
    }

    function moveBattleDown(battleId) {
      const index = stagedBattles.findIndex(b => b.id === battleId);
      if (index < stagedBattles.length - 1) {
        [stagedBattles[index], stagedBattles[index + 1]] = [stagedBattles[index + 1], stagedBattles[index]];
        stagedBattles.forEach((b, i) => b.order = i);
        saveStagedBattles();
        renderQueueList();
      }
    }

    function renderQueueList() {
      const container = document.getElementById('queueContainer');

      if (stagedBattles.length === 0) {
        container.innerHTML = `
          <div class="queue-empty">
            <div class="queue-empty-icon">&#9876;</div>
            <div>No battles staged yet.</div>
            <div style="margin-top: 8px; font-size: 0.8rem;">
              Set up your battle map, tokens, and encounter, then click "Stage Current Battle" to save it to the queue.
            </div>
          </div>
        `;
        return;
      }

      container.innerHTML = stagedBattles.map((battle, index) => {
        const adversaryCount = battle.encounter?.adversaries?.length || 0;
        const tokenCount = battle.tokens?.length || 0;
        const playerTokens = battle.tokens?.filter(t => t.type === 'player') || [];
        const adversaryTokens = battle.tokens?.filter(t => t.type === 'adversary') || [];
        const hasMap = !!battle.map?.mapImage;

        return `
          <div class="staged-battle-card" draggable="true" data-battle-id="${battle.id}"
               ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)"
               ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
            <div class="staged-battle-header">
              <div class="staged-battle-order">${index + 1}</div>
              <div class="staged-battle-info">
                <div class="staged-battle-name">${escapeHtml(battle.name)}</div>
                <div class="staged-battle-meta">
                  <span>${adversaryCount} adversar${adversaryCount === 1 ? 'y' : 'ies'}</span>
                  <span>${tokenCount} token${tokenCount === 1 ? '' : 's'}</span>
                  <span>${hasMap ? 'Map ready' : 'No map'}</span>
                </div>
              </div>
              <div class="staged-battle-actions">
                <button class="staged-action-btn load" onclick="loadStagedBattle('${battle.id}')">Load</button>
                <button class="staged-action-btn preview" onclick="toggleBattlePreview('${battle.id}')">Preview</button>
                <button class="staged-action-btn edit" onclick="openStageBattleModal('${battle.id}')">Edit</button>
                <button class="staged-action-btn delete" onclick="deleteStagedBattle('${battle.id}')">Delete</button>
              </div>
            </div>
            <div class="staged-battle-preview" id="preview-${battle.id}">
              <div class="preview-grid">
                <div class="preview-map">
                  ${hasMap
                    ? `<img src="${battle.map.mapImage}" alt="Map preview">`
                    : '<span class="preview-map-placeholder">No map</span>'}
                </div>
                <div class="preview-details">
                  ${adversaryCount > 0 ? `
                    <div class="preview-section">
                      <div class="preview-section-title">Adversaries</div>
                      <div class="preview-adversaries">
                        ${battle.encounter.adversaries.map(a => `<span class="preview-adv-tag">${escapeHtml(a.name)}</span>`).join('')}
                      </div>
                    </div>
                  ` : ''}
                  ${tokenCount > 0 ? `
                    <div class="preview-section">
                      <div class="preview-section-title">Tokens</div>
                      <div class="preview-tokens">
                        ${playerTokens.map(t => `<span class="preview-token-tag">${escapeHtml(t.name)}</span>`).join('')}
                        ${adversaryTokens.map(t => `<span class="preview-token-tag adversary">${escapeHtml(t.name)}</span>`).join('')}
                      </div>
                    </div>
                  ` : ''}
                  ${battle.notes ? `
                    <div class="preview-section">
                      <div class="preview-section-title">Notes</div>
                      <div class="preview-notes">${escapeHtml(battle.notes)}</div>
                    </div>
                  ` : ''}
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Drag and drop for reordering
    let draggedBattleId = null;

    function handleDragStart(event) {
      draggedBattleId = event.target.dataset.battleId;
      event.target.style.opacity = '0.5';
    }

    function handleDragOver(event) {
      event.preventDefault();
      const card = event.target.closest('.staged-battle-card');
      if (card && card.dataset.battleId !== draggedBattleId) {
        card.classList.add('drag-over');
      }
    }

    function handleDrop(event) {
      event.preventDefault();
      const card = event.target.closest('.staged-battle-card');
      if (card && draggedBattleId) {
        const targetId = card.dataset.battleId;
        if (targetId !== draggedBattleId) {
          const fromIndex = stagedBattles.findIndex(b => b.id === draggedBattleId);
          const toIndex = stagedBattles.findIndex(b => b.id === targetId);

          if (fromIndex !== -1 && toIndex !== -1) {
            const [moved] = stagedBattles.splice(fromIndex, 1);
            stagedBattles.splice(toIndex, 0, moved);
            stagedBattles.forEach((b, i) => b.order = i);
            saveStagedBattles();
            renderQueueList();
          }
        }
      }
      document.querySelectorAll('.staged-battle-card').forEach(c => c.classList.remove('drag-over'));
    }

    function handleDragEnd(event) {
      event.target.style.opacity = '1';
      draggedBattleId = null;
      document.querySelectorAll('.staged-battle-card').forEach(c => c.classList.remove('drag-over'));
    }

    function saveStagedBattles() {
      try {
        // For localStorage, we need to be careful about size
        // Store map images separately if they're base64
        const battlesForStorage = stagedBattles.map(battle => {
          const stored = { ...battle };
          // Keep URL-based maps, but note if there was a base64 map
          if (stored.map && stored.map.mapImage) {
            if (stored.map.mapImage.startsWith('data:')) {
              // Store base64 maps (they can be large but usually fit)
              // If localStorage fails, we'll handle it
            }
          }
          return stored;
        });
        localStorage.setItem('daggerheart-staged-battles', JSON.stringify(battlesForStorage));
      } catch (e) {
        console.error('Failed to save staged battles:', e);
        alert('Failed to save battle queue. The data may be too large. Try using URL-based images instead of uploaded images.');
      }
    }

    function loadStagedBattles() {
      try {
        const data = localStorage.getItem('daggerheart-staged-battles');
        if (data) {
          stagedBattles = JSON.parse(data);
          // Sort by order
          stagedBattles.sort((a, b) => (a.order || 0) - (b.order || 0));
        }
      } catch (e) {
        console.error('Failed to load staged battles:', e);
        stagedBattles = [];
      }
    }

    function exportQueue() {
      if (stagedBattles.length === 0) {
        alert('No battles to export.');
        return;
      }

      const exportData = {
        version: 1,
        exportedAt: new Date().toISOString(),
        battles: stagedBattles
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `battle-queue-${new Date().toISOString().slice(0, 10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function handleImportQueue(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          if (!data.battles || !Array.isArray(data.battles)) {
            alert('Invalid battle queue file.');
            return;
          }

          const mode = confirm('Click OK to append battles to current queue, or Cancel to replace the current queue.');

          if (mode) {
            // Append
            const startOrder = stagedBattles.length;
            data.battles.forEach((battle, i) => {
              battle.id = 'battle-' + Math.random().toString(36).substr(2, 9);
              battle.order = startOrder + i;
              stagedBattles.push(battle);
            });
          } else {
            // Replace
            stagedBattles = data.battles.map((battle, i) => ({
              ...battle,
              id: 'battle-' + Math.random().toString(36).substr(2, 9),
              order: i
            }));
          }

          saveStagedBattles();
          renderQueueList();
          updateTabBadges();

          alert(`Imported ${data.battles.length} battle(s).`);
        } catch (err) {
          console.error('Import failed:', err);
          alert('Failed to import battle queue. Invalid file format.');
        }
      };
      reader.readAsText(file);

      // Reset input
      event.target.value = '';
    }

    function clearQueue() {
      if (stagedBattles.length === 0) return;

      if (!confirm(`Delete all ${stagedBattles.length} staged battle(s)?`)) {
        return;
      }

      stagedBattles = [];
      saveStagedBattles();
      renderQueueList();
      updateTabBadges();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ========== Initialize ==========
    function init() {
      // Load fear
      const storedFear = localStorage.getItem('daggerheart-fear');
      if (storedFear) {
        currentFear = parseInt(storedFear) || 0;
        updateFearDisplay();
      }

      // Load NPC
      const npcData = localStorage.getItem('daggerheart-npc');
      if (npcData) {
        const parsed = JSON.parse(npcData);
        currentNpcImage = parsed.image;
        npcVisible = parsed.visible || false;
        updateNpcPreview();
        document.getElementById('npcVisibilityToggle').checked = npcVisible;
      }

      // Load encounter
      const encounterData = localStorage.getItem('daggerheart-encounter');
      if (encounterData) {
        const parsed = JSON.parse(encounterData);
        currentEncounter = parsed.encounter;
        renderEncounter();
      }

      // Load spotlight
      const spotlightData = localStorage.getItem('daggerheart-spotlight');
      if (spotlightData) {
        const parsed = JSON.parse(spotlightData);
        if (parsed.visible && parsed.adversaryId && currentEncounter) {
          spotlightedAdversary = parsed.adversaryId;
          updateSpotlightUI();
        }
      }

      // Load tokens
      const tokensData = localStorage.getItem('daggerheart-battle-tokens');
      if (tokensData) {
        battleMapTokens = JSON.parse(tokensData);
        renderTokenList();
      }

      // Load adversary database
      loadAdversaryDatabase();

      // Load staged battles
      loadStagedBattles();
      renderQueueList();

      // Initialize PeerJS
      initPeerHost();

      // Render initial state
      renderTokenList();
      updateTabBadges();
    }

    // Start
    init();
  </script>
</body>
</html>
