<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GM Control Panel - Streamlined</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Cinzel', serif;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
    }

    /* Header Bar - Always visible */
    .header-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 15px;
      background: rgba(0,0,0,0.4);
      border-bottom: 1px solid rgba(179, 136, 255, 0.3);
      flex-shrink: 0;
    }

    .header-title {
      font-size: 1rem;
      background: linear-gradient(180deg, #ffd700, #b8860b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .header-btn {
      padding: 6px 12px;
      border: 1px solid rgba(179, 136, 255, 0.4);
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .header-btn:hover {
      background: rgba(179, 136, 255, 0.2);
    }

    .header-btn.connected {
      border-color: #4CAF50;
      color: #4CAF50;
    }

    /* Quick Bar - Fear & Dice always visible */
    .quick-bar {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 10px 15px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      flex-shrink: 0;
    }

    .fear-compact {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .fear-label {
      font-size: 0.7rem;
      color: #888;
    }

    .fear-value {
      font-size: 1.5rem;
      font-weight: 900;
      color: #ffd700;
      min-width: 35px;
      text-align: center;
    }

    .fear-btns {
      display: flex;
      gap: 4px;
    }

    .fear-btn {
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    .fear-btn.add {
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      color: white;
    }

    .fear-btn.remove {
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
    }

    .fear-btn:hover { transform: scale(1.1); }

    /* Countdown Section */
    .countdown-section {
      display: flex;
      align-items: center;
      gap: 8px;
      padding-left: 15px;
      border-left: 1px solid rgba(255,255,255,0.1);
    }

    .countdown-label {
      font-size: 0.7rem;
      color: #888;
    }

    .countdown-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .countdown-select {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      min-width: 100px;
    }

    .countdown-select:focus {
      outline: none;
      border-color: #b388ff;
    }

    .countdown-value {
      font-size: 1.2rem;
      font-weight: 700;
      color: #b388ff;
      min-width: 30px;
      text-align: center;
    }

    .countdown-btn {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 4px;
      font-size: 0.9rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    .countdown-btn.add {
      background: linear-gradient(135deg, #4CAF50, #2e7d32);
      color: white;
    }

    .countdown-btn.remove {
      background: linear-gradient(135deg, #f44336, #c62828);
      color: white;
    }

    .countdown-btn:hover { transform: scale(1.1); }

    .countdown-btn.new-cd {
      width: auto;
      padding: 4px 8px;
      background: linear-gradient(135deg, #b388ff, #7c4dff);
      color: white;
      font-size: 0.7rem;
    }

    .countdown-visibility-btn {
      width: 24px;
      height: 24px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: #888;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .countdown-visibility-btn.visible {
      background: rgba(76, 175, 80, 0.3);
      border-color: #4CAF50;
      color: #4CAF50;
    }

    .countdown-visibility-btn:hover { transform: scale(1.1); }

    .countdown-delete-btn {
      width: 20px;
      height: 20px;
      border: none;
      border-radius: 3px;
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .countdown-delete-btn:hover {
      background: rgba(244, 67, 54, 0.4);
    }

    /* New Countdown Modal */
    .countdown-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .countdown-modal.active {
      display: flex;
    }

    .countdown-modal-content {
      background: #1a1a2e;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      padding: 20px;
      width: 300px;
    }

    .countdown-modal-content h3 {
      margin: 0 0 15px 0;
      color: #b388ff;
      font-size: 1rem;
    }

    .countdown-modal-content label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 5px;
    }

    .countdown-modal-content input,
    .countdown-modal-content select {
      width: 100%;
      padding: 8px;
      margin-bottom: 12px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      box-sizing: border-box;
    }

    .countdown-modal-content input:focus,
    .countdown-modal-content select:focus {
      outline: none;
      border-color: #b388ff;
    }

    .countdown-modal-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .countdown-modal-buttons button {
      flex: 1;
      padding: 8px;
      border: none;
      border-radius: 4px;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .countdown-modal-buttons .cancel-btn {
      background: rgba(255,255,255,0.1);
      color: #888;
    }

    .countdown-modal-buttons .create-btn {
      background: linear-gradient(135deg, #b388ff, #7c4dff);
      color: white;
    }

    .dice-compact {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
    }

    .dice-input {
      width: 100px;
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
    }

    .dice-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .roll-btn {
      padding: 6px 14px;
      border: none;
      border-radius: 4px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      font-weight: 700;
      cursor: pointer;
    }

    .roll-btn:hover { transform: scale(1.05); }

    .quick-dice-btns {
      display: flex;
      gap: 4px;
    }

    .qd-btn {
      padding: 4px 8px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: #aaa;
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      cursor: pointer;
    }

    .qd-btn:hover {
      background: rgba(179, 136, 255, 0.2);
      border-color: #b388ff;
      color: #e0e0e0;
    }

    .last-roll-display {
      padding: 4px 12px;
      background: rgba(0,0,0,0.4);
      border-radius: 4px;
      min-width: 60px;
      text-align: center;
    }

    .last-roll-result {
      font-size: 1.1rem;
      font-weight: 700;
      color: #ffd700;
    }

    /* Tab Navigation */
    .tab-nav {
      display: flex;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      flex-shrink: 0;
    }

    .tab-btn {
      flex: 1;
      padding: 10px 15px;
      border: none;
      background: transparent;
      color: #888;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: #e0e0e0;
      background: rgba(255,255,255,0.05);
    }

    .tab-btn.active {
      color: #ffd700;
      border-bottom-color: #ffd700;
      background: rgba(255,215,0,0.1);
    }

    .tab-badge {
      display: inline-block;
      min-width: 18px;
      height: 18px;
      padding: 0 5px;
      margin-left: 5px;
      background: rgba(255,255,255,0.2);
      border-radius: 9px;
      font-size: 0.7rem;
      line-height: 18px;
      text-align: center;
    }

    .tab-btn.active .tab-badge {
      background: rgba(255,215,0,0.3);
    }

    .tab-badge.updated {
      background: #4CAF50;
      color: white;
      animation: badge-pulse 0.5s ease;
    }

    @keyframes badge-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }

    /* Tab Content */
    .tab-content {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
    }

    .tab-panel {
      display: none;
      height: 100%;
    }

    .tab-panel.active {
      display: block;
    }

    /* Battle Tab */
    .battle-grid {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 15px;
      height: 100%;
    }

    .map-area {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    .map-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .map-header h3 {
      font-size: 0.9rem;
      color: #b388ff;
    }

    .map-controls {
      display: flex;
      gap: 8px;
    }

    .map-btn {
      padding: 5px 10px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: #e0e0e0;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .map-btn:hover {
      background: rgba(255,255,255,0.1);
    }

    .map-btn.active {
      background: rgba(179, 136, 255, 0.3);
      border-color: #b388ff;
    }

    .map-preview-area {
      flex: 1;
      background: rgba(0,0,0,0.4);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 200px;
      position: relative;
      overflow: hidden;
    }

    .map-preview-area img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .map-placeholder {
      color: #666;
      font-size: 0.85rem;
      text-align: center;
    }

    .map-preview-wrapper {
      position: relative;
      display: inline-block;
      max-width: 100%;
      max-height: 100%;
    }

    .map-preview-grid {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .map-preview-token-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .map-preview-token {
      position: absolute;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid #4CAF50;
      background-size: cover;
      background-position: center;
      cursor: pointer;
      pointer-events: auto;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      transform: translate(-50%, -50%);
      z-index: 10;
    }

    .map-preview-token.adversary {
      border-color: #f44336;
    }

    .map-preview-token.hidden-token {
      opacity: 0.5;
      border-style: dashed;
    }

    .map-preview-token.hidden-token::after {
      content: 'üëÅ‚Äçüó®';
      position: absolute;
      top: -8px;
      right: -8px;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .map-preview-token:hover {
      transform: translate(-50%, -50%) scale(1.15);
      z-index: 20;
    }

    .map-preview-token.selected {
      box-shadow: 0 0 0 3px rgba(179, 136, 255, 0.8), 0 0 12px rgba(179, 136, 255, 0.6);
      z-index: 30;
    }

    .map-preview-token .token-label {
      position: absolute;
      bottom: -16px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 9px;
      color: #fff;
      background: rgba(0,0,0,0.7);
      padding: 1px 4px;
      border-radius: 3px;
      white-space: nowrap;
      max-width: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .map-preview-token .token-conditions-mini {
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      gap: 1px;
    }

    .map-preview-token .condition-mini {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      font-size: 7px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
    }

    .map-preview-token .condition-mini.hidden-cond {
      background: linear-gradient(135deg, #666, #444);
    }

    .map-preview-token .condition-mini.restrained-cond {
      background: linear-gradient(135deg, #2196F3, #1565C0);
    }

    .map-preview-token .condition-mini.vulnerable-cond {
      background: linear-gradient(135deg, #f44336, #c62828);
    }

    .position-mode-indicator {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(179, 136, 255, 0.9);
      color: #fff;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .cancel-position-btn {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .cancel-position-btn:hover {
      background: rgba(255,255,255,0.3);
    }

    .map-preview-area.positioning-active {
      cursor: crosshair;
    }

    .map-preview-area.positioning-active .map-preview-token-layer {
      pointer-events: auto;
    }

    .token-area {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    .token-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .token-header h3 {
      font-size: 0.9rem;
      color: #b388ff;
    }

    .add-token-btn {
      padding: 4px 10px;
      border: 1px dashed rgba(76, 175, 80, 0.5);
      border-radius: 4px;
      background: transparent;
      color: #4CAF50;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .add-token-btn:hover {
      background: rgba(76, 175, 80, 0.1);
    }

    .token-list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .token-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      border-left: 3px solid #4CAF50;
    }

    .token-item.adversary {
      border-left-color: #f44336;
    }

    .token-item.hidden-from-players {
      opacity: 0.5;
    }

    .token-thumb {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      overflow: hidden;
    }

    .token-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .token-name {
      flex: 1;
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .token-actions {
      display: flex;
      gap: 4px;
    }

    .token-action-btn {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      color: #aaa;
      font-size: 0.7rem;
      cursor: pointer;
    }

    .token-action-btn:hover {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }

    .token-action-btn.visible-on {
      background: rgba(76, 175, 80, 0.3);
      color: #4CAF50;
    }

    /* Token control buttons for battlemap section */
    .token-controls {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,0.1);
      width: 100%;
    }

    .token-controls-row {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .token-spotlight-btn {
      padding: 3px 8px;
      border: none;
      border-radius: 3px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-family: 'Cinzel', serif;
      font-size: 0.6rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .token-spotlight-btn:hover {
      transform: scale(1.05);
    }

    .token-spotlight-btn.active {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      color: #fff;
    }

    .token-condition-btn {
      padding: 2px 6px;
      border: 1px solid;
      border-radius: 3px;
      background: transparent;
      font-family: 'Cinzel', serif;
      font-size: 0.55rem;
      font-weight: 700;
      cursor: pointer;
      text-transform: uppercase;
    }

    .token-condition-btn.hidden-btn {
      border-color: rgba(106, 90, 205, 0.4);
      color: #9370db;
    }

    .token-condition-btn.hidden-btn.active {
      background: rgba(106, 90, 205, 0.3);
      border-color: #9370db;
    }

    .token-condition-btn.restrained-btn {
      border-color: rgba(112, 128, 144, 0.4);
      color: #b0c4de;
    }

    .token-condition-btn.restrained-btn.active {
      background: rgba(112, 128, 144, 0.3);
      border-color: #b0c4de;
    }

    .token-condition-btn.vulnerable-btn {
      border-color: rgba(218, 165, 32, 0.4);
      color: #ffd700;
    }

    .token-condition-btn.vulnerable-btn.active {
      background: rgba(218, 165, 32, 0.3);
      border-color: #ffd700;
    }

    .token-hp-tracker {
      display: flex;
      align-items: center;
      gap: 4px;
      background: rgba(0,0,0,0.3);
      padding: 2px 6px;
      border-radius: 3px;
    }

    .token-hp-label {
      font-size: 0.55rem;
      color: #ff6b6b;
      text-transform: uppercase;
    }

    .token-hp-btn {
      width: 16px;
      height: 16px;
      border: none;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      color: #ccc;
      font-size: 0.75rem;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .token-hp-btn.minus:hover {
      background: rgba(255,68,68,0.3);
      color: #ff6b6b;
    }

    .token-hp-btn.plus:hover {
      background: rgba(102,187,106,0.3);
      color: #66bb6a;
    }

    .token-hp-value {
      font-size: 0.7rem;
      font-weight: 700;
      color: #ff6b6b;
      min-width: 35px;
      text-align: center;
    }

    .token-hp-value.critical {
      color: #ff4444;
      animation: pulse 1s infinite;
    }

    .token-hp-value.defeated {
      color: #666;
      text-decoration: line-through;
    }

    .token-item.spotlighted {
      border-color: #ffd700;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
    }

    /* Encounter Tab */
    .encounter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .encounter-title {
      font-size: 1rem;
      color: #ffd700;
    }

    .encounter-actions {
      display: flex;
      gap: 8px;
    }

    .encounter-btn {
      padding: 6px 12px;
      border: 1px solid rgba(255,136,0,0.5);
      border-radius: 4px;
      background: transparent;
      color: #ff9800;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .encounter-btn:hover {
      background: rgba(255,136,0,0.1);
    }

    .adversary-search {
      width: 100%;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      margin-bottom: 15px;
    }

    .adversary-search:focus {
      outline: none;
      border-color: #b388ff;
    }

    .adversary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 10px;
    }

    .adversary-card {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .adversary-card.spotlighted {
      border-color: #ffd700;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
    }

    .adv-header {
      display: flex;
      gap: 10px;
      margin-bottom: 8px;
    }

    .adv-portrait {
      width: 50px;
      height: 50px;
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      overflow: hidden;
      cursor: pointer;
      border: 2px solid rgba(255,255,255,0.1);
    }

    .adv-portrait:hover {
      border-color: #b388ff;
    }

    .adv-portrait img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .adv-info {
      flex: 1;
    }

    .adv-name {
      font-size: 0.9rem;
      font-weight: 700;
      margin-bottom: 2px;
    }

    .adv-tier {
      font-size: 0.7rem;
      color: #888;
    }

    .adv-actions {
      display: flex;
      gap: 4px;
    }

    .spotlight-btn {
      padding: 4px 10px;
      border: none;
      border-radius: 4px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-size: 0.7rem;
      font-weight: 700;
      cursor: pointer;
    }

    .spotlight-btn.active {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      color: #fff;
    }

    .adv-trackers {
      display: flex;
      gap: 10px;
      margin-bottom: 8px;
    }

    .tracker {
      flex: 1;
    }

    .tracker-label {
      font-size: 0.65rem;
      color: #888;
      margin-bottom: 3px;
    }

    .tracker-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .tracker-btn {
      width: 22px;
      height: 22px;
      border: none;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      color: #e0e0e0;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .tracker-btn:hover {
      background: rgba(255,255,255,0.2);
    }

    .tracker-value {
      flex: 1;
      text-align: center;
      font-size: 0.85rem;
      font-weight: 700;
    }

    .tracker-value.hp {
      color: #4CAF50;
    }

    .tracker-value.stress {
      color: #ff9800;
    }

    .tracker-value.low {
      color: #f44336;
    }

    .tracker-bar {
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      margin-top: 3px;
      overflow: hidden;
    }

    .tracker-fill {
      height: 100%;
      background: #4CAF50;
      transition: width 0.3s;
    }

    .tracker-fill.stress {
      background: #ff9800;
    }

    .adv-conditions {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .condition-badge {
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.65rem;
      cursor: pointer;
      background: rgba(255,255,255,0.1);
      color: #888;
      border: 1px solid transparent;
    }

    .condition-badge:hover {
      background: rgba(255,255,255,0.15);
    }

    .condition-badge.active {
      border-color: currentColor;
    }

    .condition-badge.hidden.active {
      background: rgba(158,158,158,0.3);
      color: #9e9e9e;
    }

    .condition-badge.restrained.active {
      background: rgba(33,150,243,0.3);
      color: #2196f3;
    }

    .condition-badge.vulnerable.active {
      background: rgba(244,67,54,0.3);
      color: #f44336;
    }

    /* Stat Block Styles */
    .adv-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      margin: 8px 0;
      padding: 8px;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-label {
      font-size: 0.6rem;
      color: #888;
      text-transform: uppercase;
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 0.85rem;
      font-weight: 700;
      color: #e0e0e0;
    }

    .stat-value.attack {
      color: #ef5350;
    }

    .stat-value.defense {
      color: #42a5f5;
    }

    .adv-thresholds {
      display: flex;
      gap: 8px;
      margin: 8px 0;
    }

    .threshold {
      flex: 1;
      padding: 6px;
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
      text-align: center;
    }

    .threshold-label {
      font-size: 0.6rem;
      color: #888;
      text-transform: uppercase;
    }

    .threshold-value {
      font-size: 0.9rem;
      font-weight: 700;
    }

    .threshold.major .threshold-value {
      color: #ffa726;
    }

    .threshold.severe .threshold-value {
      color: #ef5350;
    }

    .adv-traits {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin: 8px 0;
    }

    .trait-tag {
      padding: 2px 8px;
      background: rgba(124, 77, 255, 0.2);
      border: 1px solid rgba(124, 77, 255, 0.4);
      border-radius: 12px;
      font-size: 0.65rem;
      color: #b388ff;
    }

    .adv-abilities {
      margin: 8px 0;
      padding: 8px;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
    }

    .abilities-header {
      font-size: 0.65rem;
      color: #888;
      text-transform: uppercase;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 4px;
    }

    .ability-item {
      font-size: 0.75rem;
      color: #ccc;
      margin-bottom: 6px;
      padding-left: 8px;
      border-left: 2px solid rgba(124, 77, 255, 0.4);
    }

    .ability-item:last-child {
      margin-bottom: 0;
    }

    .ability-name {
      color: #b388ff;
      font-weight: 600;
    }

    .adv-attack-section {
      margin: 8px 0;
      padding: 8px;
      background: rgba(244, 67, 54, 0.1);
      border: 1px solid rgba(244, 67, 54, 0.3);
      border-radius: 6px;
    }

    .attack-header {
      font-size: 0.75rem;
      color: #ff8a80;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .attack-details {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      font-size: 0.75rem;
    }

    .attack-mod {
      color: #fff;
      font-weight: 600;
      background: rgba(244, 67, 54, 0.3);
      padding: 2px 8px;
      border-radius: 4px;
    }

    .attack-damage {
      color: #ffab91;
      font-weight: 500;
    }

    .attack-range {
      color: #888;
      font-style: italic;
    }

    .attack-summary {
      color: #ccc;
    }

    .encounter-empty {
      text-align: center;
      color: #666;
      padding: 40px;
    }

    .hide-spotlight-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: rgba(255,68,68,0.8);
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      display: none;
      z-index: 100;
    }

    .hide-spotlight-btn.visible {
      display: block;
    }

    /* Settings Tab */
    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 15px;
    }

    .settings-section {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 15px;
    }

    .settings-section h3 {
      font-size: 0.9rem;
      color: #b388ff;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(179, 136, 255, 0.2);
    }

    .display-btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 10px;
    }

    .display-btn:hover {
      transform: scale(1.02);
    }

    .display-btn.player {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
      color: white;
    }

    .display-btn.battlemap {
      background: linear-gradient(135deg, #1e88e5, #0d47a1);
      color: white;
    }

    .connection-info {
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      padding: 12px;
      margin-top: 10px;
    }

    .room-code-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .room-code-label {
      font-size: 0.75rem;
      color: #888;
    }

    .room-code-value {
      font-size: 1.1rem;
      font-weight: 700;
      color: #ffd700;
      letter-spacing: 2px;
    }

    .copy-btn {
      padding: 4px 10px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: transparent;
      color: #e0e0e0;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .copy-btn:hover {
      background: rgba(255,255,255,0.1);
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: #888;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #888;
    }

    .status-dot.connected {
      background: #4CAF50;
      box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
    }

    /* NPC Portrait Section */
    .npc-preview-small {
      width: 100%;
      height: 150px;
      background: rgba(0,0,0,0.4);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
      overflow: hidden;
    }

    .npc-preview-small img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .npc-controls {
      display: flex;
      gap: 8px;
    }

    .npc-btn {
      flex: 1;
      padding: 8px;
      border: 1px solid rgba(179, 136, 255, 0.4);
      border-radius: 4px;
      background: transparent;
      color: #b388ff;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .npc-btn:hover {
      background: rgba(179, 136, 255, 0.1);
    }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
      margin-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .toggle-label {
      font-size: 0.8rem;
    }

    .toggle-switch {
      position: relative;
      width: 44px;
      height: 22px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: #333;
      border-radius: 22px;
      transition: all 0.3s;
    }

    .toggle-slider::before {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      left: 2px;
      bottom: 2px;
      background: #888;
      border-radius: 50%;
      transition: all 0.3s;
    }

    .toggle-switch input:checked + .toggle-slider {
      background: linear-gradient(135deg, #4a0e4e, #7c4dff);
    }

    .toggle-switch input:checked + .toggle-slider::before {
      transform: translateX(22px);
      background: #ffd700;
    }

    /* Reference Tab */
    .reference-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 10px;
    }

    .reference-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px 15px;
      flex-shrink: 0;
    }

    .reference-header h3 {
      font-size: 0.9rem;
      color: #b388ff;
      margin: 0;
    }

    .reference-controls {
      display: flex;
      gap: 8px;
    }

    .reference-btn {
      padding: 6px 12px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      background: rgba(179, 136, 255, 0.2);
      color: #e0e0e0;
      font-size: 0.8rem;
      font-family: 'Cinzel', serif;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .reference-btn:hover {
      background: rgba(179, 136, 255, 0.4);
      transform: scale(1.02);
    }

    .reference-pdf-wrapper {
      flex: 1;
      min-height: 0;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      overflow: hidden;
    }

    .reference-pdf-frame {
      width: 100%;
      height: 100%;
      border: none;
      background: #fff;
    }

    /* Reference Sub-tabs */
    .reference-subtabs {
      display: flex;
      gap: 4px;
      margin-bottom: 10px;
    }

    .reference-subtab {
      padding: 8px 16px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px 6px 0 0;
      background: rgba(0,0,0,0.3);
      color: #888;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .reference-subtab:hover {
      background: rgba(255,255,255,0.05);
      color: #e0e0e0;
    }

    .reference-subtab.active {
      background: rgba(179, 136, 255, 0.2);
      border-bottom-color: transparent;
      color: #ffd700;
    }

    .reference-subpanel {
      display: none;
      flex: 1;
      min-height: 0;
    }

    .reference-subpanel.active {
      display: flex;
      flex-direction: column;
    }

    /* Campaign Notes in Reference Tab */
    .campaign-notes-container {
      display: flex;
      flex: 1;
      gap: 15px;
      min-height: 0;
    }

    .notes-sidebar {
      width: 250px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .notes-categories {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .category-btn {
      padding: 8px 12px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px;
      background: rgba(0,0,0,0.3);
      color: #aaa;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      text-align: left;
      transition: all 0.2s;
    }

    .category-btn:hover {
      background: rgba(255,255,255,0.05);
      color: #e0e0e0;
    }

    .category-btn.active {
      background: rgba(179, 136, 255, 0.2);
      border-color: #b388ff;
      color: #e0e0e0;
    }

    .notes-list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
      padding: 8px;
    }

    .note-item {
      padding: 8px 10px;
      border-radius: 4px;
      background: rgba(0,0,0,0.3);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .note-item:hover {
      background: rgba(255,255,255,0.05);
    }

    .note-item.selected {
      background: rgba(179, 136, 255, 0.2);
      border-left: 3px solid #b388ff;
    }

    .note-category-icon {
      color: #b388ff;
      font-size: 0.7rem;
    }

    .note-title {
      flex: 1;
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .add-note-btn {
      padding: 10px;
      border: 1px dashed rgba(179, 136, 255, 0.4);
      border-radius: 6px;
      background: transparent;
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .add-note-btn:hover {
      background: rgba(179, 136, 255, 0.1);
    }

    .notes-editor {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 15px;
    }

    .notes-editor input[type="text"],
    .notes-editor select {
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
    }

    .notes-editor input[type="text"]:focus,
    .notes-editor select:focus {
      outline: none;
      border-color: #b388ff;
    }

    .notes-editor textarea {
      flex: 1;
      padding: 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      resize: none;
      min-height: 200px;
    }

    .notes-editor textarea:focus {
      outline: none;
      border-color: #b388ff;
    }

    .note-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .note-actions button {
      padding: 8px 16px;
      border-radius: 4px;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .note-actions #save-note-btn {
      background: linear-gradient(135deg, #ffd700, #b8860b);
      border: none;
      color: #1a1a2e;
      font-weight: 700;
    }

    .note-actions #delete-note-btn {
      background: transparent;
      border: 1px solid rgba(244, 67, 54, 0.5);
      color: #f44336;
    }

    .notes-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #666;
      text-align: center;
      padding: 40px;
    }

    .notes-empty-icon {
      font-size: 3rem;
      margin-bottom: 15px;
    }

    /* Characters Tab */
    .characters-container {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 15px;
      height: 100%;
    }

    .characters-sidebar {
      display: flex;
      flex-direction: column;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 12px;
    }

    .characters-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .characters-header h3 {
      font-size: 0.9rem;
      color: #4CAF50;
      margin: 0;
    }

    .add-character-btn {
      padding: 5px 10px;
      border: 1px dashed rgba(76, 175, 80, 0.5);
      border-radius: 4px;
      background: transparent;
      color: #4CAF50;
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .add-character-btn:hover {
      background: rgba(76, 175, 80, 0.1);
    }

    .characters-list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .characters-empty {
      color: #666;
      font-size: 0.8rem;
      text-align: center;
      padding: 20px 10px;
    }

    .character-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      border-left: 3px solid #4CAF50;
      cursor: pointer;
      transition: all 0.2s;
    }

    .character-item:hover {
      background: rgba(255,255,255,0.05);
    }

    .character-item.selected {
      background: rgba(76, 175, 80, 0.15);
      border-left-color: #81c784;
    }

    .character-item-portrait {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(0,0,0,0.4);
      overflow: hidden;
      flex-shrink: 0;
    }

    .character-item-portrait img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-item-info {
      flex: 1;
      min-width: 0;
    }

    .character-item-name {
      font-size: 0.85rem;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .character-item-meta {
      font-size: 0.7rem;
      color: #888;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .character-editor {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      overflow-y: auto;
    }

    .character-editor-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #666;
      text-align: center;
      padding: 40px;
    }

    .editor-empty-icon {
      font-size: 3rem;
      margin-bottom: 15px;
      color: #4CAF50;
    }

    .character-editor-form {
      padding: 20px;
    }

    .character-form-header {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .character-portrait-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .character-portrait {
      width: 120px;
      height: 120px;
      border-radius: 8px;
      background: rgba(0,0,0,0.4);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid rgba(76, 175, 80, 0.3);
    }

    .character-portrait img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .portrait-placeholder {
      color: #666;
      font-size: 0.75rem;
    }

    .portrait-upload-btn {
      padding: 6px 12px;
      border: 1px solid rgba(76, 175, 80, 0.5);
      border-radius: 4px;
      background: transparent;
      color: #4CAF50;
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .portrait-upload-btn:hover {
      background: rgba(76, 175, 80, 0.1);
    }

    .character-basic-info {
      flex: 1;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      font-size: 0.75rem;
      color: #888;
      margin-bottom: 4px;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .form-input,
    .form-select {
      width: 100%;
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
    }

    .form-input:focus,
    .form-select:focus {
      outline: none;
      border-color: #4CAF50;
    }

    .form-textarea {
      width: 100%;
      padding: 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      resize: vertical;
      min-height: 100px;
    }

    .form-textarea:focus {
      outline: none;
      border-color: #4CAF50;
    }

    .character-stats-section,
    .character-domain-section,
    .character-experiences-section,
    .character-abilities-section,
    .character-feats-section,
    .character-notes-section {
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .character-stats-section h4,
    .character-domain-section h4,
    .character-experiences-section h4,
    .character-abilities-section h4,
    .character-feats-section h4,
    .character-notes-section h4 {
      font-size: 0.85rem;
      color: #4CAF50;
      margin-bottom: 12px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .stat-box {
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      padding: 10px;
    }

    .stat-box label {
      display: block;
      font-size: 0.7rem;
      color: #888;
      margin-bottom: 6px;
      text-align: center;
    }

    .stat-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .stat-input {
      width: 50px;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      text-align: center;
    }

    .stat-input.single {
      width: 70px;
    }

    .stat-input:focus {
      outline: none;
      border-color: #4CAF50;
    }

    .stat-divider {
      color: #666;
      font-size: 0.9rem;
    }

    .thresholds-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .threshold-box {
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      padding: 10px;
      text-align: center;
    }

    .threshold-box.minor {
      border-left: 3px solid #ffc107;
    }

    .threshold-box.major {
      border-left: 3px solid #ff9800;
    }

    .threshold-box.severe {
      border-left: 3px solid #f44336;
    }

    .threshold-box label {
      display: block;
      font-size: 0.7rem;
      color: #888;
      margin-bottom: 6px;
    }

    .threshold-input {
      width: 60px;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      text-align: center;
    }

    .threshold-input:focus {
      outline: none;
      border-color: #4CAF50;
    }

    .domain-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .domain-checkbox {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .domain-checkbox:hover {
      background: rgba(255,255,255,0.05);
    }

    .domain-checkbox input[type="checkbox"] {
      accent-color: #4CAF50;
    }

    .experiences-list,
    .feats-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 10px;
    }

    .experience-item,
    .feat-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
    }

    .experience-item span,
    .feat-item span {
      flex: 1;
      font-size: 0.85rem;
    }

    .remove-item-btn {
      width: 20px;
      height: 20px;
      border: none;
      border-radius: 50%;
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
      font-size: 0.7rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .remove-item-btn:hover {
      background: rgba(244, 67, 54, 0.4);
    }

    .add-experience-row,
    .add-feat-row {
      display: flex;
      gap: 8px;
    }

    .add-item-btn {
      width: 36px;
      height: 36px;
      border: 1px solid rgba(76, 175, 80, 0.5);
      border-radius: 4px;
      background: transparent;
      color: #4CAF50;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .add-item-btn:hover {
      background: rgba(76, 175, 80, 0.1);
    }

    .abilities-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }

    .ability-card {
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      padding: 12px;
      border-left: 3px solid #b388ff;
    }

    .ability-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .ability-name {
      font-size: 0.9rem;
      font-weight: 700;
      color: #e0e0e0;
    }

    .ability-type {
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 0.65rem;
      text-transform: uppercase;
      background: rgba(179, 136, 255, 0.2);
      color: #b388ff;
    }

    .ability-description {
      font-size: 0.8rem;
      color: #aaa;
      line-height: 1.4;
    }

    .ability-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .add-ability-btn {
      padding: 8px 14px;
      border: 1px dashed rgba(179, 136, 255, 0.4);
      border-radius: 4px;
      background: transparent;
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .add-ability-btn:hover {
      background: rgba(179, 136, 255, 0.1);
    }

    .character-form-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      padding-top: 15px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .save-character-btn {
      padding: 10px 24px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #4CAF50, #388E3C);
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .save-character-btn:hover {
      transform: scale(1.02);
    }

    .delete-character-btn {
      padding: 10px 24px;
      border: 1px solid rgba(244, 67, 54, 0.5);
      border-radius: 6px;
      background: transparent;
      color: #f44336;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .delete-character-btn:hover {
      background: rgba(244, 67, 54, 0.1);
    }

    /* Autocomplete Dropdown */
    .autocomplete-container {
      position: relative;
    }

    .autocomplete-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      background: #2a2a3e;
      border: 1px solid #444;
      border-radius: 0 0 6px 6px;
      z-index: 1000;
      display: none;
    }

    .autocomplete-dropdown.visible {
      display: block;
    }

    .autocomplete-item {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.85rem;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
      background: rgba(179, 136, 255, 0.2);
    }

    .autocomplete-item small {
      color: #888;
      font-size: 0.7rem;
    }

    /* Token Positioning Modal */
    .positioning-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .positioning-modal.visible {
      display: flex;
    }

    .positioning-container {
      background: #1a1a2e;
      border-radius: 12px;
      max-width: 90vw;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .positioning-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      background: rgba(0,0,0,0.3);
    }

    .positioning-title {
      font-size: 0.9rem;
      color: #ffd700;
    }

    .positioning-close {
      background: none;
      border: none;
      color: #888;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .positioning-close:hover {
      color: #fff;
    }

    .positioning-map {
      position: relative;
      overflow: auto;
    }

    .positioning-map img {
      display: block;
      max-width: 80vw;
      max-height: 70vh;
    }

    .positioning-grid {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: auto;
      cursor: crosshair;
    }

    /* Image Dialog */
    .image-dialog-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .image-dialog-overlay.visible {
      display: flex;
    }

    .image-dialog {
      background: #1a1a2e;
      border-radius: 12px;
      padding: 20px;
      max-width: 400px;
      width: 90%;
    }

    .image-dialog h3 {
      margin-bottom: 15px;
      color: #ffd700;
    }

    .image-dialog-options {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 15px;
    }

    .image-dialog-btn {
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      color: #e0e0e0;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s;
    }

    .image-dialog-btn:hover {
      background: rgba(179, 136, 255, 0.1);
      border-color: #b388ff;
    }

    .url-input-section {
      display: none;
      margin-top: 15px;
    }

    .url-input-section.visible {
      display: block;
    }

    .url-input-section label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 5px;
    }

    .url-input-row {
      display: flex;
      gap: 8px;
    }

    .url-input-row input {
      flex: 1;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-size: 0.85rem;
    }

    .url-add-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background: #4CAF50;
      color: white;
      cursor: pointer;
    }

    .url-add-btn:disabled {
      background: #444;
      cursor: not-allowed;
    }

    .url-preview {
      margin-top: 10px;
      max-height: 100px;
      overflow: hidden;
      border-radius: 6px;
    }

    .url-preview img {
      max-width: 100%;
      max-height: 100px;
    }

    .image-dialog-cancel {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: transparent;
      color: #888;
      cursor: pointer;
    }

    /* Image Gallery Browser */
    .image-gallery-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2100;
    }

    .image-gallery-overlay.visible {
      display: flex;
    }

    .image-gallery {
      background: #1a1a2e;
      border-radius: 12px;
      padding: 20px;
      max-width: 700px;
      width: 95%;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }

    .image-gallery h3 {
      margin-bottom: 15px;
      color: #ffd700;
      flex-shrink: 0;
    }

    .image-gallery-loading {
      text-align: center;
      padding: 40px;
      color: #888;
    }

    .image-gallery-empty {
      text-align: center;
      padding: 40px;
      color: #888;
    }

    .image-gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 12px;
      overflow-y: auto;
      padding: 5px;
      flex: 1;
      min-height: 200px;
    }

    .image-gallery-item {
      aspect-ratio: 1;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      position: relative;
      background: #2a2a3e;
    }

    .image-gallery-item:hover {
      border-color: #b388ff;
      transform: scale(1.02);
    }

    .image-gallery-item.selected {
      border-color: #ffd700;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
    }

    .image-gallery-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .image-gallery-item-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.8);
      color: #e0e0e0;
      font-size: 0.65rem;
      padding: 4px;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }

    .image-gallery-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      flex-shrink: 0;
    }

    .image-gallery-select-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      background: #4CAF50;
      color: white;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .image-gallery-select-btn:disabled {
      background: #444;
      cursor: not-allowed;
    }

    .image-gallery-cancel-btn {
      padding: 12px 20px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: transparent;
      color: #888;
      cursor: pointer;
    }

    /* Link to full version */
    .full-version-link {
      text-align: center;
      padding: 15px;
      border-top: 1px solid rgba(255,255,255,0.1);
      margin-top: 15px;
    }

    .full-version-link a {
      color: #888;
      font-size: 0.8rem;
      text-decoration: none;
    }

    .full-version-link a:hover {
      color: #b388ff;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.2);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.3);
    }

    /* Battle Queue Styles */
    .queue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .queue-title {
      font-size: 1rem;
      color: #ffd700;
    }

    .queue-actions {
      display: flex;
      gap: 8px;
    }

    .queue-btn {
      padding: 6px 12px;
      border: 1px solid rgba(76, 175, 80, 0.5);
      border-radius: 4px;
      background: transparent;
      color: #4CAF50;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .queue-btn:hover {
      background: rgba(76, 175, 80, 0.1);
    }

    .queue-btn.primary {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      border-color: transparent;
      color: white;
    }

    .queue-btn.primary:hover {
      transform: scale(1.02);
    }

    .queue-btn.danger {
      border-color: rgba(244, 67, 54, 0.5);
      color: #f44336;
    }

    .queue-btn.danger:hover {
      background: rgba(244, 67, 54, 0.1);
    }

    .queue-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .queue-empty {
      text-align: center;
      color: #666;
      padding: 40px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      border: 2px dashed rgba(255,255,255,0.1);
    }

    .queue-empty-icon {
      font-size: 2rem;
      margin-bottom: 10px;
      opacity: 0.5;
    }

    .staged-battle-card {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
      overflow: hidden;
      transition: all 0.2s;
    }

    .staged-battle-card:hover {
      border-color: rgba(179, 136, 255, 0.4);
    }

    .staged-battle-card.drag-over {
      border-color: #ffd700;
      background: rgba(255, 215, 0, 0.1);
    }

    .staged-battle-header {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      background: rgba(0,0,0,0.2);
      cursor: grab;
    }

    .staged-battle-header:active {
      cursor: grabbing;
    }

    .staged-battle-order {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      font-weight: 700;
      margin-right: 10px;
      flex-shrink: 0;
    }

    .staged-battle-info {
      flex: 1;
      min-width: 0;
    }

    .staged-battle-name {
      font-size: 0.9rem;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .staged-battle-meta {
      font-size: 0.7rem;
      color: #888;
      display: flex;
      gap: 10px;
      margin-top: 2px;
    }

    .staged-battle-actions {
      display: flex;
      gap: 4px;
    }

    .staged-action-btn {
      padding: 6px 10px;
      border: none;
      border-radius: 4px;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .staged-action-btn.load {
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-weight: 700;
    }

    .staged-action-btn.load:hover {
      transform: scale(1.05);
    }

    .staged-action-btn.preview {
      background: rgba(179, 136, 255, 0.2);
      color: #b388ff;
    }

    .staged-action-btn.edit {
      background: rgba(255,255,255,0.1);
      color: #aaa;
    }

    .staged-action-btn.delete {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }

    .staged-battle-preview {
      display: none;
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,0.05);
    }

    .staged-battle-preview.visible {
      display: block;
    }

    .preview-grid {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 10px;
    }

    .preview-map {
      width: 120px;
      height: 80px;
      background: rgba(0,0,0,0.4);
      border-radius: 4px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .preview-map img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .preview-map-placeholder {
      color: #555;
      font-size: 0.7rem;
    }

    .preview-details {
      font-size: 0.75rem;
    }

    .preview-section {
      margin-bottom: 6px;
    }

    .preview-section-title {
      color: #888;
      font-size: 0.65rem;
      margin-bottom: 2px;
    }

    .preview-adversaries {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .preview-adv-tag {
      padding: 2px 6px;
      background: rgba(244, 67, 54, 0.2);
      border-radius: 3px;
      font-size: 0.65rem;
      color: #f44336;
    }

    .preview-tokens {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .preview-token-tag {
      padding: 2px 6px;
      background: rgba(76, 175, 80, 0.2);
      border-radius: 3px;
      font-size: 0.65rem;
      color: #4CAF50;
    }

    .preview-token-tag.adversary {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }

    .preview-notes {
      color: #aaa;
      font-style: italic;
      max-height: 40px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Stage Battle Modal */
    .stage-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .stage-modal.visible {
      display: flex;
    }

    .stage-modal-content {
      background: #1a1a2e;
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .stage-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .stage-modal-title {
      font-size: 1rem;
      color: #ffd700;
    }

    .stage-modal-close {
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      color: #aaa;
      font-size: 1rem;
      cursor: pointer;
    }

    .stage-modal-body {
      padding: 15px;
    }

    .stage-form-group {
      margin-bottom: 15px;
    }

    .stage-form-label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 6px;
    }

    .stage-form-input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
    }

    .stage-form-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .stage-form-textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      resize: vertical;
      min-height: 80px;
    }

    .stage-form-textarea:focus {
      outline: none;
      border-color: #b388ff;
    }

    .stage-summary {
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 15px;
    }

    .stage-summary-title {
      font-size: 0.75rem;
      color: #888;
      margin-bottom: 8px;
    }

    .stage-summary-item {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      padding: 4px 0;
    }

    .stage-summary-value {
      color: #ffd700;
    }

    .stage-modal-footer {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      padding: 15px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .stage-cancel-btn {
      padding: 10px 20px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: transparent;
      color: #aaa;
      font-family: 'Cinzel', serif;
      cursor: pointer;
    }

    .stage-save-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: white;
      font-family: 'Cinzel', serif;
      font-weight: 700;
      cursor: pointer;
    }

    /* Settings Modal Styles */
    .delete-account-btn {
      padding: 10px 20px;
      border: 1px solid #f44336;
      border-radius: 6px;
      background: transparent;
      color: #f44336;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .delete-account-btn:hover {
      background: rgba(244, 67, 54, 0.1);
    }

    .stage-btn {
      padding: 10px 20px;
      border-radius: 6px;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .stage-btn.cancel {
      border: 1px solid rgba(255,255,255,0.2);
      background: transparent;
      color: #aaa;
    }

    .stage-btn.delete {
      border: none;
      background: #f44336;
      color: white;
      font-weight: 700;
    }

    .stage-btn.delete:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .stage-btn.delete:not(:disabled):hover {
      background: #d32f2f;
    }

    .stage-save-btn:hover {
      transform: scale(1.02);
    }

    /* PC Selection Dialog */
    .pc-selection-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 250px;
      overflow-y: auto;
    }

    .pc-selection-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.2s;
    }

    .pc-selection-item:hover {
      background: rgba(76, 175, 80, 0.15);
      border-color: rgba(76, 175, 80, 0.3);
    }

    .pc-selection-item .pc-portrait {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(0,0,0,0.4);
      overflow: hidden;
      flex-shrink: 0;
    }

    .pc-selection-item .pc-portrait img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .pc-selection-item .pc-info {
      flex: 1;
    }

    .pc-selection-item .pc-name {
      font-weight: 700;
      font-size: 0.9rem;
    }

    .pc-selection-item .pc-meta {
      font-size: 0.75rem;
      color: #888;
    }

    .pc-selection-item .pc-add-btn {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background: linear-gradient(135deg, #4CAF50, #388E3C);
      color: white;
      font-size: 0.75rem;
      font-family: 'Cinzel', serif;
      cursor: pointer;
    }

    .pc-selection-item .pc-add-btn:hover {
      transform: scale(1.05);
    }

    .pc-selection-divider {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 15px 0;
      color: #666;
      font-size: 0.8rem;
    }

    .pc-selection-divider::before,
    .pc-selection-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: rgba(255,255,255,0.1);
    }

    .pc-selection-empty {
      text-align: center;
      color: #666;
      padding: 20px;
      font-size: 0.85rem;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .battle-grid {
        grid-template-columns: 1fr;
      }

      .quick-bar {
        flex-wrap: wrap;
      }

      .dice-compact {
        width: 100%;
        order: 1;
      }

      .quick-dice-btns {
        display: none;
      }

      .preview-grid {
        grid-template-columns: 1fr;
      }

      .preview-map {
        width: 100%;
        height: 100px;
      }
    }

    /* Auth & Cloud Features */
    .auth-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 10px;
      padding-left: 10px;
      border-left: 1px solid rgba(179, 136, 255, 0.3);
    }

    .auth-btn {
      padding: 6px 12px;
      border: 1px solid rgba(179, 136, 255, 0.4);
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .auth-btn:hover {
      background: rgba(179, 136, 255, 0.2);
    }

    .user-menu {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .user-menu .user-name {
      font-size: 0.75rem;
      color: #888;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tier-badge {
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 4px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-weight: bold;
    }

    .tier-badge.demo {
      background: rgba(255,255,255,0.2);
      color: #888;
    }

    .hidden {
      display: none !important;
    }

    /* Campaign Manager */
    .campaign-manager {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 15px;
      background: rgba(0,0,0,0.2);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .campaign-row, .scene-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .campaign-manager select {
      flex: 1;
      max-width: 200px;
      padding: 6px 10px;
      border: 1px solid rgba(179, 136, 255, 0.4);
      border-radius: 6px;
      background: rgba(0,0,0,0.3);
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
    }

    .campaign-manager select:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .campaign-manager button {
      padding: 6px 10px;
      border: 1px solid rgba(179, 136, 255, 0.4);
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .campaign-manager button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .campaign-manager button:hover:not(:disabled) {
      background: rgba(179, 136, 255, 0.2);
    }

    .campaign-manager button.delete-btn {
      color: #f44336;
      border-color: rgba(244, 67, 54, 0.4);
    }

    .campaign-manager button.delete-btn:hover:not(:disabled) {
      background: rgba(244, 67, 54, 0.2);
    }

    .save-status {
      font-size: 0.7rem;
      color: #888;
    }

    .save-status.saved {
      color: #4CAF50;
    }

    .save-status.saving {
      color: #ffd700;
    }

    /* Upgrade Prompt */
    .upgrade-prompt {
      padding: 10px 15px;
      background: rgba(179, 136, 255, 0.1);
      border-bottom: 1px solid rgba(179, 136, 255, 0.3);
      text-align: center;
    }

    .upgrade-prompt p {
      font-size: 0.8rem;
      color: #b388ff;
      margin-bottom: 8px;
    }

    .upgrade-prompt button {
      padding: 6px 16px;
      border: 1px solid #ffd700;
      border-radius: 6px;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(184, 134, 11, 0.2));
      color: #ffd700;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .upgrade-prompt button:hover {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(184, 134, 11, 0.3));
    }

    /* Notes Panel */
    .notes-container {
      display: flex;
      height: 100%;
      gap: 15px;
    }

    .notes-sidebar {
      width: 200px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .notes-categories {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .category-btn {
      padding: 8px 12px;
      border: 1px solid rgba(179, 136, 255, 0.3);
      border-radius: 6px;
      background: rgba(0,0,0,0.2);
      color: #888;
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      cursor: pointer;
      text-align: left;
      transition: all 0.2s;
    }

    .category-btn:hover, .category-btn.active {
      background: rgba(179, 136, 255, 0.1);
      color: #b388ff;
    }

    .notes-list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .note-item {
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      background: rgba(0,0,0,0.2);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .note-item:hover, .note-item.selected {
      background: rgba(179, 136, 255, 0.1);
      border-color: rgba(179, 136, 255, 0.3);
    }

    .note-category-icon {
      color: #b388ff;
      font-size: 0.7rem;
    }

    .note-title {
      font-size: 0.75rem;
      color: #e0e0e0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .add-note-btn {
      padding: 10px;
      border: 1px dashed rgba(179, 136, 255, 0.4);
      border-radius: 6px;
      background: transparent;
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .add-note-btn:hover {
      background: rgba(179, 136, 255, 0.1);
    }

    .notes-editor {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .notes-editor input,
    .notes-editor select {
      padding: 10px;
      border: 1px solid rgba(179, 136, 255, 0.3);
      border-radius: 6px;
      background: rgba(0,0,0,0.3);
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
    }

    .notes-editor textarea {
      flex: 1;
      padding: 12px;
      border: 1px solid rgba(179, 136, 255, 0.3);
      border-radius: 6px;
      background: rgba(0,0,0,0.3);
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      resize: none;
    }

    .note-actions {
      display: flex;
      gap: 10px;
    }

    .note-actions button {
      flex: 1;
      padding: 10px;
      border: 1px solid rgba(179, 136, 255, 0.4);
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      color: #b388ff;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .note-actions button:hover {
      background: rgba(179, 136, 255, 0.2);
    }

    #delete-note-btn {
      border-color: rgba(198, 40, 40, 0.4);
      color: #ef5350;
    }

    #delete-note-btn:hover {
      background: rgba(198, 40, 40, 0.2);
    }

    /* Loot Generator Styles */
    .loot-container {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }

    .loot-header {
      margin-bottom: 20px;
    }

    .loot-header h3 {
      font-size: 1.3rem;
      color: #ffd700;
      margin-bottom: 5px;
    }

    .loot-subtitle {
      font-size: 0.85rem;
      color: #888;
    }

    .loot-controls {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .loot-control-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 15px;
      margin-bottom: 15px;
    }

    .loot-control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .loot-label {
      font-size: 0.75rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .loot-select {
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid rgba(179, 136, 255, 0.3);
      background: rgba(0,0,0,0.3);
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .loot-select:focus {
      outline: none;
      border-color: #b388ff;
    }

    .loot-actions {
      display: flex;
      gap: 10px;
    }

    .loot-generate-btn {
      flex: 1;
      padding: 12px 20px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      color: #1a1a2e;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .loot-generate-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
    }

    .loot-clear-btn {
      padding: 12px 20px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: transparent;
      color: #888;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .loot-clear-btn:hover {
      border-color: rgba(255,255,255,0.4);
      color: #e0e0e0;
    }

    .loot-results {
      min-height: 200px;
      margin-bottom: 20px;
    }

    .loot-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: #666;
      text-align: center;
    }

    .loot-empty-icon {
      font-size: 3rem;
      margin-bottom: 10px;
      opacity: 0.5;
    }

    .loot-empty-hint {
      font-size: 0.8rem;
      margin-top: 8px;
      color: #555;
    }

    .loot-items-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 15px;
    }

    .loot-card {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 15px;
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.2s;
    }

    .loot-card:hover {
      border-color: rgba(255,215,0,0.3);
    }

    .loot-card.common {
      border-left: 3px solid #9e9e9e;
    }

    .loot-card.uncommon {
      border-left: 3px solid #4CAF50;
    }

    .loot-card.rare {
      border-left: 3px solid #2196F3;
    }

    .loot-card.legendary {
      border-left: 3px solid #ffd700;
    }

    .loot-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }

    .loot-card-name {
      font-size: 1rem;
      font-weight: 700;
      color: #e0e0e0;
    }

    .loot-card-meta {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .loot-card-type {
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 3px;
      background: rgba(179, 136, 255, 0.2);
      color: #b388ff;
      text-transform: uppercase;
    }

    .loot-card-roll {
      font-size: 0.7rem;
      color: #666;
    }

    .loot-card-rarity {
      font-size: 0.7rem;
      padding: 2px 8px;
      border-radius: 10px;
      text-transform: capitalize;
    }

    .loot-card-rarity.common {
      background: rgba(158, 158, 158, 0.2);
      color: #9e9e9e;
    }

    .loot-card-rarity.uncommon {
      background: rgba(76, 175, 80, 0.2);
      color: #4CAF50;
    }

    .loot-card-rarity.rare {
      background: rgba(33, 150, 243, 0.2);
      color: #2196F3;
    }

    .loot-card-rarity.legendary {
      background: rgba(255, 215, 0, 0.2);
      color: #ffd700;
    }

    .loot-card-description {
      font-size: 0.85rem;
      color: #aaa;
      line-height: 1.5;
    }

    /* Loot Card Type Icons */
    .loot-type-icon {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .loot-type-icon svg {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
    }

    .loot-type-icon.consumable svg {
      fill: #b388ff;
    }

    .loot-type-icon.treasure svg {
      fill: #ffd700;
    }

    /* Loot Card Actions */
    .loot-card-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.05);
    }

    .loot-print-btn {
      background: rgba(255,215,0,0.1);
      border: 1px solid rgba(255,215,0,0.3);
      border-radius: 4px;
      padding: 6px 10px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      color: #ffd700;
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      transition: all 0.2s;
    }

    .loot-print-btn:hover {
      background: rgba(255,215,0,0.2);
      border-color: rgba(255,215,0,0.5);
      transform: translateY(-1px);
    }

    .loot-print-btn svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
    }

    /* Equipment Search in Loot Tab */
    .equipment-search-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .equipment-search-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .equipment-search-title {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      color: #b388ff;
    }

    .equipment-filters {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .equipment-filter-select {
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
    }

    .equipment-filter-select:focus {
      outline: none;
      border-color: #b388ff;
    }

    .equipment-search-container {
      position: relative;
    }

    .equipment-search-input {
      width: 100%;
      padding: 10px 14px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a3e;
      color: #e0e0e0;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
    }

    .equipment-search-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .equipment-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: #2a2a3e;
      border: 1px solid #444;
      border-radius: 0 0 6px 6px;
      z-index: 1000;
      display: none;
    }

    .equipment-dropdown.visible {
      display: block;
    }

    .equipment-item {
      padding: 10px 14px;
      cursor: pointer;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      transition: background 0.2s;
    }

    .equipment-item:hover,
    .equipment-item.selected {
      background: rgba(179, 136, 255, 0.2);
    }

    .equipment-item-name {
      font-size: 0.9rem;
      font-weight: bold;
      color: #e0e0e0;
    }

    .equipment-item-meta {
      font-size: 0.75rem;
      color: #888;
      margin-top: 2px;
    }

    .equipment-item-type {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 3px;
      font-size: 0.65rem;
      text-transform: uppercase;
      margin-right: 6px;
    }

    .equipment-item-type.weapon {
      background: rgba(255, 87, 34, 0.2);
      color: #ff5722;
    }

    .equipment-item-type.armor {
      background: rgba(33, 150, 243, 0.2);
      color: #2196f3;
    }

    .equipment-item-type.secondary {
      background: rgba(156, 39, 176, 0.2);
      color: #9c27b0;
    }

    /* Equipment Card Styling */
    .loot-card.equipment {
      border-left: 3px solid #ff9800;
    }

    .loot-card.weapon {
      border-left: 3px solid #ff5722;
    }

    .loot-card.armor {
      border-left: 3px solid #2196f3;
    }

    .loot-card.secondary {
      border-left: 3px solid #9c27b0;
    }

    .equipment-card-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
      margin: 8px 0;
      font-size: 0.75rem;
    }

    .equipment-stat {
      display: flex;
      justify-content: space-between;
      padding: 4px 8px;
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
    }

    .equipment-stat-label {
      color: #888;
    }

    .equipment-stat-value {
      color: #e0e0e0;
      font-weight: bold;
    }

    .equipment-feature {
      margin-top: 8px;
      padding: 8px;
      background: rgba(179, 136, 255, 0.1);
      border-radius: 4px;
      border-left: 2px solid #b388ff;
    }

    .equipment-feature-name {
      font-weight: bold;
      color: #b388ff;
      font-size: 0.8rem;
    }

    .equipment-feature-desc {
      font-size: 0.75rem;
      color: #aaa;
      margin-top: 2px;
    }

    .loot-type-icon.weapon svg,
    .loot-type-icon.primary_weapon svg {
      fill: #ff5722;
    }

    .loot-type-icon.armor svg {
      fill: #2196f3;
    }

    .loot-type-icon.secondary_weapon svg,
    .loot-type-icon.secondary svg {
      fill: #9c27b0;
    }

    .loot-remove-btn {
      background: rgba(244, 67, 54, 0.1);
      border: 1px solid rgba(244, 67, 54, 0.3);
      border-radius: 4px;
      padding: 6px 10px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      color: #f44336;
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      transition: all 0.2s;
      margin-left: 8px;
    }

    .loot-remove-btn:hover {
      background: rgba(244, 67, 54, 0.2);
      border-color: rgba(244, 67, 54, 0.5);
    }

    /* Print Card Modal */
    .print-card-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .print-card-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .print-card-modal {
      background: #1a1a2e;
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      width: 90%;
      border: 2px solid rgba(255,215,0,0.3);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }

    .print-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .print-card-title {
      font-family: 'Cinzel', serif;
      font-size: 1.2rem;
      color: #ffd700;
    }

    .print-card-close {
      background: none;
      border: none;
      color: #666;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      transition: color 0.2s;
    }

    .print-card-close:hover {
      color: #fff;
    }

    /* Playing Card Style */
    .playing-card {
      width: 250px;
      height: 350px;
      background: linear-gradient(145deg, #2d2d44 0%, #1a1a2e 100%);
      border-radius: 12px;
      border: 3px solid;
      margin: 0 auto 20px;
      padding: 15px;
      display: flex;
      flex-direction: column;
      position: relative;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }

    .playing-card.common {
      border-color: #9e9e9e;
    }

    .playing-card.uncommon {
      border-color: #4CAF50;
    }

    .playing-card.rare {
      border-color: #2196F3;
    }

    .playing-card.legendary {
      border-color: #ffd700;
      box-shadow: 0 8px 32px rgba(255,215,0,0.2);
    }

    .playing-card-corner {
      position: absolute;
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      color: rgba(255,255,255,0.5);
    }

    .playing-card-corner.top-left {
      top: 8px;
      left: 10px;
    }

    .playing-card-corner.bottom-right {
      bottom: 8px;
      right: 10px;
      transform: rotate(180deg);
    }

    .playing-card-type-icon {
      width: 50px;
      height: 50px;
      margin: 10px auto 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.3);
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.1);
    }

    .playing-card-type-icon svg {
      width: 28px;
      height: 28px;
    }

    .playing-card-type-icon.consumable svg {
      fill: #b388ff;
    }

    .playing-card-type-icon.treasure svg {
      fill: #ffd700;
    }

    .playing-card-type-icon.primary_weapon svg {
      fill: #ff5722;
    }

    .playing-card-type-icon.secondary_weapon svg {
      fill: #9c27b0;
    }

    .playing-card-type-icon.armor svg {
      fill: #2196f3;
    }

    .playing-card-name {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      font-weight: 700;
      text-align: center;
      color: #e0e0e0;
      margin-bottom: 8px;
      line-height: 1.2;
    }

    .playing-card-rarity {
      text-align: center;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 12px;
      padding: 4px 12px;
      border-radius: 10px;
      width: fit-content;
      margin-left: auto;
      margin-right: auto;
    }

    .playing-card-rarity.common {
      background: rgba(158, 158, 158, 0.2);
      color: #9e9e9e;
    }

    .playing-card-rarity.uncommon {
      background: rgba(76, 175, 80, 0.2);
      color: #4CAF50;
    }

    .playing-card-rarity.rare {
      background: rgba(33, 150, 243, 0.2);
      color: #2196F3;
    }

    .playing-card-rarity.legendary {
      background: rgba(255, 215, 0, 0.2);
      color: #ffd700;
    }

    .playing-card-divider {
      width: 60%;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255,215,0,0.3), transparent);
      margin: 0 auto 12px;
    }

    .playing-card-description {
      font-size: 0.75rem;
      color: #aaa;
      line-height: 1.5;
      text-align: center;
      flex-grow: 1;
      overflow-y: auto;
      padding: 0 5px;
    }

    .playing-card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
      font-size: 0.65rem;
      color: #666;
    }

    .print-card-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .print-card-btn {
      padding: 10px 20px;
      border-radius: 6px;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .print-card-btn.primary {
      background: linear-gradient(135deg, #ffd700, #b8860b);
      border: none;
      color: #1a1a2e;
      font-weight: 600;
    }

    .print-card-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255,215,0,0.3);
    }

    .print-card-btn.secondary {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.2);
      color: #aaa;
    }

    .print-card-btn.secondary:hover {
      border-color: rgba(255,255,255,0.4);
      color: #fff;
    }

    /* Print-specific styles */
    @media print {
      body * {
        visibility: hidden;
      }

      .print-card-overlay,
      .print-card-overlay * {
        visibility: visible;
      }

      .print-card-overlay {
        position: absolute;
        left: 0;
        top: 0;
        background: white;
      }

      .print-card-modal {
        box-shadow: none;
        border: none;
        background: white;
      }

      .print-card-header,
      .print-card-actions {
        display: none;
      }

      .playing-card {
        background: white;
        box-shadow: none;
        border-width: 2px;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }

      .playing-card-name,
      .playing-card-description {
        color: #333;
      }
    }

    .loot-reference {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.05);
      overflow: hidden;
    }

    .loot-reference-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      cursor: pointer;
      color: #888;
      font-size: 0.85rem;
      transition: all 0.2s;
    }

    .loot-reference-header:hover {
      background: rgba(255,255,255,0.05);
      color: #aaa;
    }

    .loot-reference-toggle {
      transition: transform 0.2s;
    }

    .loot-reference-toggle.open {
      transform: rotate(180deg);
    }

    .loot-reference-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .loot-reference-content.open {
      max-height: 200px;
    }

    .rarity-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      padding: 0 15px 15px;
    }

    .rarity-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border-radius: 4px;
      background: rgba(0,0,0,0.2);
    }

    .rarity-item.common .rarity-name {
      color: #9e9e9e;
    }

    .rarity-item.uncommon .rarity-name {
      color: #4CAF50;
    }

    .rarity-item.rare .rarity-name {
      color: #2196F3;
    }

    .rarity-item.legendary .rarity-name {
      color: #ffd700;
    }

    .rarity-name {
      font-weight: 700;
      font-size: 0.85rem;
    }

    .rarity-range {
      font-size: 0.75rem;
      color: #666;
    }
  </style>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <script>
    // ===========================================
    // FIREBASE CONFIGURATION
    // ===========================================
    // To set up Firebase:
    // 1. Go to https://console.firebase.google.com/
    // 2. Create a new project (or use existing)
    // 3. Go to Project Settings > General > Your apps
    // 4. Click "Add app" and select Web (</>)
    // 5. Copy your config values below
    // 6. Go to Realtime Database > Create Database
    // 7. Start in TEST MODE for now (allows read/write)
    // ===========================================
    const firebaseConfig = {
      apiKey: "AIzaSyA6GYyYWlW1ybQ07-K13u4YUaNFcV66Zj0",
      authDomain: "daggerheart-8bdc1.firebaseapp.com",
      databaseURL: "https://daggerheart-8bdc1-default-rtdb.firebaseio.com",
      projectId: "daggerheart-8bdc1",
      storageBucket: "daggerheart-8bdc1.firebasestorage.app",
      messagingSenderId: "885297626381",
      appId: "1:885297626381:web:9caf2af85fb793f819c444"
    };

    // Initialize Firebase
    let firebaseApp = null;
    let database = null;

    try {
      firebaseApp = firebase.initializeApp(firebaseConfig);
      database = firebase.database();
      console.log('Firebase initialized successfully');
    } catch (e) {
      console.error('Firebase initialization error:', e);
    }

    // Cleanup stale rooms from the database
    // Runs automatically when GM panel loads to remove old abandoned rooms
    async function cleanupStaleRooms() {
      if (!database) {
        console.log('Firebase not available for cleanup');
        return;
      }

      const STALE_THRESHOLD_HOURS = 24; // Rooms older than 24 hours with inactive GM
      const STALE_THRESHOLD_MS = STALE_THRESHOLD_HOURS * 60 * 60 * 1000;
      const now = Date.now();

      try {
        const roomsSnapshot = await database.ref('rooms').once('value');
        const rooms = roomsSnapshot.val();

        if (!rooms) {
          console.log('No rooms to cleanup');
          return;
        }

        let deletedCount = 0;
        const deletePromises = [];

        for (const [roomCode, roomData] of Object.entries(rooms)) {
          const gmData = roomData?.gm;

          // Delete room if:
          // 1. No GM data exists, or
          // 2. GM is not active AND timestamp is older than threshold, or
          // 3. GM timestamp is older than threshold (regardless of active status - they crashed)
          const shouldDelete =
            !gmData ||
            (!gmData.active && gmData.timestamp && (now - gmData.timestamp) > STALE_THRESHOLD_MS) ||
            (gmData.timestamp && (now - gmData.timestamp) > STALE_THRESHOLD_MS);

          if (shouldDelete) {
            deletePromises.push(
              database.ref('rooms/' + roomCode).remove()
                .then(() => {
                  deletedCount++;
                  console.log(`Cleaned up stale room: ${roomCode}`);
                })
                .catch(err => console.error(`Failed to delete room ${roomCode}:`, err))
            );
          }
        }

        await Promise.all(deletePromises);

        if (deletedCount > 0) {
          console.log(`Room cleanup complete: ${deletedCount} stale room(s) removed`);
        } else {
          console.log('Room cleanup complete: no stale rooms found');
        }
      } catch (e) {
        console.error('Error during room cleanup:', e);
      }
    }

    // Run cleanup when page loads
    if (database) {
      cleanupStaleRooms();
    }
  </script>
</head>
<body>
  <!-- Header Bar -->
  <div class="header-bar">
    <div class="header-title">GM Control Panel</div>
    <div class="header-actions">
      <a href="encounter-generator.html" class="header-btn" style="text-decoration: none;" title="Build encounters">Encounter Builder</a>
      <span id="connectionStatusText" style="font-size: 0.7rem; color: #888;">Initializing...</span>
      <button class="header-btn" id="connectionBtn" onclick="copyRoomCode()">Room: ----</button>
      <!-- Auth UI -->
      <div id="auth-container" class="auth-container">
        <button id="login-btn" class="auth-btn">Sign In</button>
        <div id="user-menu" class="user-menu hidden">
          <span id="user-name" class="user-name"></span>
          <span id="user-tier" class="tier-badge demo">DEMO</span>
          <button id="settings-btn" class="auth-btn" onclick="openSettingsModal()" title="Account Settings">&#9881;</button>
          <button id="logout-btn" class="auth-btn">Sign Out</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Campaign Manager (shown for authenticated users with campaigns feature) -->
  <div id="campaign-manager" class="campaign-manager hidden" data-requires="campaigns">
    <div class="campaign-row">
      <select id="campaign-select">
        <option value="">Select Campaign...</option>
      </select>
      <button id="new-campaign-btn" onclick="window.cloudFeatures?.createNewCampaign()" title="New Campaign">+</button>
      <button id="delete-campaign-btn" onclick="window.cloudFeatures?.deleteCampaign()" title="Delete Campaign" disabled class="delete-btn">√ó</button>
    </div>
    <div class="scene-row">
      <select id="scene-select" disabled>
        <option value="">Select Scene...</option>
      </select>
      <button id="new-scene-btn" onclick="window.cloudFeatures?.createNewScene()" title="New Scene" disabled>+</button>
      <button id="save-scene-btn" onclick="window.cloudFeatures?.saveScene()" title="Save Scene" disabled>Save</button>
      <button id="delete-scene-btn" onclick="window.cloudFeatures?.deleteScene()" title="Delete Scene" disabled class="delete-btn">√ó</button>
    </div>
    <span id="save-status" class="save-status"></span>
  </div>

  <!-- Upgrade Prompt (shown for demo users) -->
  <div id="upgrade-prompt" class="upgrade-prompt hidden" data-upgrade-prompt>
    <p>Sign in and upgrade to save your campaigns and scenes to the cloud.</p>
    <button id="upgrade-btn">Learn More</button>
  </div>

  <!-- Quick Bar - Always Visible -->
  <div class="quick-bar">
    <div class="fear-compact">
      <span class="fear-label">FEAR</span>
      <div class="fear-btns">
        <button class="fear-btn remove" onclick="adjustFear(-1)">-</button>
      </div>
      <div class="fear-value" id="fearDisplay">0</div>
      <div class="fear-btns">
        <button class="fear-btn add" onclick="adjustFear(1)">+</button>
      </div>
    </div>

    <div class="countdown-section">
      <span class="countdown-label">COUNTDOWN</span>
      <div class="countdown-controls">
        <select class="countdown-select" id="countdownSelect" onchange="selectCountdown()">
          <option value="">-- None --</option>
        </select>
        <button class="countdown-btn remove" onclick="adjustCountdown(-1)">-</button>
        <div class="countdown-value" id="countdownValue">-</div>
        <button class="countdown-btn add" onclick="adjustCountdown(1)">+</button>
        <button class="countdown-visibility-btn" id="countdownVisBtn" onclick="toggleCountdownVisibility()" title="Toggle player visibility">V</button>
        <button class="countdown-delete-btn" onclick="deleteSelectedCountdown()" title="Delete countdown">X</button>
        <button class="countdown-btn new-cd" onclick="openNewCountdownModal()">+ New</button>
      </div>
    </div>

    <div class="dice-compact">
      <input type="text" class="dice-input" id="diceNotation" placeholder="1d20+5" value="1d20">
      <button class="roll-btn" onclick="rollNotation()">Roll</button>
      <div class="quick-dice-btns">
        <button class="qd-btn" onclick="setNotation('1d20')">d20</button>
        <button class="qd-btn" onclick="setNotation('2d6')">2d6</button>
        <button class="qd-btn" onclick="setNotation('1d12')">d12</button>
        <button class="qd-btn" onclick="rollHopeFear()">H/F</button>
      </div>
      <div class="last-roll-display">
        <div class="last-roll-result" id="lastRoll">-</div>
      </div>
    </div>
  </div>

  <!-- Tab Navigation -->
  <div class="tab-nav">
    <button class="tab-btn active" onclick="switchTab('battle')">Battle <span class="tab-badge" id="battleBadge">0</span></button>
    <button class="tab-btn" onclick="switchTab('encounter')">Encounter <span class="tab-badge" id="encounterBadge">0</span></button>
    <button class="tab-btn" onclick="switchTab('queue')">Queue <span class="tab-badge" id="queueBadge">0</span></button>
    <button class="tab-btn" onclick="switchTab('characters')">Characters <span class="tab-badge" id="charactersBadge">0</span></button>
    <button class="tab-btn" onclick="switchTab('settings')">Settings</button>
    <button class="tab-btn" onclick="switchTab('loot')">Loot</button>
    <button class="tab-btn" onclick="switchTab('reference')">Reference</button>
  </div>

  <!-- Tab Content -->
  <div class="tab-content">
    <!-- Battle Tab -->
    <div class="tab-panel active" id="battleTab">
      <div class="battle-grid">
        <div class="map-area">
          <div class="map-header">
            <h3>Battle Map</h3>
            <div class="map-controls">
              <input type="file" id="mapImageInput" accept="image/*" style="display: none;" onchange="handleMapUpload(event)">
              <button class="map-btn" onclick="showMapImageDialog()">Upload</button>
              <button class="map-btn" id="mapVisBtn" onclick="toggleMapVisibility()">Show</button>
              <button class="map-btn" id="gridBtn" onclick="toggleGrid()">Grid</button>
              <button class="map-btn" onclick="clearMap()">Clear</button>
            </div>
          </div>
          <div class="map-preview-area" id="mapPreviewArea">
            <div class="map-preview-wrapper" id="mapPreviewWrapper">
              <img id="mapPreview" style="display: none;" alt="Map Preview">
              <canvas id="mapPreviewGrid" class="map-preview-grid"></canvas>
              <div id="mapPreviewTokenLayer" class="map-preview-token-layer"></div>
            </div>
            <div class="map-placeholder" id="mapPlaceholder">Click Upload to add a battle map</div>
            <div class="position-mode-indicator" id="positionModeIndicator" style="display: none;">
              <span>Positioning: <strong id="positioningTokenName"></strong></span>
              <button class="cancel-position-btn" onclick="cancelPositionMode()">Cancel</button>
            </div>
          </div>
        </div>

        <div class="token-area">
          <div class="token-header">
            <h3>Tokens</h3>
            <button class="add-token-btn" onclick="addPlayerToken()">+ Player</button>
          </div>
          <div class="token-list" id="tokenList">
            <!-- Tokens rendered here -->
          </div>
        </div>
      </div>
    </div>

    <!-- Encounter Tab -->
    <div class="tab-panel" id="encounterTab">
      <div class="encounter-header">
        <div class="encounter-title" id="encounterTitle">No Encounter Loaded</div>
        <div class="encounter-actions">
          <input type="file" id="encounterFolderInput" webkitdirectory directory style="display: none;" onchange="handleEncounterFolderUpload(event)">
          <input type="file" id="encounterFileInput" accept=".json" style="display: none;" onchange="handleEncounterUpload(event)">
          <input type="file" id="adversaryImageInput" accept="image/*" style="display: none;" multiple onchange="handleAdversaryImageUpload(event)">
          <button class="encounter-btn" onclick="document.getElementById('encounterFolderInput').click()">Load Folder</button>
          <button class="encounter-btn" onclick="loadSampleEncounter()">Sample</button>
          <button class="encounter-btn" onclick="clearEncounter()">Clear</button>
        </div>
      </div>

      <div class="autocomplete-container">
        <input type="text"
               class="adversary-search"
               id="adversarySearchInput"
               placeholder="Search adversaries to add..."
               autocomplete="off">
        <div id="autocompleteDropdown" class="autocomplete-dropdown"></div>
      </div>

      <div id="encounterContainer">
        <div class="encounter-empty">
          No encounter loaded. Load a folder or use the search to add adversaries.
        </div>
      </div>

      <button class="hide-spotlight-btn" id="hideSpotlightBtn" onclick="hideSpotlight()">Hide Spotlight</button>
    </div>

    <!-- Queue Tab -->
    <div class="tab-panel" id="queueTab">
      <div class="queue-header">
        <div class="queue-title">Battle Queue</div>
        <div class="queue-actions">
          <button class="queue-btn primary" onclick="openStageBattleModal()">+ Stage Current Battle</button>
          <input type="file" id="importQueueInput" accept=".json" style="display: none;" onchange="handleImportQueue(event)">
          <button class="queue-btn" onclick="document.getElementById('importQueueInput').click()">Import</button>
          <button class="queue-btn" onclick="exportQueue()">Export</button>
          <button class="queue-btn danger" onclick="clearQueue()">Clear All</button>
        </div>
      </div>

      <div id="queueContainer" class="queue-list">
        <div class="queue-empty">
          <div class="queue-empty-icon">&#9876;</div>
          <div>No battles staged yet.</div>
          <div style="margin-top: 8px; font-size: 0.8rem;">
            Set up your battle map, tokens, and encounter, then click "Stage Current Battle" to save it to the queue.
          </div>
        </div>
      </div>
    </div>

    <!-- Characters Tab -->
    <div class="tab-panel" id="charactersTab">
      <div class="characters-container">
        <div class="characters-sidebar">
          <div class="characters-header">
            <h3>Player Characters</h3>
            <button class="add-character-btn" onclick="addNewCharacter()">+ Add PC</button>
          </div>
          <div class="characters-list" id="charactersList">
            <div class="characters-empty">
              No characters yet. Click "+ Add PC" to create a player character.
            </div>
          </div>
        </div>
        <div class="character-editor" id="characterEditor">
          <div class="character-editor-empty">
            <div class="editor-empty-icon">‚öî</div>
            <div>Select a character to view details</div>
            <div style="margin-top: 8px; font-size: 0.8rem; color: #666;">
              Or click "+ Add PC" to create a new player character
            </div>
          </div>
          <div class="character-editor-form" id="characterEditorForm" style="display: none;">
            <div class="character-form-header">
              <div class="character-portrait-section">
                <div class="character-portrait" id="characterPortrait">
                  <span class="portrait-placeholder">No Image</span>
                </div>
                <input type="file" id="characterImageInput" accept="image/*" style="display: none;" onchange="handleCharacterImageUpload(event)">
                <button class="portrait-upload-btn" onclick="showCharacterImageDialog()">Upload Portrait</button>
              </div>
              <div class="character-basic-info">
                <div class="form-group">
                  <label>Character Name</label>
                  <input type="text" id="charName" class="form-input" placeholder="Enter character name...">
                </div>
                <div class="form-row">
                  <div class="form-group">
                    <label>Level</label>
                    <input type="number" id="charLevel" class="form-input" min="1" max="10" value="1">
                  </div>
                  <div class="form-group">
                    <label>Ancestry</label>
                    <select id="charAncestry" class="form-select">
                      <option value="">Select Ancestry...</option>
                      <option value="clank">Clank</option>
                      <option value="daemon">Daemon</option>
                      <option value="drakona">Drakona</option>
                      <option value="dwarf">Dwarf</option>
                      <option value="elf">Elf</option>
                      <option value="faerie">Faerie</option>
                      <option value="faun">Faun</option>
                      <option value="firbolg">Firbolg</option>
                      <option value="fungril">Fungril</option>
                      <option value="galapa">Galapa</option>
                      <option value="giant">Giant</option>
                      <option value="goblin">Goblin</option>
                      <option value="halfling">Halfling</option>
                      <option value="human">Human</option>
                      <option value="infernis">Infernis</option>
                      <option value="katari">Katari</option>
                      <option value="orc">Orc</option>
                      <option value="ribbet">Ribbet</option>
                      <option value="simiah">Simiah</option>
                    </select>
                  </div>
                </div>
                <div class="form-row">
                  <div class="form-group">
                    <label>Class</label>
                    <select id="charClass" class="form-select" onchange="updateSubclassOptions()">
                      <option value="">Select Class...</option>
                      <option value="bard">Bard</option>
                      <option value="druid">Druid</option>
                      <option value="guardian">Guardian</option>
                      <option value="ranger">Ranger</option>
                      <option value="rogue">Rogue</option>
                      <option value="seraph">Seraph</option>
                      <option value="sorcerer">Sorcerer</option>
                      <option value="warrior">Warrior</option>
                      <option value="wizard">Wizard</option>
                    </select>
                  </div>
                  <div class="form-group">
                    <label>Subclass</label>
                    <select id="charSubclass" class="form-select">
                      <option value="">Select Class first...</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>

            <div class="character-stats-section">
              <h4>Combat Stats</h4>
              <div class="stats-grid">
                <div class="stat-box">
                  <label>Hit Points</label>
                  <div class="stat-row">
                    <input type="number" id="charCurrentHp" class="stat-input" min="0" placeholder="Current">
                    <span class="stat-divider">/</span>
                    <input type="number" id="charMaxHp" class="stat-input" min="1" placeholder="Max">
                  </div>
                </div>
                <div class="stat-box">
                  <label>Stress</label>
                  <div class="stat-row">
                    <input type="number" id="charCurrentStress" class="stat-input" min="0" placeholder="Current">
                    <span class="stat-divider">/</span>
                    <input type="number" id="charMaxStress" class="stat-input" min="1" placeholder="Max">
                  </div>
                </div>
                <div class="stat-box">
                  <label>Armor</label>
                  <input type="number" id="charArmor" class="stat-input single" min="0" value="0">
                </div>
                <div class="stat-box">
                  <label>Evasion</label>
                  <input type="number" id="charEvasion" class="stat-input single" min="0" value="10">
                </div>
              </div>

              <h4>Thresholds</h4>
              <div class="thresholds-grid">
                <div class="threshold-box minor">
                  <label>Minor</label>
                  <input type="number" id="charMinorThreshold" class="threshold-input" min="1" placeholder="HP">
                </div>
                <div class="threshold-box major">
                  <label>Major</label>
                  <input type="number" id="charMajorThreshold" class="threshold-input" min="1" placeholder="HP">
                </div>
                <div class="threshold-box severe">
                  <label>Severe</label>
                  <input type="number" id="charSevereThreshold" class="threshold-input" min="1" placeholder="HP">
                </div>
              </div>
            </div>

            <div class="character-domain-section">
              <h4>Domain</h4>
              <div class="domain-checkboxes">
                <label class="domain-checkbox"><input type="checkbox" id="domainBlade" value="blade"> Blade</label>
                <label class="domain-checkbox"><input type="checkbox" id="domainBone" value="bone"> Bone</label>
                <label class="domain-checkbox"><input type="checkbox" id="domainCodex" value="codex"> Codex</label>
                <label class="domain-checkbox"><input type="checkbox" id="domainGrace" value="grace"> Grace</label>
                <label class="domain-checkbox"><input type="checkbox" id="domainMidnight" value="midnight"> Midnight</label>
                <label class="domain-checkbox"><input type="checkbox" id="domainSage" value="sage"> Sage</label>
                <label class="domain-checkbox"><input type="checkbox" id="domainSplendor" value="splendor"> Splendor</label>
                <label class="domain-checkbox"><input type="checkbox" id="domainValor" value="valor"> Valor</label>
              </div>
            </div>

            <div class="character-experiences-section">
              <h4>Experiences</h4>
              <div class="experiences-list" id="experiencesList">
                <!-- Experiences rendered here -->
              </div>
              <div class="add-experience-row">
                <input type="text" id="newExperienceInput" class="form-input" placeholder="Add an experience...">
                <button class="add-item-btn" onclick="addExperience()">+</button>
              </div>
            </div>

            <div class="character-abilities-section">
              <h4>Abilities</h4>
              <div class="abilities-list" id="abilitiesList">
                <!-- Abilities rendered here -->
              </div>
              <button class="add-ability-btn" onclick="addAbility()">+ Add Ability</button>
            </div>

            <div class="character-feats-section">
              <h4>Feats</h4>
              <div class="feats-list" id="featsList">
                <!-- Feats rendered here -->
              </div>
              <div class="add-feat-row">
                <input type="text" id="newFeatInput" class="form-input" placeholder="Add a feat...">
                <button class="add-item-btn" onclick="addFeat()">+</button>
              </div>
            </div>

            <div class="character-notes-section">
              <h4>Character Notes</h4>
              <textarea id="charNotes" class="form-textarea" placeholder="Backstory, personality, goals, etc..."></textarea>
            </div>

            <div class="character-form-actions">
              <button class="save-character-btn" onclick="saveCurrentCharacter()">Save Character</button>
              <button class="delete-character-btn" onclick="deleteCurrentCharacter()">Delete Character</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- PC Selection Dialog for Token Addition -->
    <div id="pcSelectionDialog" class="stage-modal" onclick="closePcSelectionDialog(event)">
      <div class="stage-modal-content" onclick="event.stopPropagation()" style="max-width: 400px;">
        <div class="stage-modal-header">
          <div class="stage-modal-title">Add Player Token</div>
          <button class="stage-modal-close" onclick="closePcSelectionDialog()">√ó</button>
        </div>
        <div class="stage-modal-body">
          <div id="pcSelectionList" class="pc-selection-list">
            <!-- PCs will be rendered here -->
          </div>
          <div class="pc-selection-divider">
            <span>or enter custom name</span>
          </div>
          <div class="stage-form-group">
            <input type="text" class="stage-form-input" id="customPlayerName" placeholder="Enter player name...">
          </div>
        </div>
        <div class="stage-modal-footer">
          <button class="stage-cancel-btn" onclick="closePcSelectionDialog()">Cancel</button>
          <button class="stage-save-btn" onclick="addCustomPlayerToken()">Add Custom</button>
        </div>
      </div>
    </div>

    <!-- Character Image Source Dialog -->
    <div id="characterImageSourceDialog" class="image-dialog-overlay" onclick="closeCharacterImageDialog(event)">
      <div class="image-dialog" onclick="event.stopPropagation()">
        <h3>Add Character Portrait</h3>
        <div class="image-dialog-options">
          <button class="image-dialog-btn" onclick="chooseCharacterFileUpload()">
            Upload from Computer
          </button>
          <button class="image-dialog-btn" onclick="browseCharacterImages()">
            Browse My Uploads
          </button>
          <button class="image-dialog-btn" onclick="showCharacterUrlInput()">
            Use Image URL
          </button>
        </div>
        <div id="characterUrlInputSection" class="url-input-section">
          <label>Image URL:</label>
          <div class="url-input-row">
            <input type="url" id="characterImageUrlInput" placeholder="https://..." onkeyup="handleCharacterUrlKeyup(event)" oninput="previewCharacterUrlImage()">
            <button class="url-add-btn" id="characterUrlAddBtn" onclick="addCharacterUrl()" disabled>Add</button>
          </div>
          <div id="characterUrlPreview" class="url-preview"></div>
        </div>
        <button class="image-dialog-cancel" onclick="closeCharacterImageDialog()">Cancel</button>
      </div>
    </div>

    <!-- Add Ability Modal -->
    <div id="addAbilityModal" class="stage-modal" onclick="closeAbilityModal(event)">
      <div class="stage-modal-content" onclick="event.stopPropagation()">
        <div class="stage-modal-header">
          <div class="stage-modal-title">Add Ability</div>
          <button class="stage-modal-close" onclick="closeAbilityModal()">√ó</button>
        </div>
        <div class="stage-modal-body">
          <div class="stage-form-group">
            <label class="stage-form-label">Ability Name</label>
            <input type="text" class="stage-form-input" id="abilityName" placeholder="Enter ability name...">
          </div>
          <div class="stage-form-group">
            <label class="stage-form-label">Type</label>
            <select class="stage-form-input" id="abilityType">
              <option value="passive">Passive</option>
              <option value="action">Action</option>
              <option value="reaction">Reaction</option>
              <option value="spell">Spell</option>
            </select>
          </div>
          <div class="stage-form-group">
            <label class="stage-form-label">Description</label>
            <textarea class="stage-form-textarea" id="abilityDescription" placeholder="Describe what this ability does..."></textarea>
          </div>
        </div>
        <div class="stage-modal-footer">
          <button class="stage-cancel-btn" onclick="closeAbilityModal()">Cancel</button>
          <button class="stage-save-btn" onclick="saveAbility()">Add Ability</button>
        </div>
      </div>
    </div>

    <!-- Settings Tab -->
    <div class="tab-panel" id="settingsTab">
      <div class="settings-grid">
        <div class="settings-section">
          <h3>Display Windows</h3>
          <button class="display-btn player" onclick="openPlayerDisplay()">Open Player Display</button>
          <button class="display-btn battlemap" onclick="openBattleMap()">Open Battle Map</button>

          <div class="connection-info">
            <div class="room-code-row">
              <span class="room-code-label">Room Code</span>
              <span class="room-code-value" id="roomCodeDisplay">----</span>
              <button class="copy-btn" onclick="copyRoomCode()">Copy</button>
            </div>
            <div class="connection-status">
              <div class="status-dot" id="connectionDot"></div>
              <span id="connectionText">Initializing...</span>
            </div>
          </div>
        </div>

        <div class="settings-section">
          <h3>NPC Portrait</h3>
          <div class="npc-preview-small" id="npcPreviewContainer">
            <img id="npcPreview" style="display: none;" alt="NPC Preview">
            <span id="npcPlaceholder" style="color: #666; font-size: 0.8rem;">No image</span>
          </div>
          <input type="file" id="npcImageInput" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
          <div class="npc-controls">
            <button class="npc-btn" onclick="showNpcImageDialog()">Set Image</button>
            <button class="npc-btn" onclick="clearNpcImage()">Clear</button>
          </div>
          <div class="toggle-row">
            <span class="toggle-label">Show to Players</span>
            <label class="toggle-switch">
              <input type="checkbox" id="npcVisibilityToggle" onchange="toggleNpcVisibility()">
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>
      </div>

      <div class="settings-section" style="margin-top: 20px;">
        <h3>Session Management</h3>
        <p style="color: #888; font-size: 0.85rem; margin-bottom: 12px;">
          If you're starting a new game session and seeing stale data from a previous session, use this to clear all cached data.
        </p>
        <button class="display-btn" onclick="clearAllSessionData()" style="background: linear-gradient(135deg, #c62828, #b71c1c); width: 100%;">
          Clear All Session Data
        </button>
      </div>

      <div class="full-version-link">
        <a href="gm-control-panel.html">Switch to Full GM Control Panel</a>
      </div>
    </div>

    <!-- Loot Generator Tab -->
    <div class="tab-panel" id="lootTab">
      <div class="loot-container">
        <div class="loot-header">
          <h3>Loot Generator</h3>
          <p class="loot-subtitle">Generate random treasure and consumables for your Daggerheart sessions</p>
        </div>

        <div class="loot-controls">
          <div class="loot-control-row">
            <div class="loot-control-group">
              <label class="loot-label">Loot Type</label>
              <select id="lootType" class="loot-select" onchange="updateLootOptions()">
                <option value="treasure">Treasure (Permanent Items)</option>
                <option value="consumable">Consumables</option>
                <option value="both">Both (Mixed)</option>
              </select>
            </div>

            <div class="loot-control-group">
              <label class="loot-label">Rarity</label>
              <select id="lootRarity" class="loot-select">
                <option value="any">Any Rarity</option>
                <option value="common">Common (1-24)</option>
                <option value="uncommon">Uncommon (25-36)</option>
                <option value="rare">Rare (37-48)</option>
                <option value="legendary">Legendary (49-60)</option>
              </select>
            </div>

            <div class="loot-control-group">
              <label class="loot-label">Number of Items</label>
              <select id="lootCount" class="loot-select">
                <option value="1">1 Item</option>
                <option value="2">2 Items</option>
                <option value="3">3 Items</option>
                <option value="4">4 Items</option>
                <option value="5">5 Items</option>
              </select>
            </div>
          </div>

          <div class="loot-actions">
            <button class="loot-generate-btn" onclick="generateLoot()">Generate Loot</button>
            <button class="loot-clear-btn" onclick="clearLootResults()">Clear</button>
          </div>
        </div>

        <div class="loot-results" id="lootResults">
          <div class="loot-empty">
            <div class="loot-empty-icon">&#128176;</div>
            <div>No loot generated yet</div>
            <div class="loot-empty-hint">Select your options above and click "Generate Loot" to roll for treasure!</div>
          </div>
        </div>

        <!-- Equipment Search Section -->
        <div class="equipment-search-section">
          <div class="equipment-search-header">
            <span class="equipment-search-title">Add Equipment</span>
          </div>
          <div class="equipment-filters">
            <select id="equipmentTypeFilter" class="equipment-filter-select" onchange="filterEquipmentResults()">
              <option value="all">All Types</option>
              <option value="primary_weapon">Primary Weapons</option>
              <option value="secondary_weapon">Secondary Weapons</option>
              <option value="armor">Armor</option>
            </select>
            <select id="equipmentTierFilter" class="equipment-filter-select" onchange="filterEquipmentResults()">
              <option value="all">All Tiers</option>
              <option value="tier_1">Tier 1 (Level 1)</option>
              <option value="tier_2">Tier 2 (Levels 2-4)</option>
              <option value="tier_3">Tier 3 (Levels 5-7)</option>
              <option value="tier_4">Tier 4 (Levels 8-10)</option>
            </select>
          </div>
          <div class="equipment-search-container">
            <input type="text"
                   class="equipment-search-input"
                   id="equipmentSearchInput"
                   placeholder="Search weapons, armor, equipment..."
                   autocomplete="off">
            <div id="equipmentDropdown" class="equipment-dropdown"></div>
          </div>
        </div>

        <div class="loot-reference">
          <div class="loot-reference-header" onclick="toggleLootReference()">
            <span>Rarity Roll Reference</span>
            <span class="loot-reference-toggle" id="lootReferenceToggle">&#9660;</span>
          </div>
          <div class="loot-reference-content" id="lootReferenceContent">
            <div class="rarity-info">
              <div class="rarity-item common">
                <span class="rarity-name">Common</span>
                <span class="rarity-range">Roll 1-24 (1d12 or 2d12)</span>
              </div>
              <div class="rarity-item uncommon">
                <span class="rarity-name">Uncommon</span>
                <span class="rarity-range">Roll 25-36 (2d12 or 3d12)</span>
              </div>
              <div class="rarity-item rare">
                <span class="rarity-name">Rare</span>
                <span class="rarity-range">Roll 37-48 (3d12 or 4d12)</span>
              </div>
              <div class="rarity-item legendary">
                <span class="rarity-name">Legendary</span>
                <span class="rarity-range">Roll 49-60 (4d12 or 5d12)</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Reference Tab -->
    <div class="tab-panel" id="referenceTab">
      <div class="reference-container">
        <div class="reference-subtabs">
          <button class="reference-subtab active" onclick="switchReferenceSubtab('srd')">SRD Reference</button>
          <button class="reference-subtab" onclick="switchReferenceSubtab('notes')">Campaign Notes</button>
        </div>

        <!-- SRD Sub-panel -->
        <div class="reference-subpanel active" id="srdSubpanel">
          <div class="reference-header">
            <h3>Daggerheart SRD Reference</h3>
            <div class="reference-controls">
              <a href="https://www.daggerheart.com/wp-content/uploads/2025/05/DH-SRD-May202025.pdf"
                 target="_blank"
                 class="reference-btn">
                Open in New Tab
              </a>
            </div>
          </div>
          <div class="reference-pdf-wrapper">
            <iframe
              id="srdPdfViewer"
              src="https://www.daggerheart.com/wp-content/uploads/2025/05/DH-SRD-May202025.pdf"
              class="reference-pdf-frame"
              title="Daggerheart SRD PDF">
            </iframe>
          </div>
        </div>

        <!-- Campaign Notes Sub-panel -->
        <div class="reference-subpanel" id="notesSubpanel">
          <div class="campaign-notes-container" id="notes-panel">
            <div class="notes-sidebar">
              <div class="notes-categories">
                <button class="category-btn active" data-category="all" onclick="filterNotesByCategory('all')">All Notes</button>
                <button class="category-btn" data-category="session" onclick="filterNotesByCategory('session')">[S] Session Notes</button>
                <button class="category-btn" data-category="npc" onclick="filterNotesByCategory('npc')">[N] NPCs</button>
                <button class="category-btn" data-category="location" onclick="filterNotesByCategory('location')">[L] Locations</button>
                <button class="category-btn" data-category="plot" onclick="filterNotesByCategory('plot')">[P] Plot Threads</button>
                <button class="category-btn" data-category="rules" onclick="filterNotesByCategory('rules')">[R] House Rules</button>
              </div>
              <div class="notes-list" id="notes-list">
                <!-- Notes rendered here -->
              </div>
              <button class="add-note-btn" id="add-note-btn" onclick="createNewNote()">+ Add Note</button>
            </div>
            <div class="notes-editor" id="notes-editor">
              <div class="notes-empty" id="notes-empty-state">
                <div class="notes-empty-icon">üìù</div>
                <div>No note selected</div>
                <div style="margin-top: 8px; font-size: 0.8rem;">
                  Select a note from the list or create a new one
                </div>
              </div>
              <div id="notes-editor-form" style="display: none;">
                <input type="text" id="note-title" placeholder="Note title...">
                <select id="note-category">
                  <option value="session">Session Notes</option>
                  <option value="npc">NPCs</option>
                  <option value="location">Locations</option>
                  <option value="plot">Plot Threads</option>
                  <option value="rules">House Rules</option>
                </select>
                <textarea id="note-content" placeholder="Write your note here... (Markdown supported)"></textarea>
                <div class="note-actions">
                  <button id="delete-note-btn" onclick="deleteCurrentNote()">Delete</button>
                  <button id="save-note-btn" onclick="saveCurrentNote()">Save</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Token Positioning Modal -->
  <div id="positioningModal" class="positioning-modal" onclick="closePositioningModal(event)">
    <div class="positioning-container" onclick="event.stopPropagation()">
      <div class="positioning-header">
        <div class="positioning-title" id="positioningTitle">Position Token</div>
        <button class="positioning-close" onclick="closePositioningModal()">x</button>
      </div>
      <div class="positioning-map" id="positioningMapContainer">
        <img id="positioningMapImage" src="" alt="Map">
        <canvas id="positioningGrid" class="positioning-grid"></canvas>
      </div>
    </div>
  </div>

  <!-- Image Source Dialog -->
  <div id="imageSourceDialog" class="image-dialog-overlay" onclick="closeImageDialog(event)">
    <div class="image-dialog" onclick="event.stopPropagation()">
      <h3>Add Portrait Image</h3>
      <div class="image-dialog-options">
        <button class="image-dialog-btn" onclick="chooseFileUpload()">
          Upload from Computer
        </button>
        <button class="image-dialog-btn" onclick="browseAdversaryImages()">
          Browse My Uploads
        </button>
        <button class="image-dialog-btn" onclick="showUrlInput()">
          Use Image URL
        </button>
      </div>
      <div id="urlInputSection" class="url-input-section">
        <label>Image URL:</label>
        <div class="url-input-row">
          <input type="url" id="imageUrlInput" placeholder="https://..." onkeyup="handleUrlKeyup(event)" oninput="previewUrlImage()">
          <button class="url-add-btn" id="urlAddBtn" onclick="addUrlPortrait()" disabled>Add</button>
        </div>
        <div id="urlPreview" class="url-preview"></div>
      </div>
      <button class="image-dialog-cancel" onclick="closeImageDialog()">Cancel</button>
    </div>
  </div>

  <!-- Battle Map Image Source Dialog -->
  <div id="mapImageSourceDialog" class="image-dialog-overlay" onclick="closeMapImageDialog(event)">
    <div class="image-dialog" onclick="event.stopPropagation()">
      <h3>Add Battle Map</h3>
      <div class="image-dialog-options">
        <button class="image-dialog-btn" onclick="chooseMapFileUpload()">
          Upload from Computer
        </button>
        <button class="image-dialog-btn" onclick="browseMapImages()">
          Browse My Uploads
        </button>
        <button class="image-dialog-btn" onclick="showMapUrlInput()">
          Use Image URL (CDN)
        </button>
      </div>
      <div id="mapUrlInputSection" class="url-input-section">
        <label>Image URL:</label>
        <div class="url-input-row">
          <input type="url" id="mapImageUrlInput" placeholder="https://..." onkeyup="handleMapUrlKeyup(event)" oninput="previewMapUrlImage()">
          <button class="url-add-btn" id="mapUrlAddBtn" onclick="addMapUrl()" disabled>Add</button>
        </div>
        <div id="mapUrlPreview" class="url-preview"></div>
      </div>
      <button class="image-dialog-cancel" onclick="closeMapImageDialog()">Cancel</button>
    </div>
  </div>

  <!-- Player Token Image Source Dialog -->
  <div id="playerTokenImageSourceDialog" class="image-dialog-overlay" onclick="closePlayerTokenImageDialog(event)">
    <div class="image-dialog" onclick="event.stopPropagation()">
      <h3>Add Token Image</h3>
      <div class="image-dialog-options">
        <button class="image-dialog-btn" onclick="choosePlayerTokenFileUpload()">
          Upload from Computer
        </button>
        <button class="image-dialog-btn" onclick="browsePlayerTokenImages()">
          Browse My Uploads
        </button>
        <button class="image-dialog-btn" onclick="showPlayerTokenUrlInput()">
          Use Image URL (CDN)
        </button>
      </div>
      <div id="playerTokenUrlInputSection" class="url-input-section">
        <label>Image URL:</label>
        <div class="url-input-row">
          <input type="url" id="playerTokenImageUrlInput" placeholder="https://..." onkeyup="handlePlayerTokenUrlKeyup(event)" oninput="previewPlayerTokenUrlImage()">
          <button class="url-add-btn" id="playerTokenUrlAddBtn" onclick="addPlayerTokenUrl()" disabled>Add</button>
        </div>
        <div id="playerTokenUrlPreview" class="url-preview"></div>
      </div>
      <button class="image-dialog-cancel" onclick="closePlayerTokenImageDialog()">Cancel</button>
    </div>
  </div>

  <!-- Player Token Image Upload -->
  <input type="file" id="playerTokenImageInput" accept="image/*" style="display: none;" onchange="handlePlayerTokenImageUpload(event)">

  <!-- NPC Portrait Image Source Dialog -->
  <div id="npcImageSourceDialog" class="image-dialog-overlay" onclick="closeNpcImageDialog(event)">
    <div class="image-dialog" onclick="event.stopPropagation()">
      <h3>Add NPC Portrait</h3>
      <div class="image-dialog-options">
        <button class="image-dialog-btn" onclick="chooseNpcFileUpload()">
          Upload from Computer
        </button>
        <button class="image-dialog-btn" onclick="browseNpcImages()">
          Browse My Uploads
        </button>
        <button class="image-dialog-btn" onclick="showNpcUrlInput()">
          Use Image URL (CDN)
        </button>
      </div>
      <div id="npcUrlInputSection" class="url-input-section">
        <label>Image URL:</label>
        <div class="url-input-row">
          <input type="url" id="npcImageUrlInput" placeholder="https://..." onkeyup="handleNpcUrlKeyup(event)" oninput="previewNpcUrlImage()">
          <button class="url-add-btn" id="npcUrlAddBtn" onclick="addNpcUrl()" disabled>Add</button>
        </div>
        <div id="npcUrlPreview" class="url-preview"></div>
      </div>
      <button class="image-dialog-cancel" onclick="closeNpcImageDialog()">Cancel</button>
    </div>
  </div>

  <!-- Image Gallery Browser Modal -->
  <div id="imageGalleryOverlay" class="image-gallery-overlay" onclick="closeImageGallery(event)">
    <div class="image-gallery" onclick="event.stopPropagation()">
      <h3>My Uploaded Images</h3>
      <div id="imageGalleryContent">
        <div class="image-gallery-loading">Loading images...</div>
      </div>
      <div class="image-gallery-actions">
        <button class="image-gallery-select-btn" id="gallerySelectBtn" onclick="selectGalleryImage()" disabled>Select Image</button>
        <button class="image-gallery-cancel-btn" onclick="closeImageGallery()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="stage-modal" onclick="closeSettingsModal(event)">
    <div class="stage-modal-content" onclick="event.stopPropagation()">
      <div class="stage-modal-header">
        <div class="stage-modal-title">Account Settings</div>
        <button class="stage-modal-close" onclick="closeSettingsModal()">x</button>
      </div>
      <div class="stage-modal-body">
        <div class="settings-section">
          <h4 style="color: #ffd700; margin: 0 0 10px 0;">Account</h4>
          <p style="color: #888; font-size: 0.8rem; margin: 0 0 15px 0;">
            Your email: <span id="settings-user-email" style="color: #e0e0e0;">-</span>
          </p>
          <p style="color: #888; font-size: 0.8rem; margin: 0 0 15px 0;">
            Tier: <span id="settings-user-tier" style="color: #b388ff;">-</span>
          </p>
        </div>

        <div class="settings-section danger-zone" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(244, 67, 54, 0.3);">
          <h4 style="color: #f44336; margin: 0 0 10px 0;">Danger Zone</h4>
          <p style="color: #888; font-size: 0.8rem; margin: 0 0 15px 0;">
            Permanently delete your account and all associated data including campaigns, scenes, characters, notes, and uploaded files. This action cannot be undone.
          </p>
          <div class="delete-account-section" id="deleteAccountSection">
            <button class="delete-account-btn" onclick="showDeleteConfirmation()">Delete My Account</button>
          </div>
          <div class="delete-confirmation-section" id="deleteConfirmationSection" style="display: none;">
            <p style="color: #f44336; font-size: 0.85rem; margin: 0 0 10px 0;">
              Type <strong>delete</strong> to confirm account deletion:
            </p>
            <input type="text" id="deleteConfirmInput" class="stage-form-input" placeholder="Type 'delete' to confirm" style="margin-bottom: 10px;">
            <div style="display: flex; gap: 10px;">
              <button class="stage-btn cancel" onclick="cancelDeleteConfirmation()">Cancel</button>
              <button class="stage-btn delete" id="confirmDeleteBtn" onclick="confirmDeleteAccount()" disabled>Delete Forever</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Stage Battle Modal -->
  <div id="stageBattleModal" class="stage-modal" onclick="closeStageBattleModal(event)">
    <div class="stage-modal-content" onclick="event.stopPropagation()">
      <div class="stage-modal-header">
        <div class="stage-modal-title" id="stageModalTitle">Stage Current Battle</div>
        <button class="stage-modal-close" onclick="closeStageBattleModal()">x</button>
      </div>
      <div class="stage-modal-body">
        <div class="stage-form-group">
          <label class="stage-form-label">Battle Name</label>
          <input type="text" class="stage-form-input" id="stageBattleName" placeholder="e.g., Goblin Ambush, Boss Fight...">
        </div>

        <div class="stage-summary">
          <div class="stage-summary-title">What will be staged:</div>
          <div class="stage-summary-item">
            <span>Battle Map</span>
            <span class="stage-summary-value" id="stageSummaryMap">None</span>
          </div>
          <div class="stage-summary-item">
            <span>Adversaries</span>
            <span class="stage-summary-value" id="stageSummaryAdversaries">0</span>
          </div>
          <div class="stage-summary-item">
            <span>Tokens</span>
            <span class="stage-summary-value" id="stageSummaryTokens">0</span>
          </div>
          <div class="stage-summary-item">
            <span>Positioned Tokens</span>
            <span class="stage-summary-value" id="stageSummaryPositioned">0</span>
          </div>
        </div>

        <div class="stage-form-group">
          <label class="stage-form-label">Notes (optional)</label>
          <textarea class="stage-form-textarea" id="stageBattleNotes" placeholder="Add any GM notes for this battle..."></textarea>
        </div>
      </div>
      <div class="stage-modal-footer">
        <button class="stage-cancel-btn" onclick="closeStageBattleModal()">Cancel</button>
        <button class="stage-save-btn" id="stageSaveBtn" onclick="saveStagedBattle()">Stage Battle</button>
      </div>
    </div>
  </div>

  <!-- New Countdown Modal -->
  <div id="newCountdownModal" class="countdown-modal" onclick="closeNewCountdownModal(event)">
    <div class="countdown-modal-content" onclick="event.stopPropagation()">
      <h3>Create New Countdown</h3>
      <label>Countdown Name</label>
      <input type="text" id="newCountdownName" placeholder="e.g., Ritual Complete">
      <label>Starting Value</label>
      <input type="number" id="newCountdownValue" value="6" min="1" max="20">
      <label>Countdown Type (Optional)</label>
      <select id="newCountdownType">
        <option value="custom">Custom</option>
        <option value="tension">Tension</option>
        <option value="campaign">Campaign</option>
        <option value="environment">Environment</option>
        <option value="adversary">Adversary</option>
      </select>
      <div class="countdown-modal-buttons">
        <button class="cancel-btn" onclick="closeNewCountdownModal()">Cancel</button>
        <button class="create-btn" onclick="createNewCountdown()">Create</button>
      </div>
    </div>
  </div>

  <script>
    // ========== State ==========
    let currentFear = 0;
    let currentNpcImage = null;
    let npcVisible = false;
    let currentEncounter = null;
    let spotlightedAdversary = null;
    let pendingImageUploadAdversaryId = null;
    let currentMap = null;
    let mapVisible = false;
    let battleMapTokens = [];
    // Ensure battleMapTokens is always an array (defensive helper)
    function ensureTokensArray() {
      if (!Array.isArray(battleMapTokens)) {
        battleMapTokens = battleMapTokens?.tokens || [];
      }
    }
    let gridVisible = false;
    let gridSize = 50;
    let nextPlayerTokenId = 1;
    let positioningTokenId = null;
    let pendingPlayerTokenImageId = null;
    let adversaryDatabase = [];
    let selectedAutocompleteIndex = -1;
    let roomRef = null;  // Firebase database reference for the room
    let roomCode = null;
    let connectedClients = 0;
    let heartbeatInterval = null;
    let stagedBattles = [];
    let editingStagedBattleId = null;

    // ========== Countdown State ==========
    let countdowns = []; // Array of {id, name, value, type, visible}
    let selectedCountdownId = null;
    let nextCountdownId = 1;

    // ========== Characters State ==========
    let playerCharacters = [];
    let selectedCharacterId = null;
    let currentCharacterAbilities = [];
    let currentCharacterExperiences = [];
    let currentCharacterFeats = [];

    // ========== Notes State ==========
    let campaignNotes = [];
    let selectedNoteId = null;
    let lastGeneratedLoot = []; // Store loot results for print card functionality
    let currentNoteCategory = 'all';
    let equipmentDatabase = []; // Flattened equipment database for search
    let selectedEquipmentIndex = -1;

    // Subclass options by class
    const SUBCLASS_OPTIONS = {
      bard: ['Wordsmith', 'Troubadour'],
      druid: ['Warden of Renewal', 'Warden of the Seasons'],
      guardian: ['Stalwart', 'Vengeance'],
      ranger: ['Beastbound', 'Wayfinder'],
      rogue: ['Syndicate', 'Nightwalker'],
      seraph: ['Winged Sentinel', 'Divine Herald'],
      sorcerer: ['Primal', 'Elemental Origin'],
      warrior: ['Call of the Brave', 'Call of the Slayer'],
      wizard: ['School of Knowledge', 'School of War']
    };

    // Default silhouette image
    const DEFAULT_NPC_IMAGE = `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
      <defs>
        <radialGradient id="shadowGlow" cx="50%" cy="50%" r="50%">
          <stop offset="0%" style="stop-color:#1a1a2e"/>
          <stop offset="70%" style="stop-color:#0d0d15"/>
          <stop offset="100%" style="stop-color:#050508"/>
        </radialGradient>
        <linearGradient id="silhouetteGrad" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" style="stop-color:#2d2d44"/>
          <stop offset="100%" style="stop-color:#15151f"/>
        </linearGradient>
      </defs>
      <rect width="200" height="200" fill="url(#shadowGlow)"/>
      <path d="M100 30 C75 30 60 50 60 75 C60 95 75 105 85 110 L75 115 C55 120 40 140 40 165 L40 190 L70 190 L75 150 L85 145 L90 190 L110 190 L115 145 L125 150 L130 190 L160 190 L160 165 C160 140 145 120 125 115 L115 110 C125 105 140 95 140 75 C140 50 125 30 100 30Z" fill="url(#silhouetteGrad)"/>
      <text x="100" y="120" font-family="Georgia, serif" font-size="48" font-weight="bold" fill="#6b5b95" text-anchor="middle" opacity="0.6">?</text>
    </svg>`)}`;

    function getDefaultImageForAdversary(adv) {
      // Try to find CDN portrait from bestiary database (case-insensitive)
      if (adversaryDatabase && adversaryDatabase.length > 0) {
        const advNameUpper = adv.name.toUpperCase();
        const bestiary = adversaryDatabase.find(b => b.name.toUpperCase() === advNameUpper);
        if (bestiary && bestiary.portrait) {
          return bestiary.portrait;
        }
      }
      return DEFAULT_NPC_IMAGE;
    }

    // ========== Tab Switching ==========
    function switchTab(tabName) {
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

      document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`).classList.add('active');
      document.getElementById(tabName + 'Tab').classList.add('active');

      // Refresh lists when switching tabs to ensure sync
      if (tabName === 'battle') {
        renderTokenList();
      } else if (tabName === 'encounter') {
        renderEncounter();
      } else if (tabName === 'queue') {
        renderQueueList();
      }

      // Clear update indicator on the tab we're switching to
      const badge = document.getElementById(tabName + 'Badge');
      if (badge) {
        badge.classList.remove('updated');
      }
    }

    function updateTabBadges() {
      const battleBadge = document.getElementById('battleBadge');
      const encounterBadge = document.getElementById('encounterBadge');
      const queueBadge = document.getElementById('queueBadge');
      const charactersBadge = document.getElementById('charactersBadge');

      if (battleBadge) {
        battleBadge.textContent = battleMapTokens.length;
      }

      if (encounterBadge) {
        const count = currentEncounter ? currentEncounter.adversaries.length : 0;
        encounterBadge.textContent = count;
      }

      if (queueBadge) {
        queueBadge.textContent = stagedBattles.length;
      }

      if (charactersBadge) {
        charactersBadge.textContent = playerCharacters.length;
      }
    }

    function flashTabBadge(tabName) {
      const badge = document.getElementById(tabName + 'Badge');
      if (badge) {
        badge.classList.add('updated');
        setTimeout(() => badge.classList.remove('updated'), 1000);
      }
    }

    // ========== Fear Tracker ==========
    function adjustFear(amount) {
      currentFear = Math.max(0, Math.min(12, currentFear + amount));
      updateFearDisplay();
      syncFear();
    }

    function resetFear() {
      currentFear = 0;
      updateFearDisplay();
      syncFear();
    }

    function updateFearDisplay() {
      document.getElementById('fearDisplay').textContent = currentFear;
      localStorage.setItem('daggerheart-fear', currentFear.toString());
    }

    function syncFear() {
      sendToPlayer({ type: 'fear', value: currentFear });
      localStorage.setItem('daggerheart-update', Date.now().toString());
    }

    // ========== Countdown Tracker ==========
    function openNewCountdownModal() {
      document.getElementById('newCountdownModal').classList.add('active');
      document.getElementById('newCountdownName').value = '';
      document.getElementById('newCountdownValue').value = '6';
      document.getElementById('newCountdownType').value = 'custom';
      document.getElementById('newCountdownName').focus();
    }

    function closeNewCountdownModal(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('newCountdownModal').classList.remove('active');
    }

    function createNewCountdown() {
      const name = document.getElementById('newCountdownName').value.trim();
      const value = parseInt(document.getElementById('newCountdownValue').value) || 6;
      const type = document.getElementById('newCountdownType').value;

      if (!name) {
        alert('Please enter a countdown name');
        return;
      }

      const newCountdown = {
        id: nextCountdownId++,
        name: name,
        value: value,
        type: type,
        visible: false
      };

      countdowns.push(newCountdown);
      updateCountdownSelect();

      // Auto-select the new countdown
      selectedCountdownId = newCountdown.id;
      document.getElementById('countdownSelect').value = newCountdown.id;
      updateCountdownDisplay();

      closeNewCountdownModal();
      saveCountdowns();
      syncCountdowns();
    }

    function updateCountdownSelect() {
      const select = document.getElementById('countdownSelect');
      const currentValue = select.value;

      // Clear existing options except the first one
      select.innerHTML = '<option value="">-- None --</option>';

      countdowns.forEach(cd => {
        const option = document.createElement('option');
        option.value = cd.id;
        option.textContent = `${cd.name} (${cd.value})`;
        if (cd.visible) {
          option.textContent += ' [V]';
        }
        select.appendChild(option);
      });

      // Restore selection if still valid
      if (currentValue && countdowns.find(cd => cd.id == currentValue)) {
        select.value = currentValue;
      }
    }

    function selectCountdown() {
      const select = document.getElementById('countdownSelect');
      selectedCountdownId = select.value ? parseInt(select.value) : null;
      updateCountdownDisplay();
    }

    function updateCountdownDisplay() {
      const valueEl = document.getElementById('countdownValue');
      const visBtn = document.getElementById('countdownVisBtn');

      if (selectedCountdownId) {
        const countdown = countdowns.find(cd => cd.id === selectedCountdownId);
        if (countdown) {
          valueEl.textContent = countdown.value;
          visBtn.classList.toggle('visible', countdown.visible);
          return;
        }
      }

      valueEl.textContent = '-';
      visBtn.classList.remove('visible');
    }

    function adjustCountdown(amount) {
      if (!selectedCountdownId) return;

      const countdown = countdowns.find(cd => cd.id === selectedCountdownId);
      if (!countdown) return;

      countdown.value = Math.max(0, countdown.value + amount);
      updateCountdownDisplay();
      updateCountdownSelect();
      saveCountdowns();
      syncCountdowns();
    }

    function toggleCountdownVisibility() {
      if (!selectedCountdownId) return;

      const countdown = countdowns.find(cd => cd.id === selectedCountdownId);
      if (!countdown) return;

      countdown.visible = !countdown.visible;
      updateCountdownDisplay();
      updateCountdownSelect();
      saveCountdowns();
      syncCountdowns();
    }

    function deleteSelectedCountdown() {
      if (!selectedCountdownId) return;

      const countdown = countdowns.find(cd => cd.id === selectedCountdownId);
      if (!countdown) return;

      if (!confirm(`Delete countdown "${countdown.name}"?`)) return;

      countdowns = countdowns.filter(cd => cd.id !== selectedCountdownId);
      selectedCountdownId = null;
      document.getElementById('countdownSelect').value = '';
      updateCountdownSelect();
      updateCountdownDisplay();
      saveCountdowns();
      syncCountdowns();
    }

    function saveCountdowns() {
      localStorage.setItem('daggerheart-countdowns', JSON.stringify(countdowns));
      localStorage.setItem('daggerheart-nextCountdownId', nextCountdownId.toString());
    }

    function loadCountdowns() {
      const saved = localStorage.getItem('daggerheart-countdowns');
      if (saved) {
        try {
          countdowns = JSON.parse(saved);
        } catch (e) {
          countdowns = [];
        }
      }
      const savedNextId = localStorage.getItem('daggerheart-nextCountdownId');
      if (savedNextId) {
        nextCountdownId = parseInt(savedNextId) || 1;
      }
      updateCountdownSelect();
    }

    function syncCountdowns() {
      // Send all visible countdowns to players
      const visibleCountdowns = countdowns.filter(cd => cd.visible).map(cd => ({
        id: cd.id,
        name: cd.name,
        value: cd.value,
        type: cd.type
      }));
      sendToPlayer({ type: 'countdowns', countdowns: visibleCountdowns });
    }

    // ========== Dice Roller ==========
    function setNotation(notation) {
      document.getElementById('diceNotation').value = notation;
      rollNotation(); // Auto-roll when clicking quick dice buttons
    }

    function rollNotation() {
      const notationInput = document.getElementById('diceNotation');
      const notation = notationInput.value.trim();
      if (!notation) return;

      const result = rollDice(notation);
      const lastRollEl = document.getElementById('lastRoll');

      // Visual feedback - flash the result
      lastRollEl.textContent = result.total;
      lastRollEl.style.transform = 'scale(1.3)';
      lastRollEl.style.color = '#4CAF50';
      setTimeout(() => {
        lastRollEl.style.transform = 'scale(1)';
        lastRollEl.style.color = '#ffd700';
      }, 200);

      const diceData = {
        notation: notation,
        total: result.total,
        breakdown: result.breakdown,
        timestamp: Date.now()
      };

      localStorage.setItem('daggerheart-dice', JSON.stringify(diceData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer({ type: 'dice', ...diceData });

      console.log('Dice roll:', notation, '=', result.total, result.breakdown);
    }

    function rollDice(notation) {
      let total = 0;
      let breakdown = [];

      // Parse dice notation like "2d6+1d8+5"
      const parts = notation.replace(/\s/g, '').match(/([+-]?)(\d+d\d+|\d+)/gi) || [];

      parts.forEach(part => {
        // Check if it's a dice roll (contains 'd')
        if (part.toLowerCase().includes('d')) {
          const isNegative = part.startsWith('-');
          const cleanPart = part.replace(/^[+-]/, '');
          const [numDice, dieType] = cleanPart.toLowerCase().split('d').map(Number);
          const rolls = [];

          for (let i = 0; i < numDice; i++) {
            const roll = Math.floor(Math.random() * dieType) + 1;
            rolls.push(roll);
          }

          const subtotal = rolls.reduce((a, b) => a + b, 0);
          total += isNegative ? -subtotal : subtotal;
          breakdown.push(`${isNegative ? '-' : ''}${numDice}d${dieType}: [${rolls.join(', ')}]`);
        } else {
          // It's a modifier
          const value = parseInt(part);
          if (!isNaN(value)) {
            total += value;
            if (value !== 0) {
              breakdown.push(`Modifier: ${value >= 0 ? '+' : ''}${value}`);
            }
          }
        }
      });

      return { total, breakdown };
    }

    function rollHopeFear() {
      const hope = Math.floor(Math.random() * 12) + 1;
      const fear = Math.floor(Math.random() * 12) + 1;
      const sum = hope + fear;
      const winner = hope >= fear ? 'Hope' : 'Fear';
      const isDoubles = hope === fear;
      const lastRollEl = document.getElementById('lastRoll');

      if (isDoubles) {
        lastRollEl.textContent = `Critical!`;
        lastRollEl.style.color = '#ffd700';
      } else {
        lastRollEl.textContent = `${sum} ${winner}`;
        lastRollEl.style.color = winner === 'Hope' ? '#4CAF50' : '#f44336';
      }
      lastRollEl.style.transform = 'scale(1.3)';
      setTimeout(() => {
        lastRollEl.style.transform = 'scale(1)';
        lastRollEl.style.color = '#ffd700';
      }, 200);

      // Send to player display (localStorage for same-browser, PeerJS for remote)
      const diceData = {
        type: 'hopefear',
        hope: hope,
        fear: fear,
        sum: sum,
        winner: winner,
        critical: isDoubles,
        timestamp: Date.now()
      };

      localStorage.setItem('daggerheart-dice', JSON.stringify(diceData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer(diceData);

      console.log('Hope/Fear roll:', hope, '+', fear, '=', sum, winner, isDoubles ? '(Critical!)' : '');
    }

    // ========== Image Upload Helper ==========
    async function uploadImageToCloud(file) {
      // Try cloud upload first if available
      if (window.cloudFeatures?.canUse?.('cloudSave')) {
        try {
          const result = await window.cloudFeatures.uploadFile(file);
          return result.url;
        } catch (err) {
          console.warn('Cloud upload failed, falling back to local:', err);
        }
      }

      // Fallback to base64 for offline/unauthenticated users
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.readAsDataURL(file);
      });
    }

    // ========== Battle Map ==========
    async function handleMapUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const imageUrl = await uploadImageToCloud(file);
      setMapFromUrl(imageUrl);
    }

    function setMapFromUrl(imageUrl) {
      currentMap = {
        mapImage: imageUrl,
        gridSize: gridSize
      };

      const mapPreview = document.getElementById('mapPreview');
      mapPreview.src = imageUrl;
      mapPreview.style.display = 'block';
      document.getElementById('mapPlaceholder').style.display = 'none';

      // Wait for image to load to get dimensions, then render tokens and grid
      mapPreview.onload = () => {
        setTimeout(() => {
          drawMapPreviewGrid();
          renderMapPreviewTokens();
        }, 50);
      };

      syncBattleMap();
    }

    function toggleMapVisibility() {
      mapVisible = !mapVisible;
      const btn = document.getElementById('mapVisBtn');
      btn.classList.toggle('active', mapVisible);
      btn.textContent = mapVisible ? 'Hide' : 'Show';
      syncBattleMap();
    }

    function toggleGrid() {
      gridVisible = !gridVisible;
      document.getElementById('gridBtn').classList.toggle('active', gridVisible);
      drawMapPreviewGrid();
      syncBattleMap();
    }

    function clearMap() {
      currentMap = null;
      mapVisible = false;
      document.getElementById('mapPreview').style.display = 'none';
      document.getElementById('mapPlaceholder').style.display = 'block';
      document.getElementById('mapVisBtn').classList.remove('active');
      document.getElementById('mapVisBtn').textContent = 'Show';
      cancelPositionMode();
      renderMapPreviewTokens();
      drawMapPreviewGrid();
      syncBattleMap();
    }

    function syncBattleMap() {
      ensureTokensArray();

      // Filter tokens - only show tokens marked visible to players (eyeball toggle)
      // This is separate from the Daggerheart "hidden" condition which is a game mechanic
      const visibleTokensForPlayers = battleMapTokens.filter(t => t.visible === true);

      const mapData = {
        type: 'mapSync',
        map: currentMap ? {
          type: 'map',
          visible: mapVisible,
          mapImage: mapVisible ? currentMap.mapImage : null,
          gridSize: currentMap.gridSize
        } : null,
        tokens: { type: 'tokens', tokens: visibleTokensForPlayers },
        grid: { type: 'grid', visible: gridVisible },
        timestamp: Date.now()
      };

      sendToBattleMap(mapData);

      // Store state in localStorage but strip large base64 images
      localStorage.setItem('daggerheart-battle-map-state', JSON.stringify({
        visible: mapVisible,
        gridSize: gridSize
      }));

      // Strip base64 images from tokens before storing (keep URL images)
      // Format must match what battle-map.html expects: { type: 'tokens', tokens: [...] }
      // Player display only gets visible tokens
      const tokensForStorage = visibleTokensForPlayers.map(token => ({
        ...token,
        image: token.image && (token.image.startsWith('http://') || token.image.startsWith('https://'))
          ? token.image
          : null
      }));
      localStorage.setItem('daggerheart-battle-tokens', JSON.stringify({
        type: 'tokens',
        tokens: tokensForStorage,
        timestamp: Date.now()
      }));

      // Store ALL tokens for GM state (including hidden ones) so they persist on reload
      const allTokensForGmStorage = battleMapTokens.map(token => ({
        ...token,
        image: token.image && (token.image.startsWith('http://') || token.image.startsWith('https://'))
          ? token.image
          : null
      }));
      localStorage.setItem('daggerheart-gm-tokens', JSON.stringify({
        type: 'tokens',
        tokens: allTokensForGmStorage,
        timestamp: Date.now()
      }));

      localStorage.setItem('daggerheart-battle-grid', JSON.stringify({ visible: gridVisible }));
      localStorage.setItem('daggerheart-update', Date.now().toString());
    }

    // ========== Tokens ==========
    function addPlayerToken() {
      // Show the PC selection dialog
      const dialog = document.getElementById('pcSelectionDialog');
      const listEl = document.getElementById('pcSelectionList');
      const customInput = document.getElementById('customPlayerName');

      // Clear previous state
      customInput.value = '';

      // Render the list of saved PCs
      if (playerCharacters && playerCharacters.length > 0) {
        listEl.innerHTML = playerCharacters.map(pc => `
          <div class="pc-selection-item" onclick="addPcAsToken('${pc.id}')">
            <div class="pc-portrait">
              ${pc.portrait ? `<img src="${pc.portrait}" alt="${pc.name}">` : ''}
            </div>
            <div class="pc-info">
              <div class="pc-name">${pc.name || 'Unnamed'}</div>
              <div class="pc-meta">
                Level ${pc.level || 1} ${pc.ancestry ? capitalizeFirst(pc.ancestry) : ''} ${pc.characterClass ? capitalizeFirst(pc.characterClass) : ''}
              </div>
            </div>
            <button class="pc-add-btn" onclick="event.stopPropagation(); addPcAsToken('${pc.id}')">Add</button>
          </div>
        `).join('');
      } else {
        listEl.innerHTML = `
          <div class="pc-selection-empty">
            No saved characters yet.<br>
            Add characters in the Characters tab first,<br>
            or enter a custom name below.
          </div>
        `;
      }

      dialog.classList.add('visible');
    }

    function closePcSelectionDialog(e) {
      if (e && e.target !== e.currentTarget) return;
      document.getElementById('pcSelectionDialog').classList.remove('visible');
    }

    function addPcAsToken(pcId) {
      const pc = playerCharacters.find(c => c.id === pcId);
      if (!pc) return;

      // Check if this PC is already on the map
      const existingToken = battleMapTokens.find(t => t.id === 'pc-' + pcId);
      if (existingToken) {
        alert(`${pc.name} is already on the battle map.`);
        closePcSelectionDialog();
        return;
      }

      const token = {
        id: 'pc-' + pcId,
        name: pc.name,
        type: 'player',
        x: 0,
        y: 0,
        image: pc.portrait || null,
        conditions: { hidden: false, restrained: false, vulnerable: false },
        visible: false,  // Hidden from players by default - GM clicks eyeball to reveal
        characterId: pcId  // Link back to the character
      };

      battleMapTokens.push(token);
      renderTokenList();
      syncBattleMap();
      updateTabBadges();
      closePcSelectionDialog();
      scheduleAutoSaveIfAvailable();
    }

    function addCustomPlayerToken() {
      const name = document.getElementById('customPlayerName').value.trim();
      if (!name) {
        alert('Please enter a name for the player token.');
        return;
      }

      const token = {
        id: 'player-' + nextPlayerTokenId++,
        name: name,
        type: 'player',
        x: 0,
        y: 0,
        image: null,
        conditions: { hidden: false, restrained: false, vulnerable: false },
        visible: false  // Hidden from players by default - GM clicks eyeball to reveal
      };

      battleMapTokens.push(token);
      renderTokenList();
      syncBattleMap();
      updateTabBadges();
      closePcSelectionDialog();
      scheduleAutoSaveIfAvailable();
    }

    function addAdversaryToken(adversary) {
      const existingToken = battleMapTokens.find(t => t.id === adversary.id);
      if (existingToken) return;

      const hasPortrait = adversary.portraits && adversary.portraits.length > 0;
      // Adversaries start with hidden condition by default (game mechanic)
      const defaultConditions = { hidden: true, restrained: false, vulnerable: false };
      const token = {
        id: adversary.id,
        name: adversary.name,
        type: 'adversary',
        x: 0,
        y: 0,
        image: hasPortrait ? adversary.portraits[adversary.activePortraitIndex || 0] : getDefaultImageForAdversary(adversary),
        conditions: adversary.conditions ? { ...defaultConditions, ...adversary.conditions, hidden: true } : defaultConditions,
        visible: false  // Hidden from players by default - GM clicks eyeball to reveal
      };

      battleMapTokens.push(token);
      renderTokenList();
      syncBattleMap();
      updateTabBadges();
      flashTabBadge('battle'); // Flash to show token was added
      scheduleAutoSaveIfAvailable();
    }

    function removeToken(tokenId) {
      battleMapTokens = battleMapTokens.filter(t => t.id !== tokenId);
      renderTokenList();
      syncBattleMap();
      updateTabBadges();
      scheduleAutoSaveIfAvailable();
    }

    function toggleTokenVisibility(tokenId) {
      const token = battleMapTokens.find(t => t.id === tokenId);
      if (token) {
        token.visible = !token.visible;
        renderTokenList();
        syncBattleMap();
        scheduleAutoSaveIfAvailable();
      }
    }

    function openPositioningModal(tokenId) {
      if (!currentMap) {
        alert('Please upload a map first');
        return;
      }

      // Use the inline positioning mode on the map preview
      selectTokenForPositioning(tokenId);
    }

    function drawPositioningGrid() {
      const canvas = document.getElementById('positioningGrid');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;

      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw current token position
      const token = battleMapTokens.find(t => t.id === positioningTokenId);
      if (token) {
        const x = token.x * gridSize + gridSize / 2;
        const y = token.y * gridSize + gridSize / 2;
        ctx.fillStyle = token.type === 'player' ? '#4CAF50' : '#f44336';
        ctx.beginPath();
        ctx.arc(x, y, gridSize / 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    document.getElementById('positioningGrid').addEventListener('click', (e) => {
      if (!positioningTokenId) return;

      const canvas = e.target;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      const x = Math.floor((e.clientX - rect.left) * scaleX / gridSize);
      const y = Math.floor((e.clientY - rect.top) * scaleY / gridSize);

      const token = battleMapTokens.find(t => t.id === positioningTokenId);
      if (token) {
        token.x = x;
        token.y = y;
        drawPositioningGrid();
        syncBattleMap();
      }
    });

    function closePositioningModal(event) {
      if (event && event.target !== document.getElementById('positioningModal')) return;
      document.getElementById('positioningModal').classList.remove('visible');
      positioningTokenId = null;
    }

    // ===== Map Preview Token Rendering =====
    let selectedTokenForPositioning = null;

    function renderMapPreviewTokens() {
      ensureTokensArray();
      const tokenLayer = document.getElementById('mapPreviewTokenLayer');
      const mapPreview = document.getElementById('mapPreview');

      if (!tokenLayer || !mapPreview || mapPreview.style.display === 'none' || !currentMap) {
        if (tokenLayer) tokenLayer.innerHTML = '';
        return;
      }

      // Get the displayed size of the map image
      const imgRect = mapPreview.getBoundingClientRect();
      const wrapperRect = document.getElementById('mapPreviewWrapper').getBoundingClientRect();

      // Calculate scale factor between natural and displayed size
      const scaleX = mapPreview.width / mapPreview.naturalWidth;
      const scaleY = mapPreview.height / mapPreview.naturalHeight;

      tokenLayer.innerHTML = '';

      battleMapTokens.forEach(token => {
        const tokenEl = document.createElement('div');
        tokenEl.className = `map-preview-token ${token.type}${!token.visible ? ' hidden-token' : ''}`;
        tokenEl.id = `preview-token-${token.id}`;

        if (selectedTokenForPositioning === token.id) {
          tokenEl.classList.add('selected');
        }

        // Calculate pixel position based on grid coordinates and scale
        const pixelX = (token.x * gridSize + gridSize / 2) * scaleX;
        const pixelY = (token.y * gridSize + gridSize / 2) * scaleY;

        tokenEl.style.left = `${pixelX}px`;
        tokenEl.style.top = `${pixelY}px`;

        // Set token image or default color
        if (token.image) {
          tokenEl.style.backgroundImage = `url(${token.image})`;
        } else {
          tokenEl.style.backgroundColor = token.type === 'player' ? '#4CAF50' : '#f44336';
        }

        // Add token name label
        const labelEl = document.createElement('div');
        labelEl.className = 'token-label';
        labelEl.textContent = token.name;
        tokenEl.appendChild(labelEl);

        // Add condition badges
        const conditions = getTokenConditions(token);
        if (conditions.hidden || conditions.restrained || conditions.vulnerable) {
          const conditionsEl = document.createElement('div');
          conditionsEl.className = 'token-conditions-mini';

          if (conditions.hidden) {
            const badge = document.createElement('div');
            badge.className = 'condition-mini hidden-cond';
            badge.textContent = 'H';
            conditionsEl.appendChild(badge);
          }
          if (conditions.restrained) {
            const badge = document.createElement('div');
            badge.className = 'condition-mini restrained-cond';
            badge.textContent = 'R';
            conditionsEl.appendChild(badge);
          }
          if (conditions.vulnerable) {
            const badge = document.createElement('div');
            badge.className = 'condition-mini vulnerable-cond';
            badge.textContent = 'V';
            conditionsEl.appendChild(badge);
          }

          tokenEl.appendChild(conditionsEl);
        }

        // Click handler to select token for positioning
        tokenEl.addEventListener('click', (e) => {
          e.stopPropagation();
          selectTokenForPositioning(token.id);
        });

        tokenLayer.appendChild(tokenEl);
      });
    }

    function getTokenConditions(token) {
      // For adversaries, get conditions from the encounter data
      if (token.type === 'adversary' && currentEncounter && currentEncounter.adversaries) {
        const adversary = currentEncounter.adversaries.find(a => a.id === token.id);
        if (adversary && adversary.conditions) {
          return adversary.conditions;
        }
      }
      return token.conditions || { hidden: false, restrained: false, vulnerable: false };
    }

    function selectTokenForPositioning(tokenId) {
      const token = battleMapTokens.find(t => t.id === tokenId);
      if (!token) return;

      selectedTokenForPositioning = tokenId;

      // Show position mode indicator
      document.getElementById('positioningTokenName').textContent = token.name;
      document.getElementById('positionModeIndicator').style.display = 'flex';
      document.getElementById('mapPreviewArea').classList.add('positioning-active');

      // Update visual selection
      renderMapPreviewTokens();
    }

    function cancelPositionMode() {
      selectedTokenForPositioning = null;
      document.getElementById('positionModeIndicator').style.display = 'none';
      document.getElementById('mapPreviewArea').classList.remove('positioning-active');
      renderMapPreviewTokens();
    }

    function drawMapPreviewGrid() {
      const canvas = document.getElementById('mapPreviewGrid');
      const mapPreview = document.getElementById('mapPreview');

      if (!canvas || !mapPreview || mapPreview.style.display === 'none' || !currentMap) {
        if (canvas) {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        return;
      }

      // Set canvas size to match the displayed map size
      canvas.width = mapPreview.width;
      canvas.height = mapPreview.height;
      canvas.style.width = mapPreview.width + 'px';
      canvas.style.height = mapPreview.height + 'px';

      // Calculate scale factor
      const scaleX = mapPreview.width / mapPreview.naturalWidth;
      const scaleY = mapPreview.height / mapPreview.naturalHeight;
      const scaledGridSize = gridSize * scaleX;

      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Only draw if grid is enabled
      if (!gridVisible) return;

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 1;

      // Draw vertical lines
      for (let x = 0; x <= canvas.width; x += scaledGridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      // Draw horizontal lines
      for (let y = 0; y <= canvas.height; y += scaledGridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    // Click handler for positioning on the map preview
    document.getElementById('mapPreviewWrapper').addEventListener('click', (e) => {
      if (!selectedTokenForPositioning || !currentMap) return;

      const mapPreview = document.getElementById('mapPreview');
      const rect = mapPreview.getBoundingClientRect();

      // Calculate click position relative to the map image
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      // Calculate scale factor
      const scaleX = mapPreview.width / mapPreview.naturalWidth;
      const scaleY = mapPreview.height / mapPreview.naturalHeight;

      // Convert to grid coordinates
      const gridX = Math.floor(clickX / (gridSize * scaleX));
      const gridY = Math.floor(clickY / (gridSize * scaleY));

      // Update token position
      const token = battleMapTokens.find(t => t.id === selectedTokenForPositioning);
      if (token) {
        token.x = gridX;
        token.y = gridY;
        renderMapPreviewTokens();
        renderTokenList();
        syncBattleMap();
        scheduleAutoSaveIfAvailable();
      }
    });

    // Update map preview when window resizes
    window.addEventListener('resize', () => {
      if (currentMap) {
        setTimeout(() => {
          drawMapPreviewGrid();
          renderMapPreviewTokens();
        }, 100);
      }
    });

    function renderTokenList() {
      const container = document.getElementById('tokenList');
      if (!container) return;
      ensureTokensArray();

      if (battleMapTokens.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px; font-size: 0.8rem;">No tokens. Add players or load an encounter.</div>';
        renderMapPreviewTokens();
        return;
      }

      container.innerHTML = battleMapTokens.map(token => {
        // Get adversary data for HP and conditions if this is an adversary token
        let adversary = null;
        let isSpotlighted = false;
        if (token.type === 'adversary' && currentEncounter && currentEncounter.adversaries) {
          adversary = currentEncounter.adversaries.find(a => a.id === token.id);
          isSpotlighted = spotlightedAdversary === token.id;
        }

        // Build adversary controls HTML
        let adversaryControlsHtml = '';
        if (adversary) {
          const conditions = adversary.conditions || {};
          const hpValueClass = adversary.currentHp <= 0 ? 'defeated' : (adversary.hp && adversary.currentHp <= adversary.hp * 0.25 ? 'critical' : '');

          adversaryControlsHtml = `
            <div class="token-controls">
              <div class="token-controls-row">
                <button class="token-spotlight-btn ${isSpotlighted ? 'active' : ''}" onclick="setSpotlight('${token.id}')" title="Show to players">
                  ${isSpotlighted ? '‚òÖ' : '‚òÜ'}
                </button>
                ${adversary.hp !== undefined ? `
                  <div class="token-hp-tracker">
                    <span class="token-hp-label">HP</span>
                    <button class="token-hp-btn minus" onclick="adjustHp('${token.id}', -1)">‚àí</button>
                    <span class="token-hp-value ${hpValueClass}">${adversary.currentHp}/${adversary.hp}</span>
                    <button class="token-hp-btn plus" onclick="adjustHp('${token.id}', 1)">+</button>
                  </div>
                ` : ''}
              </div>
              <div class="token-controls-row">
                <button class="token-condition-btn hidden-btn ${conditions.hidden ? 'active' : ''}" onclick="toggleCondition('${token.id}', 'hidden')" title="Hidden">üëÅ</button>
                <button class="token-condition-btn restrained-btn ${conditions.restrained ? 'active' : ''}" onclick="toggleCondition('${token.id}', 'restrained')" title="Restrained">‚õì</button>
                <button class="token-condition-btn vulnerable-btn ${conditions.vulnerable ? 'active' : ''}" onclick="toggleCondition('${token.id}', 'vulnerable')" title="Vulnerable">‚ö†</button>
              </div>
            </div>
          `;
        }

        return `
          <div class="token-item ${token.type} ${token.visible ? '' : 'hidden-from-players'} ${isSpotlighted ? 'spotlighted' : ''}">
            <div class="token-thumb" onclick="${token.type === 'player' && !token.image ? `uploadPlayerTokenImage('${token.id}')` : `openPositioningModal('${token.id}')`}" title="${token.type === 'player' && !token.image ? 'Click to add image' : 'Click to position on map'}">
              ${token.image ? `<img src="${token.image}" alt="${token.name}">` : `<span style="font-size: 1.2rem;">${token.type === 'player' ? 'üë§' : 'üëπ'}</span>`}
            </div>
            <div style="flex: 1; min-width: 0;">
              <div style="display: flex; align-items: center; gap: 6px;">
                <span class="token-name">${token.name}</span>
                <span class="token-pos" style="font-size: 0.65rem; color: #888;">(${token.x},${token.y})</span>
              </div>
              ${adversaryControlsHtml}
            </div>
            <div class="token-actions">
              <button class="token-action-btn" onclick="openPositioningModal('${token.id}')" title="Position on map">üìç</button>
              ${token.type === 'player' ? `<button class="token-action-btn" onclick="uploadPlayerTokenImage('${token.id}')" title="Set image">üñº</button>` : ''}
              <button class="token-action-btn ${token.visible ? 'visible-on' : ''}" onclick="toggleTokenVisibility('${token.id}')" title="${token.visible ? 'Hide from players' : 'Show to players'}">
                ${token.visible ? 'üëÅ' : 'üëÅ‚Äçüó®'}
              </button>
              <button class="token-action-btn" onclick="removeToken('${token.id}')" title="Remove">‚úï</button>
            </div>
          </div>
        `;
      }).join('');

      // Also update tokens on the map preview
      renderMapPreviewTokens();
    }

    // ========== Encounters ==========
    function handleEncounterFolderUpload(event) {
      const files = Array.from(event.target.files);
      const jsonFile = files.find(f => f.name === 'encounter.json');

      if (!jsonFile) {
        alert('No encounter.json found in folder');
        return;
      }

      const imageFiles = files.filter(f => /\.(png|jpg|jpeg|gif|webp)$/i.test(f.name));
      const imageMap = {};

      let imagesLoaded = 0;
      const totalImages = imageFiles.length;

      const processEncounter = () => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            currentEncounter = {
              name: data.name || 'Encounter',
              adversaries: (data.adversaries || []).map(adv => ({
                ...adv,
                id: adv.id || 'adv-' + Math.random().toString(36).substr(2, 9),
                currentHp: adv.currentHp ?? adv.hp,
                currentStress: adv.currentStress ?? adv.stress,
                conditions: adv.conditions || { hidden: false, restrained: false, vulnerable: false },
                portraits: [],
                activePortraitIndex: 0
              }))
            };

            // Assign portraits from images
            currentEncounter.adversaries.forEach(adv => {
              if (adv.portrait && imageMap[adv.portrait]) {
                adv.portraits.push(imageMap[adv.portrait]);
              }
            });

            renderEncounter();
            saveEncounterState();

            // Add tokens for all adversaries
            currentEncounter.adversaries.forEach(adv => addAdversaryToken(adv));
          } catch (err) {
            alert('Error parsing encounter.json: ' + err.message);
          }
        };
        reader.readAsText(jsonFile);
      };

      if (totalImages === 0) {
        processEncounter();
      } else {
        imageFiles.forEach(file => {
          const imgReader = new FileReader();
          imgReader.onload = (e) => {
            imageMap[file.name] = e.target.result;
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              processEncounter();
            }
          };
          imgReader.readAsDataURL(file);
        });
      }
    }

    function handleEncounterUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          currentEncounter = {
            name: data.name || 'Encounter',
            adversaries: (data.adversaries || []).map(adv => {
              // Build portraits array from various possible fields
              let portraits = [];

              // 1. Use existing portraits array if present
              if (adv.portraits && Array.isArray(adv.portraits)) {
                portraits = [...adv.portraits];
              }

              // 2. Add portrait URL if it's a URL (not a filename reference)
              if (adv.portrait && typeof adv.portrait === 'string') {
                if (adv.portrait.startsWith('http://') || adv.portrait.startsWith('https://')) {
                  portraits.push(adv.portrait);
                }
              }

              // 3. Add portraitUrl field (CDN URL support)
              if (adv.portraitUrl && typeof adv.portraitUrl === 'string') {
                if (adv.portraitUrl.startsWith('http://') || adv.portraitUrl.startsWith('https://')) {
                  portraits.push(adv.portraitUrl);
                }
              }

              // 4. Add portraitUrls array (multiple CDN URLs)
              if (adv.portraitUrls && Array.isArray(adv.portraitUrls)) {
                adv.portraitUrls.forEach(url => {
                  if (typeof url === 'string' && (url.startsWith('http://') || url.startsWith('https://'))) {
                    portraits.push(url);
                  }
                });
              }

              return {
                ...adv,
                id: adv.id || 'adv-' + Math.random().toString(36).substr(2, 9),
                currentHp: adv.currentHp ?? adv.hp,
                currentStress: adv.currentStress ?? adv.stress,
                conditions: adv.conditions || { hidden: false, restrained: false, vulnerable: false },
                portraits: portraits,
                activePortraitIndex: 0
              };
            })
          };

          renderEncounter();
          saveEncounterState();
          currentEncounter.adversaries.forEach(adv => addAdversaryToken(adv));
        } catch (err) {
          alert('Error parsing JSON: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    function loadSampleEncounter() {
      currentEncounter = {
        name: 'Sample Encounter',
        adversaries: [
          {
            id: 'sample-1',
            name: 'APPRENTICE ASSASSIN',
            tier: 1,
            hp: 1,
            currentHp: 1,
            stress: 1,
            currentStress: 1,
            role: 'Minion',
            conditions: { hidden: false, restrained: false, vulnerable: false },
            portraits: [],
            activePortraitIndex: 0
          },
          {
            id: 'sample-2',
            name: 'ARCHER GUARD',
            tier: 1,
            hp: 3,
            currentHp: 3,
            stress: 2,
            currentStress: 2,
            role: 'Ranged',
            conditions: { hidden: false, restrained: false, vulnerable: false },
            portraits: [],
            activePortraitIndex: 0
          },
          {
            id: 'sample-3',
            name: 'ASSASSIN POISONER',
            tier: 1,
            hp: 4,
            currentHp: 4,
            stress: 4,
            currentStress: 4,
            role: 'Skulk',
            conditions: { hidden: false, restrained: false, vulnerable: false },
            portraits: [],
            activePortraitIndex: 0
          }
        ]
      };

      renderEncounter();
      saveEncounterState();
      currentEncounter.adversaries.forEach(adv => addAdversaryToken(adv));
    }

    function clearEncounter() {
      ensureTokensArray();
      // Remove adversary tokens
      if (currentEncounter) {
        currentEncounter.adversaries.forEach(adv => {
          battleMapTokens = battleMapTokens.filter(t => t.id !== adv.id);
        });
      }

      currentEncounter = null;
      spotlightedAdversary = null;
      renderEncounter();
      renderTokenList();
      syncBattleMap();
      updateTabBadges();

      localStorage.removeItem('daggerheart-encounter');
      localStorage.removeItem('daggerheart-spotlight');
      updateSpotlightUI();
    }

    function renderEncounter() {
      const container = document.getElementById('encounterContainer');
      const titleEl = document.getElementById('encounterTitle');

      if (!currentEncounter || currentEncounter.adversaries.length === 0) {
        titleEl.textContent = 'No Encounter Loaded';
        container.innerHTML = '<div class="encounter-empty">No encounter loaded. Load a folder or use the search to add adversaries.</div>';
        return;
      }

      titleEl.textContent = currentEncounter.name;

      container.innerHTML = `
        <div class="adversary-grid">
          ${currentEncounter.adversaries.map(adv => {
            const hpPercent = adv.hp ? (adv.currentHp / adv.hp) * 100 : 100;
            const stressPercent = adv.stress ? (adv.currentStress / adv.stress) * 100 : 100;
            const isSpotlighted = spotlightedAdversary === adv.id;
            const hasPortrait = adv.portraits && adv.portraits.length > 0;
            const portraitSrc = hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : getDefaultImageForAdversary(adv);

            return `
              <div class="adversary-card ${isSpotlighted ? 'spotlighted' : ''}">
                <div class="adv-header">
                  <div class="adv-portrait" onclick="openImageDialog('${adv.id}')">
                    <img src="${portraitSrc}" alt="${adv.name}">
                  </div>
                  <div class="adv-info">
                    <div class="adv-name">${adv.name}</div>
                    <div class="adv-tier">Tier ${adv.tier || 1} ${adv.role || ''}</div>
                  </div>
                  <div class="adv-actions">
                    <button class="spotlight-btn ${isSpotlighted ? 'active' : ''}" onclick="setSpotlight('${adv.id}')">
                      ${isSpotlighted ? 'On' : 'Show'}
                    </button>
                  </div>
                </div>

                <div class="adv-trackers">
                  <div class="tracker">
                    <div class="tracker-label">HP</div>
                    <div class="tracker-row">
                      <button class="tracker-btn" onclick="adjustHp('${adv.id}', -1)">-</button>
                      <span class="tracker-value hp ${adv.currentHp <= (adv.hp * 0.25) ? 'low' : ''}">${adv.currentHp}/${adv.hp}</span>
                      <button class="tracker-btn" onclick="adjustHp('${adv.id}', 1)">+</button>
                    </div>
                    <div class="tracker-bar"><div class="tracker-fill" style="width: ${hpPercent}%"></div></div>
                  </div>
                  <div class="tracker">
                    <div class="tracker-label">Stress</div>
                    <div class="tracker-row">
                      <button class="tracker-btn" onclick="adjustStress('${adv.id}', -1)">-</button>
                      <span class="tracker-value stress ${adv.currentStress <= (adv.stress * 0.25) ? 'low' : ''}">${adv.currentStress}/${adv.stress}</span>
                      <button class="tracker-btn" onclick="adjustStress('${adv.id}', 1)">+</button>
                    </div>
                    <div class="tracker-bar"><div class="tracker-fill stress" style="width: ${stressPercent}%"></div></div>
                  </div>
                </div>

                <div class="adv-conditions">
                  <span class="condition-badge hidden ${adv.conditions.hidden ? 'active' : ''}" onclick="toggleCondition('${adv.id}', 'hidden')">Hidden</span>
                  <span class="condition-badge restrained ${adv.conditions.restrained ? 'active' : ''}" onclick="toggleCondition('${adv.id}', 'restrained')">Restrained</span>
                  <span class="condition-badge vulnerable ${adv.conditions.vulnerable ? 'active' : ''}" onclick="toggleCondition('${adv.id}', 'vulnerable')">Vulnerable</span>
                </div>

                <div class="adv-stats">
                  <div class="stat-item">
                    <div class="stat-label">Defense</div>
                    <div class="stat-value defense">${adv.defense || '-'}</div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-label">Type</div>
                    <div class="stat-value">${adv.type || adv.role || '-'}</div>
                  </div>
                </div>

                ${adv.attackData ? `
                <div class="adv-attack-section">
                  <div class="attack-header">Attack: ${adv.attackData.name || 'Attack'}</div>
                  <div class="attack-details">
                    <span class="attack-mod">${adv.attackData.modifier >= 0 ? '+' : ''}${adv.attackData.modifier}</span>
                    <span class="attack-damage">${adv.attackData.damage}</span>
                    <span class="attack-range">${adv.attackData.range || 'Melee'}</span>
                  </div>
                </div>
                ` : (adv.attack ? `
                <div class="adv-attack-section">
                  <div class="attack-header">Attack</div>
                  <div class="attack-details">
                    <span class="attack-summary">${adv.attack}</span>
                  </div>
                </div>
                ` : '')}

                ${adv.thresholds ? `
                <div class="adv-thresholds">
                  <div class="threshold major">
                    <div class="threshold-label">Major</div>
                    <div class="threshold-value">${adv.thresholds.major}+</div>
                  </div>
                  <div class="threshold severe">
                    <div class="threshold-label">Severe</div>
                    <div class="threshold-value">${adv.thresholds.severe}+</div>
                  </div>
                </div>
                ` : ''}

                ${adv.traits && adv.traits.length > 0 ? `
                <div class="adv-traits">
                  ${adv.traits.map(trait => `<span class="trait-tag">${trait}</span>`).join('')}
                </div>
                ` : ''}

                ${adv.abilities && adv.abilities.length > 0 ? `
                <div class="adv-abilities">
                  <div class="abilities-header">Abilities</div>
                  ${adv.abilities.map(ability => {
                    const colonIndex = ability.indexOf(':');
                    if (colonIndex > -1) {
                      const name = ability.substring(0, colonIndex);
                      const desc = ability.substring(colonIndex + 1).trim();
                      return `<div class="ability-item"><span class="ability-name">${name}:</span> ${desc}</div>`;
                    }
                    return `<div class="ability-item">${ability}</div>`;
                  }).join('')}
                </div>
                ` : ''}
              </div>
            `;
          }).join('')}
        </div>
      `;
    }

    function adjustHp(advId, amount) {
      const adv = currentEncounter?.adversaries.find(a => a.id === advId);
      if (!adv) return;

      adv.currentHp = Math.max(0, Math.min(adv.hp, adv.currentHp + amount));

      // Update both views immediately
      renderEncounter();
      requestAnimationFrame(() => renderTokenList());
      saveEncounterState();

      if (spotlightedAdversary === advId) {
        syncSpotlight();
      }
    }

    function adjustStress(advId, amount) {
      const adv = currentEncounter?.adversaries.find(a => a.id === advId);
      if (!adv) return;

      adv.currentStress = Math.max(0, Math.min(adv.stress, adv.currentStress + amount));
      renderEncounter();
      saveEncounterState();
    }

    function toggleCondition(advId, condition) {
      const adv = currentEncounter?.adversaries.find(a => a.id === advId);
      if (!adv) return;

      adv.conditions[condition] = !adv.conditions[condition];
      renderEncounter();
      requestAnimationFrame(() => renderTokenList());
      saveEncounterState();

      // Update token conditions
      const token = battleMapTokens.find(t => t.id === advId);
      if (token) {
        token.conditions = { ...adv.conditions };
        syncBattleMap();
      }

      if (spotlightedAdversary === advId) {
        syncSpotlight();
      }
    }

    function setSpotlight(advId) {
      if (spotlightedAdversary === advId) {
        hideSpotlight();
        return;
      }

      spotlightedAdversary = advId;

      // Debug: log the adversary being spotlighted
      if (currentEncounter) {
        const adv = currentEncounter.adversaries.find(a => a.id === advId);
        if (adv) {
          console.log('Setting spotlight on:', adv.name);
          console.log('Portraits:', adv.portraits ? adv.portraits.length : 0);
          if (adv.portraits && adv.portraits.length > 0) {
            console.log('Portrait type:', typeof adv.portraits[0], adv.portraits[0].substring(0, 50) + '...');
          }
        }
      }

      renderEncounter();
      requestAnimationFrame(() => renderTokenList());
      updateSpotlightUI();
      syncSpotlight();
    }

    function hideSpotlight() {
      spotlightedAdversary = null;
      renderEncounter();
      requestAnimationFrame(() => renderTokenList());
      updateSpotlightUI();

      const spotlightData = { visible: false, timestamp: Date.now() };
      localStorage.setItem('daggerheart-spotlight', JSON.stringify(spotlightData));
      localStorage.setItem('daggerheart-update', Date.now().toString());
      sendToPlayer({ type: 'spotlight', ...spotlightData });
    }

    function updateSpotlightUI() {
      const btn = document.getElementById('hideSpotlightBtn');
      btn.classList.toggle('visible', spotlightedAdversary !== null);
    }

    function syncSpotlight() {
      if (!spotlightedAdversary || !currentEncounter) return;

      const adv = currentEncounter.adversaries.find(a => a.id === spotlightedAdversary);
      if (!adv) return;

      const isDefeated = adv.hp !== undefined && adv.currentHp <= 0;
      const hasPortrait = adv.portraits && adv.portraits.length > 0;
      const imageToShow = hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : getDefaultImageForAdversary(adv);

      const spotlightData = {
        visible: true,
        adversaryId: adv.id,
        name: adv.name,
        image: imageToShow,
        isDefaultImage: !hasPortrait,
        defeated: isDefeated,
        conditions: adv.conditions || {},
        timestamp: Date.now()
      };

      // If Firebase is connected, send via Firebase
      if (roomRef) {
        sendToPlayer({ type: 'spotlight', ...spotlightData });
        console.log('Spotlight sent via Firebase:', adv.name, hasPortrait ? 'with portrait' : 'default image');

        // Save non-image data to localStorage for persistence
        const spotlightMetadata = { ...spotlightData, image: null };
        try {
          localStorage.setItem('daggerheart-spotlight', JSON.stringify(spotlightMetadata));
          localStorage.setItem('daggerheart-update', Date.now().toString());
        } catch (e) {
          console.error('Failed to save spotlight metadata:', e);
        }
      } else {
        // No Firebase - try localStorage (for same-browser fallback)
        // Use URL images only, skip base64 to avoid quota issues
        const isUrlImage = imageToShow && (imageToShow.startsWith('http://') || imageToShow.startsWith('https://'));
        const storageData = {
          ...spotlightData,
          image: isUrlImage ? imageToShow : getDefaultImageForAdversary(adv) // Use default for base64
        };

        try {
          localStorage.setItem('daggerheart-spotlight', JSON.stringify(storageData));
          localStorage.setItem('daggerheart-update', Date.now().toString());
          console.log('Spotlight saved to localStorage:', adv.name);
        } catch (e) {
          console.error('Failed to sync spotlight to localStorage:', e);
        }
      }
    }

    function saveEncounterState() {
      if (currentEncounter) {
        try {
          // Strip large image data before saving to localStorage to avoid quota issues
          // Images are sent via Gun.js only (which handles data sync well)
          const encounterForStorage = {
            name: currentEncounter.name,
            adversaries: currentEncounter.adversaries.map(adv => ({
              ...adv,
              // Don't store base64 portraits in localStorage - they're too large
              // Only store URL-based portraits (they're small strings)
              portraits: (adv.portraits || []).filter(p =>
                typeof p === 'string' && (p.startsWith('http://') || p.startsWith('https://'))
              )
            }))
          };
          localStorage.setItem('daggerheart-encounter', JSON.stringify({ encounter: encounterForStorage }));
        } catch (e) {
          console.error('Failed to save encounter to localStorage:', e);
        }
      }
      updateTabBadges();
    }

    // ========== Adversary Search ==========
    const searchInput = document.getElementById('adversarySearchInput');
    const dropdown = document.getElementById('autocompleteDropdown');

    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim().toLowerCase();
      if (query.length < 2) {
        dropdown.classList.remove('visible');
        return;
      }

      const matches = adversaryDatabase.filter(adv =>
        adv.name.toLowerCase().includes(query) ||
        (adv.role && adv.role.toLowerCase().includes(query)) ||
        (adv.themes && adv.themes.some(t => t.toLowerCase().includes(query)))
      ).slice(0, 10);

      if (matches.length === 0) {
        dropdown.classList.remove('visible');
        return;
      }

      dropdown.innerHTML = matches.map((adv, i) => `
        <div class="autocomplete-item ${i === selectedAutocompleteIndex ? 'selected' : ''}"
             onclick="selectAutocompleteItem('${adv.name.replace(/'/g, "\\'")}')">
          ${adv.name}
          <small>T${adv.tier || 1} ${adv.role || ''}</small>
        </div>
      `).join('');

      dropdown.classList.add('visible');
    });

    searchInput.addEventListener('keydown', (e) => {
      const items = dropdown.querySelectorAll('.autocomplete-item');

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, items.length - 1);
        updateAutocompleteSelection();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, -1);
        updateAutocompleteSelection();
      } else if (e.key === 'Enter' && selectedAutocompleteIndex >= 0) {
        e.preventDefault();
        const item = items[selectedAutocompleteIndex];
        if (item) item.click();
      } else if (e.key === 'Escape') {
        dropdown.classList.remove('visible');
        selectedAutocompleteIndex = -1;
      }
    });

    function updateAutocompleteSelection() {
      const items = dropdown.querySelectorAll('.autocomplete-item');
      items.forEach((item, i) => {
        item.classList.toggle('selected', i === selectedAutocompleteIndex);
      });
    }

    function selectAutocompleteItem(name) {
      const adv = adversaryDatabase.find(a => a.name === name);
      if (!adv) return;

      if (!currentEncounter) {
        currentEncounter = { name: 'Custom Encounter', adversaries: [] };
      }

      // Use CDN portrait from bestiary if available
      const initialPortraits = adv.portrait ? [adv.portrait] : [];

      const newAdv = {
        ...adv,
        id: 'adv-' + Math.random().toString(36).substr(2, 9),
        currentHp: adv.hp,
        currentStress: adv.stress,
        conditions: { hidden: true, restrained: false, vulnerable: false },
        portraits: initialPortraits,
        activePortraitIndex: 0
      };

      currentEncounter.adversaries.push(newAdv);
      addAdversaryToken(newAdv);

      searchInput.value = '';
      dropdown.classList.remove('visible');
      selectedAutocompleteIndex = -1;

      renderEncounter();
      saveEncounterState();
    }

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.autocomplete-container')) {
        dropdown.classList.remove('visible');
        selectedAutocompleteIndex = -1;
      }
    });

    // ========== Image Dialog ==========
    function openImageDialog(advId) {
      pendingImageUploadAdversaryId = advId;
      document.getElementById('imageSourceDialog').classList.add('visible');
      document.getElementById('urlInputSection').classList.remove('visible');
      document.getElementById('imageUrlInput').value = '';
      document.getElementById('urlPreview').innerHTML = '';
    }

    function closeImageDialog(event) {
      if (event && event.target !== document.getElementById('imageSourceDialog')) return;
      document.getElementById('imageSourceDialog').classList.remove('visible');
      pendingImageUploadAdversaryId = null;
    }

    function chooseFileUpload() {
      document.getElementById('imageSourceDialog').classList.remove('visible');
      document.getElementById('adversaryImageInput').click();
    }

    function showUrlInput() {
      document.getElementById('urlInputSection').classList.add('visible');
    }

    function previewUrlImage() {
      const url = document.getElementById('imageUrlInput').value.trim();
      const preview = document.getElementById('urlPreview');
      const addBtn = document.getElementById('urlAddBtn');

      if (!url) {
        preview.innerHTML = '';
        addBtn.disabled = true;
        return;
      }

      preview.innerHTML = `<img src="${url}" alt="Preview" onerror="this.parentElement.innerHTML='Invalid URL'" onload="document.getElementById('urlAddBtn').disabled=false">`;
    }

    function handleUrlKeyup(event) {
      if (event.key === 'Enter') {
        addUrlPortrait();
      }
    }

    function addUrlPortrait() {
      const url = document.getElementById('imageUrlInput').value.trim();
      if (!url || !pendingImageUploadAdversaryId) return;

      const adv = currentEncounter?.adversaries.find(a => a.id === pendingImageUploadAdversaryId);
      if (adv) {
        if (!adv.portraits) adv.portraits = [];
        adv.portraits.push(url);
        adv.activePortraitIndex = adv.portraits.length - 1;

        // Update token image
        const token = battleMapTokens.find(t => t.id === adv.id);
        if (token) {
          token.image = url;
          syncBattleMap();
        }

        renderEncounter();
        saveEncounterState();

        if (spotlightedAdversary === adv.id) {
          syncSpotlight();
        }
      }

      closeImageDialog();
    }

    // ===== Battle Map Image Dialog Functions =====
    function showMapImageDialog() {
      document.getElementById('mapUrlInputSection').classList.remove('visible');
      document.getElementById('mapImageUrlInput').value = '';
      document.getElementById('mapUrlPreview').innerHTML = '';
      document.getElementById('mapUrlAddBtn').disabled = true;
      document.getElementById('mapImageSourceDialog').classList.add('visible');
    }

    function closeMapImageDialog(event) {
      if (event && event.target !== document.getElementById('mapImageSourceDialog')) return;
      document.getElementById('mapImageSourceDialog').classList.remove('visible');
    }

    function chooseMapFileUpload() {
      document.getElementById('mapImageSourceDialog').classList.remove('visible');
      document.getElementById('mapImageInput').click();
    }

    function showMapUrlInput() {
      document.getElementById('mapUrlInputSection').classList.add('visible');
      document.getElementById('mapImageUrlInput').focus();
    }

    function handleMapUrlKeyup(event) {
      if (event.key === 'Enter' && !document.getElementById('mapUrlAddBtn').disabled) {
        addMapUrl();
      }
    }

    function previewMapUrlImage() {
      const url = document.getElementById('mapImageUrlInput').value.trim();
      const preview = document.getElementById('mapUrlPreview');
      const addBtn = document.getElementById('mapUrlAddBtn');

      if (!url) {
        preview.innerHTML = '';
        addBtn.disabled = true;
        return;
      }

      preview.innerHTML = `<img src="${url}" alt="Preview" onerror="this.parentElement.innerHTML='Invalid URL'" onload="document.getElementById('mapUrlAddBtn').disabled=false">`;
    }

    function addMapUrl() {
      const url = document.getElementById('mapImageUrlInput').value.trim();
      if (!url) return;

      currentMap = { mapImage: url, gridSize: gridSize };

      const mapPreview = document.getElementById('mapPreview');
      mapPreview.src = url;
      mapPreview.style.display = 'block';
      document.getElementById('mapPlaceholder').style.display = 'none';
      document.getElementById('mapVisBtn').textContent = mapVisible ? 'Hide' : 'Show';

      // Wait for image to load to get dimensions, then render tokens and grid
      mapPreview.onload = () => {
        setTimeout(() => {
          drawMapPreviewGrid();
          renderMapPreviewTokens();
        }, 50);
      };

      if (mapVisible) {
        syncBattleMap();
      }

      closeMapImageDialog();
    }

    // ===== Player Token Image Dialog Functions =====
    function showPlayerTokenImageDialog() {
      document.getElementById('playerTokenUrlInputSection').classList.remove('visible');
      document.getElementById('playerTokenImageUrlInput').value = '';
      document.getElementById('playerTokenUrlPreview').innerHTML = '';
      document.getElementById('playerTokenUrlAddBtn').disabled = true;
      document.getElementById('playerTokenImageSourceDialog').classList.add('visible');
    }

    function closePlayerTokenImageDialog(event) {
      if (event && event.target !== document.getElementById('playerTokenImageSourceDialog')) return;
      document.getElementById('playerTokenImageSourceDialog').classList.remove('visible');
      pendingPlayerTokenImageId = null;
    }

    function choosePlayerTokenFileUpload() {
      document.getElementById('playerTokenImageSourceDialog').classList.remove('visible');
      document.getElementById('playerTokenImageInput').click();
    }

    function showPlayerTokenUrlInput() {
      document.getElementById('playerTokenUrlInputSection').classList.add('visible');
      document.getElementById('playerTokenImageUrlInput').focus();
    }

    function handlePlayerTokenUrlKeyup(event) {
      if (event.key === 'Enter' && !document.getElementById('playerTokenUrlAddBtn').disabled) {
        addPlayerTokenUrl();
      }
    }

    function previewPlayerTokenUrlImage() {
      const url = document.getElementById('playerTokenImageUrlInput').value.trim();
      const preview = document.getElementById('playerTokenUrlPreview');
      const addBtn = document.getElementById('playerTokenUrlAddBtn');

      if (!url) {
        preview.innerHTML = '';
        addBtn.disabled = true;
        return;
      }

      preview.innerHTML = `<img src="${url}" alt="Preview" onerror="this.parentElement.innerHTML='Invalid URL'" onload="document.getElementById('playerTokenUrlAddBtn').disabled=false">`;
    }

    function addPlayerTokenUrl() {
      const url = document.getElementById('playerTokenImageUrlInput').value.trim();
      if (!url || !pendingPlayerTokenImageId) return;

      const token = battleMapTokens.find(t => t.id === pendingPlayerTokenImageId);
      if (token) {
        token.image = url;
        renderTokenList();
        syncBattleMap();
      }
      pendingPlayerTokenImageId = null;

      closePlayerTokenImageDialog();
    }

    function uploadPlayerTokenImage(tokenId) {
      pendingPlayerTokenImageId = tokenId;
      showPlayerTokenImageDialog();
    }

    // ===== NPC Portrait Image Dialog Functions =====
    function showNpcImageDialog() {
      document.getElementById('npcUrlInputSection').classList.remove('visible');
      document.getElementById('npcImageUrlInput').value = '';
      document.getElementById('npcUrlPreview').innerHTML = '';
      document.getElementById('npcUrlAddBtn').disabled = true;
      document.getElementById('npcImageSourceDialog').classList.add('visible');
    }

    function closeNpcImageDialog(event) {
      if (event && event.target !== document.getElementById('npcImageSourceDialog')) return;
      document.getElementById('npcImageSourceDialog').classList.remove('visible');
    }

    function chooseNpcFileUpload() {
      document.getElementById('npcImageSourceDialog').classList.remove('visible');
      document.getElementById('npcImageInput').click();
    }

    function showNpcUrlInput() {
      document.getElementById('npcUrlInputSection').classList.add('visible');
      document.getElementById('npcImageUrlInput').focus();
    }

    function handleNpcUrlKeyup(event) {
      if (event.key === 'Enter' && !document.getElementById('npcUrlAddBtn').disabled) {
        addNpcUrl();
      }
    }

    function previewNpcUrlImage() {
      const url = document.getElementById('npcImageUrlInput').value.trim();
      const preview = document.getElementById('npcUrlPreview');
      const addBtn = document.getElementById('npcUrlAddBtn');

      if (!url) {
        preview.innerHTML = '';
        addBtn.disabled = true;
        return;
      }

      preview.innerHTML = `<img src="${url}" alt="Preview" onerror="this.parentElement.innerHTML='Invalid URL'" onload="document.getElementById('npcUrlAddBtn').disabled=false">`;
    }

    function addNpcUrl() {
      const url = document.getElementById('npcImageUrlInput').value.trim();
      if (!url) return;

      currentNpcImage = url;
      updateNpcPreview();
      syncNpcToStorage();
      closeNpcImageDialog();
    }

    // ===== Image Gallery Browser Functions =====
    let galleryCallback = null;
    let selectedGalleryImageUrl = null;
    let cachedGalleryImages = null;

    async function openImageGallery(callback) {
      galleryCallback = callback;
      selectedGalleryImageUrl = null;
      document.getElementById('gallerySelectBtn').disabled = true;
      document.getElementById('imageGalleryOverlay').classList.add('visible');

      const content = document.getElementById('imageGalleryContent');
      content.innerHTML = '<div class="image-gallery-loading">Loading images...</div>';

      // Check if cloud features available
      if (!window.cloudFeatures?.canUse?.('cloudSave')) {
        content.innerHTML = '<div class="image-gallery-empty">Cloud storage requires a subscription to browse uploaded images.</div>';
        return;
      }

      try {
        const result = await window.cloudFeatures.listFiles();
        cachedGalleryImages = result.files;

        if (!result.files || result.files.length === 0) {
          content.innerHTML = '<div class="image-gallery-empty">No images uploaded yet. Upload some images first!</div>';
          return;
        }

        renderGalleryImages(result.files);
      } catch (err) {
        console.error('Failed to load images:', err);
        content.innerHTML = '<div class="image-gallery-empty">Failed to load images. Please try again.</div>';
      }
    }

    function renderGalleryImages(files) {
      const content = document.getElementById('imageGalleryContent');
      content.innerHTML = `<div class="image-gallery-grid">
        ${files.map(file => `
          <div class="image-gallery-item" onclick="selectGalleryItem(this, '${file.url}')" data-url="${file.url}">
            <img src="${file.url}" alt="${file.filename}" loading="lazy">
            <div class="image-gallery-item-name">${file.filename}</div>
          </div>
        `).join('')}
      </div>`;
    }

    function selectGalleryItem(element, url) {
      // Remove previous selection
      document.querySelectorAll('.image-gallery-item.selected').forEach(el => el.classList.remove('selected'));

      // Select current
      element.classList.add('selected');
      selectedGalleryImageUrl = url;
      document.getElementById('gallerySelectBtn').disabled = false;
    }

    function selectGalleryImage() {
      if (selectedGalleryImageUrl && galleryCallback) {
        galleryCallback(selectedGalleryImageUrl);
      }
      closeImageGallery();
    }

    function closeImageGallery(event) {
      if (event && event.target !== document.getElementById('imageGalleryOverlay')) return;
      document.getElementById('imageGalleryOverlay').classList.remove('visible');
      galleryCallback = null;
      selectedGalleryImageUrl = null;
    }

    // Gallery openers for each context
    function browseMapImages() {
      document.getElementById('mapImageSourceDialog').classList.remove('visible');
      openImageGallery((url) => {
        setMapFromUrl(url);
      });
    }

    function browsePlayerTokenImages() {
      document.getElementById('playerTokenImageSourceDialog').classList.remove('visible');
      openImageGallery((url) => {
        if (pendingPlayerTokenImageId) {
          const token = battleMapTokens.find(t => t.id === pendingPlayerTokenImageId);
          if (token) {
            token.image = url;
            renderTokenList();
            syncBattleMap();
          }
          pendingPlayerTokenImageId = null;
        }
      });
    }

    function browseNpcImages() {
      document.getElementById('npcImageSourceDialog').classList.remove('visible');
      openImageGallery((url) => {
        currentNpcImage = url;
        updateNpcPreview();
        syncNpcToStorage();
      });
    }

    function browseAdversaryImages() {
      document.getElementById('imageSourceDialog').classList.remove('visible');
      openImageGallery((url) => {
        if (pendingImageUploadAdversaryId) {
          const adv = currentEncounter?.adversaries.find(a => a.id === pendingImageUploadAdversaryId);
          if (adv) {
            if (!adv.portraits) adv.portraits = [];
            adv.portraits.push(url);
            adv.activePortraitIndex = adv.portraits.length - 1;

            const token = battleMapTokens.find(t => t.id === adv.id);
            if (token) {
              token.image = url;
              syncBattleMap();
            }

            renderEncounter();
            saveEncounterState();

            if (spotlightedAdversary === adv.id) {
              syncSpotlight();
            }
          }
          pendingImageUploadAdversaryId = null;
        }
      });
    }

    async function handleAdversaryImageUpload(event) {
      const files = event.target.files;
      if (!files.length || !pendingImageUploadAdversaryId) return;

      const adv = currentEncounter?.adversaries.find(a => a.id === pendingImageUploadAdversaryId);
      if (!adv) return;

      for (const file of Array.from(files)) {
        const imageUrl = await uploadImageToCloud(file);

        if (!adv.portraits) adv.portraits = [];
        adv.portraits.push(imageUrl);
        adv.activePortraitIndex = adv.portraits.length - 1;

        const token = battleMapTokens.find(t => t.id === adv.id);
        if (token) {
          token.image = imageUrl;
          syncBattleMap();
        }

        renderEncounter();
        saveEncounterState();

        if (spotlightedAdversary === adv.id) {
          syncSpotlight();
        }
      }

      pendingImageUploadAdversaryId = null;
    }

    // ========== NPC Portrait ==========
    async function handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Check file size (limit to 10MB for cloud, 5MB for local)
      if (file.size > 10 * 1024 * 1024) {
        alert('Image too large. Please select an image under 10MB.');
        return;
      }

      const imageUrl = await uploadImageToCloud(file);
      currentNpcImage = imageUrl;
      updateNpcPreview();
      syncNpcToStorage();
    }

    function clearNpcImage() {
      currentNpcImage = null;
      npcVisible = false;
      document.getElementById('npcImageInput').value = '';
      updateNpcPreview();
      syncNpcToStorage();
    }

    function toggleNpcVisibility() {
      npcVisible = document.getElementById('npcVisibilityToggle').checked;
      syncNpcToStorage();
    }

    function updateNpcPreview() {
      const preview = document.getElementById('npcPreview');
      const placeholder = document.getElementById('npcPlaceholder');
      const toggle = document.getElementById('npcVisibilityToggle');

      if (currentNpcImage) {
        preview.src = currentNpcImage;
        preview.style.display = 'block';
        placeholder.style.display = 'none';
        toggle.disabled = false;
      } else {
        preview.style.display = 'none';
        placeholder.style.display = 'block';
        toggle.disabled = true;
        toggle.checked = false;
      }
    }

    // Sync NPC data to localStorage and Firebase
    function syncNpcToStorage() {
      const npcData = {
        image: currentNpcImage,
        visible: npcVisible,
        timestamp: Date.now()
      };

      // If Firebase connected, send via Firebase
      if (roomRef) {
        sendToPlayer({ type: 'npc', ...npcData });

        // Save metadata only to localStorage
        const metadataOnly = { ...npcData, image: null };
        try {
          localStorage.setItem('daggerheart-npc', JSON.stringify(metadataOnly));
        } catch (e) {
          console.error('Failed to save NPC metadata:', e);
        }
      } else {
        // No Firebase - save to localStorage (may fail for large images)
        try {
          localStorage.setItem('daggerheart-npc', JSON.stringify(npcData));
        } catch (e) {
          console.error('Failed to save NPC to localStorage:', e);
          if (e.name === 'QuotaExceededError' || e.code === 22) {
            alert('Image too large for localStorage. Connect via room code for remote display.');
          }
        }
      }
      localStorage.setItem('daggerheart-update', Date.now().toString());
    }

    // ========== Player Token Image ==========
    async function handlePlayerTokenImageUpload(event) {
      const file = event.target.files[0];
      if (!file || !pendingPlayerTokenImageId) return;

      const imageUrl = await uploadImageToCloud(file);
      const token = battleMapTokens.find(t => t.id === pendingPlayerTokenImageId);
      if (token) {
        token.image = imageUrl;
        renderTokenList();
        syncBattleMap();
      }
      pendingPlayerTokenImageId = null;
    }

    // ========== Gun.js Connection ==========
    function generateRoomCode() {
      const adjectives = ['RED', 'BLUE', 'GOLD', 'DARK', 'WILD', 'IRON', 'FIRE', 'FROST', 'STORM', 'SHADOW'];
      const nouns = ['WOLF', 'HAWK', 'BEAR', 'LION', 'RAVEN', 'DRAGON', 'SWORD', 'CROWN', 'FLAME', 'BLADE'];
      const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
      const noun = nouns[Math.floor(Math.random() * nouns.length)];
      const num = Math.floor(Math.random() * 100).toString().padStart(2, '0');
      return `${adj}-${noun}-${num}`;
    }

    function copyRoomCode() {
      if (roomCode) {
        navigator.clipboard.writeText(roomCode).then(() => {
          const btn = document.getElementById('connectionBtn');
          btn.textContent = 'Copied!';
          setTimeout(() => { btn.textContent = 'Room: ' + roomCode; }, 1500);
        });
      }
    }

    function initFirebaseHost() {
      roomCode = generateRoomCode();
      document.getElementById('roomCodeDisplay').textContent = roomCode;
      document.getElementById('connectionBtn').textContent = 'Room: ' + roomCode;

      const dot = document.getElementById('connectionDot');
      const text = document.getElementById('connectionText');
      const statusText = document.getElementById('connectionStatusText');

      // Check if Firebase is loaded and configured
      if (!database) {
        text.textContent = 'Firebase not configured';
        statusText.textContent = 'Offline';
        console.error('Firebase not initialized. Please add your Firebase config.');
        return;
      }

      try {
        // Create room reference in Firebase
        roomRef = database.ref('rooms/' + roomCode);

        // Mark room as active with GM heartbeat
        roomRef.child('gm').set({
          active: true,
          timestamp: Date.now()
        });

        // Start GM heartbeat to keep room alive
        if (heartbeatInterval) clearInterval(heartbeatInterval);
        heartbeatInterval = setInterval(() => {
          if (roomRef) {
            roomRef.child('gm').update({
              active: true,
              timestamp: Date.now()
            });
          }
        }, 10000);

        // Clean up room when GM disconnects
        roomRef.child('gm').onDisconnect().set({
          active: false,
          timestamp: Date.now()
        });

        console.log('GM hosting with room code:', roomCode);
        text.textContent = 'Room ready';
        statusText.textContent = 'Ready';
        dot.classList.add('connected');
        document.getElementById('connectionBtn').classList.add('connected');

        // Listen for client connections
        roomRef.child('clients').on('value', (snapshot) => {
          const clients = snapshot.val();
          if (clients) {
            let activeCount = 0;
            Object.entries(clients).forEach(([clientId, client]) => {
              if (client && client.connected && (Date.now() - client.timestamp) < 30000) {
                activeCount++;
                // If a client requests sync, send it
                if (client.requestSync) {
                  sendFullSync();
                  // Clear the sync request
                  roomRef.child('clients').child(clientId).child('requestSync').set(false);
                }
              }
            });
            connectedClients = activeCount;
            if (activeCount > 0) {
              text.textContent = `${activeCount} client(s) connected`;
              statusText.textContent = 'Connected';
            }
          }
        });

        // Listen for battle map sync requests
        roomRef.child('battleMapRequest').on('value', (snapshot) => {
          const request = snapshot.val();
          if (request && request.timestamp && (Date.now() - request.timestamp) < 5000) {
            syncBattleMap();
          }
        });

        // Send initial state
        setTimeout(() => {
          sendFullSync();
        }, 1000);

      } catch (e) {
        console.error('Failed to initialize Firebase:', e);
        text.textContent = 'Init failed - local mode';
        statusText.textContent = 'Local Mode';
      }
    }

    function sendToPlayer(data) {
      if (!roomRef) return;

      try {
        // Add timestamp to data
        data.timestamp = Date.now();

        // Route data to appropriate Firebase node based on type
        switch (data.type) {
          case 'fear':
            roomRef.child('fear').set({ value: data.value, timestamp: data.timestamp });
            break;
          case 'hopefear':
          case 'dice':
            roomRef.child('dice').set({
              type: data.type,
              notation: data.notation || null,
              total: data.total || null,
              hope: data.hope || null,
              fear: data.fear || null,
              sum: data.sum || null,
              winner: data.winner || null,
              critical: data.critical || false,
              breakdown: data.breakdown || null,
              timestamp: data.timestamp
            });
            break;
          case 'spotlight':
            roomRef.child('spotlight').set({
              visible: data.visible,
              adversaryId: data.adversaryId || null,
              name: data.name || null,
              image: data.image || null,
              isDefaultImage: data.isDefaultImage || false,
              defeated: data.defeated || false,
              conditions: data.conditions || {},
              timestamp: data.timestamp
            });
            break;
          case 'npc':
            roomRef.child('npc').set({
              visible: data.visible,
              image: data.image || null,
              timestamp: data.timestamp
            });
            break;
          case 'countdowns':
            roomRef.child('countdowns').set({
              countdowns: data.countdowns || [],
              timestamp: data.timestamp
            });
            break;
          case 'sync':
            roomRef.child('sync').set({
              fear: data.fear,
              spotlight: data.spotlight || null,
              timestamp: data.timestamp
            });
            break;
          default:
            console.log('Unknown data type:', data.type);
        }
      } catch (e) {
        console.error('Failed to send via Firebase:', e);
      }
    }

    function sendToBattleMap(data) {
      if (!roomRef) return;

      try {
        data.timestamp = Date.now();

        switch (data.type) {
          case 'map':
            roomRef.child('map').set({
              type: 'map',
              visible: data.visible,
              mapImage: data.mapImage || null,
              gridSize: data.gridSize || 50,
              timestamp: data.timestamp
            });
            break;
          case 'tokens':
            roomRef.child('tokens').set({
              type: 'tokens',
              tokens: data.tokens || [],
              timestamp: data.timestamp
            });
            break;
          case 'grid':
            roomRef.child('grid').set({
              type: 'grid',
              visible: data.visible,
              timestamp: data.timestamp
            });
            break;
          case 'mapSync':
            roomRef.child('mapSync').set({
              type: 'mapSync',
              map: data.map || null,
              tokens: data.tokens || null,
              grid: data.grid || null,
              timestamp: data.timestamp
            });
            break;
        }
      } catch (e) {
        console.error('Failed to send battle map data via Firebase:', e);
      }
    }

    function sendFullSync() {
      if (!roomRef) return;

      const syncData = {
        type: 'sync',
        fear: currentFear,
        spotlight: null
      };

      if (spotlightedAdversary && currentEncounter) {
        const adv = currentEncounter.adversaries.find(a => a.id === spotlightedAdversary);
        if (adv) {
          const isDefeated = adv.hp !== undefined && adv.currentHp <= 0;
          const hasPortrait = adv.portraits && adv.portraits.length > 0;

          syncData.spotlight = {
            visible: true,
            adversaryId: adv.id,
            name: adv.name,
            image: hasPortrait ? adv.portraits[adv.activePortraitIndex || 0] : getDefaultImageForAdversary(adv),
            isDefaultImage: !hasPortrait,
            defeated: isDefeated,
            conditions: adv.conditions || {},
            timestamp: Date.now()
          };
        }
      }

      sendToPlayer(syncData);
      syncBattleMap();
    }

    // ========== Display Windows ==========
    function openPlayerDisplay() {
      const width = 1200;
      const height = 800;
      const left = (screen.width - width) / 2;
      const top = (screen.height - height) / 2;
      window.open('player-display.html', 'PlayerDisplay', `width=${width},height=${height},left=${left},top=${top}`);
    }

    function openBattleMap() {
      const width = 1200;
      const height = 800;
      const left = (screen.width - width) / 2;
      const top = (screen.height - height) / 2;
      window.open('battle-map.html', 'BattleMap', `width=${width},height=${height},left=${left},top=${top}`);
    }

    // ========== Adversary Database ==========
    async function loadAdversaryDatabase() {
      try {
        const response = await fetch('daggerheart_creatures.json');
        const creatures = await response.json();

        // Transform JSON data to match expected format
        adversaryDatabase = creatures.map(creature => {
          // Determine themes from creature properties
          const themes = inferThemes(creature);

          // Format attack string
          let attackStr = '';
          if (creature.attack) {
            const mod = creature.attack.modifier >= 0 ? `+${creature.attack.modifier}` : `${creature.attack.modifier}`;
            attackStr = `${mod} (${creature.attack.damage})`;
            if (creature.attack.range && creature.attack.range !== 'Melee' && creature.attack.range !== 'Very Close') {
              attackStr += `, ${creature.attack.range}`;
            }
          }

          // Get features for display
          const features = creature.features ? creature.features.map(f => {
            return {
              name: f.name,
              type: f.type,
              description: f.description
            };
          }) : [];

          // Format abilities from features for display
          const abilities = creature.features ? creature.features.map(f => {
            return `${f.name}: ${f.description}`;
          }) : [];

          // Determine traits from description and features
          const traits = extractTraits(creature);

          return {
            name: creature.name,
            tier: creature.tier || 1,
            role: creature.role || 'Standard',
            hp: creature.hp || 5,
            stress: creature.stress || 3,
            themes: themes,
            difficulty: creature.difficulty || 10,
            thresholds: creature.thresholds || null,
            attack: attackStr,
            attackData: creature.attack || null,
            defense: creature.difficulty || 10,
            experience: creature.experience || '',
            features: features,
            abilities: abilities,
            traits: traits,
            description: creature.description || '',
            motives: creature.motives || '',
            portrait: creature.portrait || null
          };
        });

        console.log(`Loaded ${adversaryDatabase.length} creatures from database`);
      } catch (error) {
        console.error('Error loading creature database:', error);
        // Fallback to minimal data
        adversaryDatabase = [
          { name: 'Skeleton Warrior', tier: 1, role: 'Minion', hp: 6, stress: 3, themes: ['undead'], difficulty: 11, defense: 11, attack: '+2 (2d6+2 phy)', traits: ['Minion', 'Undead'], abilities: [] },
          { name: 'Skeleton Archer', tier: 1, role: 'Minion', hp: 4, stress: 2, themes: ['undead'], difficulty: 10, defense: 10, attack: '+3 (2d6+1 phy, Far)', traits: ['Minion', 'Undead'], abilities: [] },
          { name: 'Zombie', tier: 1, role: 'Minion', hp: 8, stress: 2, themes: ['undead'], difficulty: 10, defense: 10, attack: '+0 (1d6+3 phy)', traits: ['Minion', 'Undead'], abilities: [] },
          { name: 'Ghost', tier: 2, role: 'Standard', hp: 12, stress: 6, themes: ['undead'], difficulty: 14, defense: 14, attack: '+2 (2d6+2 mag)', traits: ['Standard', 'Undead'], abilities: [] },
          { name: 'Goblin Scout', tier: 1, role: 'Minion', hp: 4, stress: 2, themes: ['bandits'], difficulty: 10, defense: 10, attack: '+0 (1d4 phy)', traits: ['Minion'], abilities: [] },
          { name: 'Wolf', tier: 1, role: 'Minion', hp: 6, stress: 3, themes: ['beasts'], difficulty: 12, defense: 12, attack: '+2 (1d6+2 phy)', traits: ['Minion'], abilities: [] },
          { name: 'Bear', tier: 2, role: 'Standard', hp: 20, stress: 8, themes: ['beasts'], difficulty: 14, defense: 14, attack: '+1 (1d8+3 phy)', traits: ['Standard'], abilities: [] },
          { name: 'Bandit', tier: 1, role: 'Minion', hp: 5, stress: 3, themes: ['bandits'], difficulty: 10, defense: 10, attack: '+1 (1d6+2 phy)', traits: ['Minion'], abilities: [] },
          { name: 'Elemental', tier: 2, role: 'Standard', hp: 16, stress: 6, themes: ['elementals'], difficulty: 12, defense: 12, attack: '+2 (1d8+2 mag)', traits: ['Standard'], abilities: [] }
        ];
      }
    }

    // Helper function to infer themes from creature data
    function inferThemes(creature) {
      const themes = [];
      const name = creature.name.toLowerCase();
      const desc = (creature.description || '').toLowerCase();
      const motives = (creature.motives || '').toLowerCase();

      // Theme detection based on name and description
      if (name.includes('skeleton') || name.includes('zombie') || name.includes('undead') ||
          name.includes('vampire') || name.includes('ghost') || name.includes('wraith') ||
          desc.includes('undead') || desc.includes('necro')) {
        themes.push('undead');
      }
      if (name.includes('bandit') || name.includes('thief') || name.includes('rogue') ||
          name.includes('jagged knife') || name.includes('assassin') || desc.includes('bandit') || motives.includes('steal')) {
        themes.push('bandits');
      }
      if (name.includes('guard') || name.includes('knight') || name.includes('soldier') ||
          desc.includes('guard') || motives.includes('arrest')) {
        themes.push('guards');
      }
      if (name.includes('wolf') || name.includes('bear') || name.includes('beast') ||
          name.includes('spider') || name.includes('scorpion') || name.includes('rat') ||
          name.includes('burrower') || name.includes('mosquito') || desc.includes('animal')) {
        themes.push('beasts');
      }
      if (name.includes('demon') || desc.includes('demon') || desc.includes('fiend')) {
        themes.push('demons');
      }
      if (name.includes('elemental') || desc.includes('elemental')) {
        themes.push('elementals');
      }
      if (name.includes('ooze') || name.includes('slime') || desc.includes('ooze')) {
        themes.push('oozes');
      }
      if (name.includes('construct') || desc.includes('construct') || desc.includes('golem')) {
        themes.push('constructs');
      }
      if (name.includes('ogre') || name.includes('giant') || name.includes('troll') ||
          desc.includes('giant')) {
        themes.push('giants');
      }
      if (name.includes('pirate') || name.includes('corsair') || desc.includes('pirate')) {
        themes.push('pirates');
      }
      if (name.includes('tree') || name.includes('plant') || name.includes('dryad') ||
          name.includes('defender') || desc.includes('plant') || desc.includes('nature')) {
        themes.push('nature');
      }
      if (creature.role === 'Social' || name.includes('courtier') || name.includes('noble')) {
        themes.push('social');
      }

      return themes.length > 0 ? themes : ['other'];
    }

    // Helper function to extract traits from creature data
    function extractTraits(creature) {
      const traits = [];
      const desc = (creature.description || '').toLowerCase();
      const role = (creature.role || '').toLowerCase();

      // Add role as a trait
      if (creature.role) {
        traits.push(creature.role);
      }

      // Extract traits from description
      if (desc.includes('undead')) traits.push('Undead');
      if (desc.includes('flying') || desc.includes('fly')) traits.push('Flying');
      if (desc.includes('armored') || desc.includes('armor')) traits.push('Armored');
      if (desc.includes('magical') || desc.includes('magic')) traits.push('Magical');
      if (desc.includes('stealthy') || desc.includes('stealth')) traits.push('Stealthy');
      if (desc.includes('fearless')) traits.push('Fearless');
      if (desc.includes('aquatic') || desc.includes('water')) traits.push('Aquatic');

      // Add features that sound like traits
      if (creature.features) {
        creature.features.forEach(f => {
          if (f.type === 'Passive' && f.name.length < 20) {
            traits.push(f.name);
          }
        });
      }

      return traits.length > 0 ? traits : ['Standard'];
    }

    // ========== Battle Queue ==========
    function openStageBattleModal(battleId = null) {
      editingStagedBattleId = battleId;
      const modal = document.getElementById('stageBattleModal');

      if (battleId) {
        // Editing existing battle
        const battle = stagedBattles.find(b => b.id === battleId);
        if (battle) {
          document.getElementById('stageModalTitle').textContent = 'Edit Staged Battle';
          document.getElementById('stageBattleName').value = battle.name;
          document.getElementById('stageBattleNotes').value = battle.notes || '';
          document.getElementById('stageSaveBtn').textContent = 'Update Battle';
        }
      } else {
        // New battle
        document.getElementById('stageModalTitle').textContent = 'Stage Current Battle';
        document.getElementById('stageBattleName').value = currentEncounter?.name || '';
        document.getElementById('stageBattleNotes').value = '';
        document.getElementById('stageSaveBtn').textContent = 'Stage Battle';
      }

      // Update summary
      document.getElementById('stageSummaryMap').textContent = currentMap ? 'Yes' : 'None';
      document.getElementById('stageSummaryAdversaries').textContent = currentEncounter?.adversaries?.length || 0;
      document.getElementById('stageSummaryTokens').textContent = battleMapTokens.length;
      const positionedTokens = battleMapTokens.filter(t => t.x !== undefined && t.y !== undefined).length;
      document.getElementById('stageSummaryPositioned').textContent = positionedTokens;

      modal.classList.add('visible');
      document.getElementById('stageBattleName').focus();
    }

    function closeStageBattleModal(event) {
      if (event && event.target !== document.getElementById('stageBattleModal')) return;
      document.getElementById('stageBattleModal').classList.remove('visible');
      editingStagedBattleId = null;
    }

    // ========== Settings Modal ==========
    function openSettingsModal() {
      const modal = document.getElementById('settingsModal');

      // Populate user info
      const userEmail = document.getElementById('user-name')?.textContent || '-';
      const userTier = window.cloudFeatures?.getEntitlement?.() || 'demo';

      document.getElementById('settings-user-email').textContent = userEmail;
      document.getElementById('settings-user-tier').textContent = userTier.toUpperCase();

      // Reset delete confirmation state
      document.getElementById('deleteAccountSection').style.display = 'block';
      document.getElementById('deleteConfirmationSection').style.display = 'none';
      document.getElementById('deleteConfirmInput').value = '';
      document.getElementById('confirmDeleteBtn').disabled = true;

      modal.classList.add('visible');
    }

    function closeSettingsModal(event) {
      if (event && event.target !== document.getElementById('settingsModal')) return;
      document.getElementById('settingsModal').classList.remove('visible');
    }

    function showDeleteConfirmation() {
      document.getElementById('deleteAccountSection').style.display = 'none';
      document.getElementById('deleteConfirmationSection').style.display = 'block';
      document.getElementById('deleteConfirmInput').focus();
    }

    function cancelDeleteConfirmation() {
      document.getElementById('deleteAccountSection').style.display = 'block';
      document.getElementById('deleteConfirmationSection').style.display = 'none';
      document.getElementById('deleteConfirmInput').value = '';
      document.getElementById('confirmDeleteBtn').disabled = true;
    }

    // Add input listener to enable/disable delete button
    document.addEventListener('DOMContentLoaded', () => {
      const deleteInput = document.getElementById('deleteConfirmInput');
      const confirmBtn = document.getElementById('confirmDeleteBtn');

      if (deleteInput && confirmBtn) {
        deleteInput.addEventListener('input', () => {
          confirmBtn.disabled = deleteInput.value.toLowerCase() !== 'delete';
        });
      }
    });

    async function confirmDeleteAccount() {
      const input = document.getElementById('deleteConfirmInput');
      if (input.value.toLowerCase() !== 'delete') {
        return;
      }

      try {
        const result = await window.cloudFeatures?.deleteAccount?.();
        if (result) {
          alert('Your account and all associated data have been deleted.');
          // Sign out and redirect
          window.location.reload();
        }
      } catch (err) {
        console.error('Failed to delete account:', err);
        alert('Failed to delete account: ' + (err.message || 'Unknown error'));
      }
    }

    function saveStagedBattle() {
      const name = document.getElementById('stageBattleName').value.trim();
      if (!name) {
        alert('Please enter a battle name.');
        return;
      }

      const notes = document.getElementById('stageBattleNotes').value.trim();

      if (editingStagedBattleId) {
        // Update existing battle with current state
        const battle = stagedBattles.find(b => b.id === editingStagedBattleId);
        if (battle) {
          battle.name = name;
          battle.notes = notes;
          battle.encounter = currentEncounter ? JSON.parse(JSON.stringify(currentEncounter)) : null;
          battle.map = currentMap ? {
            mapImage: currentMap.mapImage,
            gridSize: currentMap.gridSize || gridSize
          } : null;
          battle.mapVisible = mapVisible;
          battle.gridVisible = gridVisible;
          battle.tokens = JSON.parse(JSON.stringify(battleMapTokens));
          battle.updatedAt = Date.now();
        }
      } else {
        // Create new staged battle
        const stagedBattle = {
          id: 'battle-' + Math.random().toString(36).substr(2, 9),
          name: name,
          notes: notes,
          encounter: currentEncounter ? JSON.parse(JSON.stringify(currentEncounter)) : null,
          map: currentMap ? {
            mapImage: currentMap.mapImage,
            gridSize: currentMap.gridSize || gridSize
          } : null,
          mapVisible: mapVisible,
          gridVisible: gridVisible,
          tokens: JSON.parse(JSON.stringify(battleMapTokens)),
          createdAt: Date.now(),
          order: stagedBattles.length
        };

        stagedBattles.push(stagedBattle);
      }

      saveStagedBattles();
      renderQueueList();
      updateTabBadges();
      closeStageBattleModal();
    }

    function loadStagedBattle(battleId) {
      const battle = stagedBattles.find(b => b.id === battleId);
      if (!battle) return;

      if (!confirm(`Load "${battle.name}"? This will replace your current battle setup.`)) {
        return;
      }

      // Clear current state
      currentEncounter = null;
      currentMap = null;
      mapVisible = false;
      gridVisible = false;
      battleMapTokens = [];
      spotlightedAdversary = null;

      // Load battle state
      if (battle.encounter) {
        currentEncounter = JSON.parse(JSON.stringify(battle.encounter));
        // Reset HP/stress to starting values for fresh battle
        currentEncounter.adversaries.forEach(adv => {
          adv.currentHp = adv.hp;
          adv.currentStress = adv.stress;
          adv.conditions = { hidden: false, restrained: false, vulnerable: false };
        });
      }

      if (battle.map) {
        currentMap = {
          mapImage: battle.map.mapImage,
          gridSize: battle.map.gridSize || 50
        };
        gridSize = currentMap.gridSize;

        // Update map preview
        const preview = document.getElementById('mapPreview');
        const placeholder = document.getElementById('mapPlaceholder');
        if (preview && placeholder) {
          preview.src = currentMap.mapImage;
          preview.style.display = 'block';
          placeholder.style.display = 'none';

          // Wait for image to load, then render grid and tokens
          preview.onload = () => {
            setTimeout(() => {
              drawMapPreviewGrid();
              renderMapPreviewTokens();
            }, 50);
          };
        }
      } else {
        const preview = document.getElementById('mapPreview');
        const placeholder = document.getElementById('mapPlaceholder');
        if (preview && placeholder) {
          preview.style.display = 'none';
          placeholder.style.display = 'block';
        }
        drawMapPreviewGrid();
        renderMapPreviewTokens();
      }

      mapVisible = battle.mapVisible || false;
      gridVisible = battle.gridVisible || false;

      // Update visibility buttons
      const mapVisBtn = document.getElementById('mapVisBtn');
      const gridBtn = document.getElementById('gridBtn');
      if (mapVisBtn) {
        mapVisBtn.textContent = mapVisible ? 'Hide' : 'Show';
        mapVisBtn.classList.toggle('active', mapVisible);
      }
      if (gridBtn) {
        gridBtn.classList.toggle('active', gridVisible);
      }

      if (battle.tokens) {
        const tokens = JSON.parse(JSON.stringify(battle.tokens));
        // Handle both array and { tokens: [...] } format
        battleMapTokens = Array.isArray(tokens) ? tokens : (tokens.tokens || []);
      }

      // Update all UIs
      renderEncounter();
      renderTokenList();
      saveEncounterState();
      syncBattleMap();
      updateTabBadges();

      // Switch to Battle tab
      switchTab('battle');

      console.log(`Loaded staged battle: ${battle.name}`);
    }

    function deleteStagedBattle(battleId) {
      const battle = stagedBattles.find(b => b.id === battleId);
      if (!battle) return;

      if (!confirm(`Delete "${battle.name}" from the queue?`)) {
        return;
      }

      stagedBattles = stagedBattles.filter(b => b.id !== battleId);
      // Re-number remaining battles
      stagedBattles.forEach((b, i) => b.order = i);

      saveStagedBattles();
      renderQueueList();
      updateTabBadges();
    }

    function toggleBattlePreview(battleId) {
      const previewEl = document.getElementById(`preview-${battleId}`);
      if (previewEl) {
        previewEl.classList.toggle('visible');
      }
    }

    function moveBattleUp(battleId) {
      const index = stagedBattles.findIndex(b => b.id === battleId);
      if (index > 0) {
        [stagedBattles[index - 1], stagedBattles[index]] = [stagedBattles[index], stagedBattles[index - 1]];
        stagedBattles.forEach((b, i) => b.order = i);
        saveStagedBattles();
        renderQueueList();
      }
    }

    function moveBattleDown(battleId) {
      const index = stagedBattles.findIndex(b => b.id === battleId);
      if (index < stagedBattles.length - 1) {
        [stagedBattles[index], stagedBattles[index + 1]] = [stagedBattles[index + 1], stagedBattles[index]];
        stagedBattles.forEach((b, i) => b.order = i);
        saveStagedBattles();
        renderQueueList();
      }
    }

    function renderQueueList() {
      const container = document.getElementById('queueContainer');

      if (stagedBattles.length === 0) {
        container.innerHTML = `
          <div class="queue-empty">
            <div class="queue-empty-icon">&#9876;</div>
            <div>No battles staged yet.</div>
            <div style="margin-top: 8px; font-size: 0.8rem;">
              Set up your battle map, tokens, and encounter, then click "Stage Current Battle" to save it to the queue.
            </div>
          </div>
        `;
        return;
      }

      container.innerHTML = stagedBattles.map((battle, index) => {
        const adversaryCount = battle.encounter?.adversaries?.length || 0;
        const tokenCount = battle.tokens?.length || 0;
        const playerTokens = battle.tokens?.filter(t => t.type === 'player') || [];
        const adversaryTokens = battle.tokens?.filter(t => t.type === 'adversary') || [];
        const hasMap = !!battle.map?.mapImage;

        return `
          <div class="staged-battle-card" draggable="true" data-battle-id="${battle.id}"
               ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)"
               ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
            <div class="staged-battle-header">
              <div class="staged-battle-order">${index + 1}</div>
              <div class="staged-battle-info">
                <div class="staged-battle-name">${escapeHtml(battle.name)}</div>
                <div class="staged-battle-meta">
                  <span>${adversaryCount} adversar${adversaryCount === 1 ? 'y' : 'ies'}</span>
                  <span>${tokenCount} token${tokenCount === 1 ? '' : 's'}</span>
                  <span>${hasMap ? 'Map ready' : 'No map'}</span>
                </div>
              </div>
              <div class="staged-battle-actions">
                <button class="staged-action-btn load" onclick="loadStagedBattle('${battle.id}')">Load</button>
                <button class="staged-action-btn preview" onclick="toggleBattlePreview('${battle.id}')">Preview</button>
                <button class="staged-action-btn edit" onclick="openStageBattleModal('${battle.id}')">Edit</button>
                <button class="staged-action-btn delete" onclick="deleteStagedBattle('${battle.id}')">Delete</button>
              </div>
            </div>
            <div class="staged-battle-preview" id="preview-${battle.id}">
              <div class="preview-grid">
                <div class="preview-map">
                  ${hasMap
                    ? `<img src="${battle.map.mapImage}" alt="Map preview">`
                    : '<span class="preview-map-placeholder">No map</span>'}
                </div>
                <div class="preview-details">
                  ${adversaryCount > 0 ? `
                    <div class="preview-section">
                      <div class="preview-section-title">Adversaries</div>
                      <div class="preview-adversaries">
                        ${battle.encounter.adversaries.map(a => `<span class="preview-adv-tag">${escapeHtml(a.name)}</span>`).join('')}
                      </div>
                    </div>
                  ` : ''}
                  ${tokenCount > 0 ? `
                    <div class="preview-section">
                      <div class="preview-section-title">Tokens</div>
                      <div class="preview-tokens">
                        ${playerTokens.map(t => `<span class="preview-token-tag">${escapeHtml(t.name)}</span>`).join('')}
                        ${adversaryTokens.map(t => `<span class="preview-token-tag adversary">${escapeHtml(t.name)}</span>`).join('')}
                      </div>
                    </div>
                  ` : ''}
                  ${battle.notes ? `
                    <div class="preview-section">
                      <div class="preview-section-title">Notes</div>
                      <div class="preview-notes">${escapeHtml(battle.notes)}</div>
                    </div>
                  ` : ''}
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Drag and drop for reordering
    let draggedBattleId = null;

    function handleDragStart(event) {
      draggedBattleId = event.target.dataset.battleId;
      event.target.style.opacity = '0.5';
    }

    function handleDragOver(event) {
      event.preventDefault();
      const card = event.target.closest('.staged-battle-card');
      if (card && card.dataset.battleId !== draggedBattleId) {
        card.classList.add('drag-over');
      }
    }

    function handleDrop(event) {
      event.preventDefault();
      const card = event.target.closest('.staged-battle-card');
      if (card && draggedBattleId) {
        const targetId = card.dataset.battleId;
        if (targetId !== draggedBattleId) {
          const fromIndex = stagedBattles.findIndex(b => b.id === draggedBattleId);
          const toIndex = stagedBattles.findIndex(b => b.id === targetId);

          if (fromIndex !== -1 && toIndex !== -1) {
            const [moved] = stagedBattles.splice(fromIndex, 1);
            stagedBattles.splice(toIndex, 0, moved);
            stagedBattles.forEach((b, i) => b.order = i);
            saveStagedBattles();
            renderQueueList();
          }
        }
      }
      document.querySelectorAll('.staged-battle-card').forEach(c => c.classList.remove('drag-over'));
    }

    function handleDragEnd(event) {
      event.target.style.opacity = '1';
      draggedBattleId = null;
      document.querySelectorAll('.staged-battle-card').forEach(c => c.classList.remove('drag-over'));
    }

    function saveStagedBattles() {
      try {
        // For localStorage, we need to be careful about size
        // Store map images separately if they're base64
        const battlesForStorage = stagedBattles.map(battle => {
          const stored = { ...battle };
          // Keep URL-based maps, but note if there was a base64 map
          if (stored.map && stored.map.mapImage) {
            if (stored.map.mapImage.startsWith('data:')) {
              // Store base64 maps (they can be large but usually fit)
              // If localStorage fails, we'll handle it
            }
          }
          return stored;
        });
        localStorage.setItem('daggerheart-staged-battles', JSON.stringify(battlesForStorage));
      } catch (e) {
        console.error('Failed to save staged battles:', e);
        alert('Failed to save battle queue. The data may be too large. Try using URL-based images instead of uploaded images.');
      }
    }

    function loadStagedBattles() {
      try {
        const data = localStorage.getItem('daggerheart-staged-battles');
        if (data) {
          stagedBattles = JSON.parse(data);
          // Sort by order
          stagedBattles.sort((a, b) => (a.order || 0) - (b.order || 0));
        }
      } catch (e) {
        console.error('Failed to load staged battles:', e);
        stagedBattles = [];
      }
    }

    function exportQueue() {
      if (stagedBattles.length === 0) {
        alert('No battles to export.');
        return;
      }

      const exportData = {
        version: 1,
        exportedAt: new Date().toISOString(),
        battles: stagedBattles
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `battle-queue-${new Date().toISOString().slice(0, 10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function handleImportQueue(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          if (!data.battles || !Array.isArray(data.battles)) {
            alert('Invalid battle queue file.');
            return;
          }

          const mode = confirm('Click OK to append battles to current queue, or Cancel to replace the current queue.');

          if (mode) {
            // Append
            const startOrder = stagedBattles.length;
            data.battles.forEach((battle, i) => {
              battle.id = 'battle-' + Math.random().toString(36).substr(2, 9);
              battle.order = startOrder + i;
              stagedBattles.push(battle);
            });
          } else {
            // Replace
            stagedBattles = data.battles.map((battle, i) => ({
              ...battle,
              id: 'battle-' + Math.random().toString(36).substr(2, 9),
              order: i
            }));
          }

          saveStagedBattles();
          renderQueueList();
          updateTabBadges();

          alert(`Imported ${data.battles.length} battle(s).`);
        } catch (err) {
          console.error('Import failed:', err);
          alert('Failed to import battle queue. Invalid file format.');
        }
      };
      reader.readAsText(file);

      // Reset input
      event.target.value = '';
    }

    function clearQueue() {
      if (stagedBattles.length === 0) return;

      if (!confirm(`Delete all ${stagedBattles.length} staged battle(s)?`)) {
        return;
      }

      stagedBattles = [];
      saveStagedBattles();
      renderQueueList();
      updateTabBadges();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ========== Session Management ==========
    function clearAllSessionData() {
      if (!confirm('This will clear all saved data including fear, NPC portrait, encounters, battle tokens, and staged battles. Are you sure?')) {
        return;
      }

      // Clear all daggerheart localStorage keys
      const keysToRemove = [
        'daggerheart-fear',
        'daggerheart-dice',
        'daggerheart-npc',
        'daggerheart-spotlight',
        'daggerheart-encounter',
        'daggerheart-battle-tokens',
        'daggerheart-gm-tokens',
        'daggerheart-battle-grid',
        'daggerheart-staged-battles',
        'daggerheart-battle-map-state',
        'daggerheart-last-room',
        'daggerheart-battlemap-last-room'
      ];
      keysToRemove.forEach(key => localStorage.removeItem(key));

      // Reset all in-memory state
      currentFear = 0;
      currentNpcImage = null;
      npcVisible = false;
      currentEncounter = null;
      spotlightedAdversary = null;
      battleMapTokens = [];
      stagedBattles = [];

      // Update UI
      updateFearDisplay();
      updateNpcPreview();
      document.getElementById('npcVisibilityToggle').checked = false;
      renderEncounter();
      renderTokenList();
      renderQueueList();
      updateTabBadges();

      // Notify Firebase clients to clear their state
      if (roomRef) {
        const timestamp = Date.now();
        roomRef.child('fear').set({ value: 0, timestamp });
        roomRef.child('npc').set({ visible: false, image: null, timestamp });
        roomRef.child('spotlight').set({ visible: false, timestamp });
        roomRef.child('tokens').set(null);
        roomRef.child('grid').set(null);
      }

      alert('Session data cleared. The page will now reload.');
      window.location.reload();
    }

    // ========== Initialize ==========
    function init() {
      // Load fear
      const storedFear = localStorage.getItem('daggerheart-fear');
      if (storedFear) {
        currentFear = parseInt(storedFear) || 0;
        updateFearDisplay();
      }

      // Load countdowns
      loadCountdowns();

      // Load NPC
      const npcData = localStorage.getItem('daggerheart-npc');
      if (npcData) {
        const parsed = JSON.parse(npcData);
        currentNpcImage = parsed.image;
        npcVisible = parsed.visible || false;
        updateNpcPreview();
        document.getElementById('npcVisibilityToggle').checked = npcVisible;
      }

      // Load encounter
      const encounterData = localStorage.getItem('daggerheart-encounter');
      if (encounterData) {
        const parsed = JSON.parse(encounterData);
        currentEncounter = parsed.encounter;
        renderEncounter();
      }

      // Load spotlight
      const spotlightData = localStorage.getItem('daggerheart-spotlight');
      if (spotlightData) {
        const parsed = JSON.parse(spotlightData);
        if (parsed.visible && parsed.adversaryId && currentEncounter) {
          spotlightedAdversary = parsed.adversaryId;
          updateSpotlightUI();
        }
      }

      // Load tokens - use GM tokens (includes hidden) with fallback to old key
      const gmTokensData = localStorage.getItem('daggerheart-gm-tokens');
      const tokensData = gmTokensData || localStorage.getItem('daggerheart-battle-tokens');
      if (tokensData) {
        const parsed = JSON.parse(tokensData);
        // Handle both old format (array) and new format ({ type: 'tokens', tokens: [...] })
        battleMapTokens = Array.isArray(parsed) ? parsed : (parsed.tokens || []);
        renderTokenList();
      }

      // Load adversary database
      loadAdversaryDatabase();

      // Load equipment database
      loadEquipmentDatabase();

      // Load staged battles
      loadStagedBattles();
      renderQueueList();

      // Initialize Firebase
      initFirebaseHost();

      // Render initial state
      renderTokenList();
      updateTabBadges();
    }

    // Start
    init();

    // Expose functions for cloud features integration
    window.getCurrentEncounterState = function() {
      return {
        adversaries: currentEncounter,
        fear: currentFear,
        tokens: battleMapTokens,
        spotlight: spotlightedAdversary,
        battleMap: {
          map: currentMap,
          mapVisible: mapVisible,
          gridVisible: gridVisible,
          gridSize: gridSize
        },
        battleQueue: stagedBattles
      };
    };

    window.loadEncounterState = function(state) {
      if (state.adversaries) {
        currentEncounter = state.adversaries;
        renderEncounter();
      }
      if (state.fear !== undefined) {
        currentFear = state.fear;
        updateFearDisplay();
      }
      if (state.tokens) {
        // Handle both array and { tokens: [...] } format
        battleMapTokens = Array.isArray(state.tokens) ? state.tokens : (state.tokens.tokens || []);
        renderTokenList();
      }
      if (state.spotlight) {
        spotlightedAdversary = state.spotlight;
        updateSpotlightUI();
      }
      // Restore battlemap state
      if (state.battleMap) {
        const bm = state.battleMap;
        if (bm.gridSize) gridSize = bm.gridSize;
        if (bm.gridVisible !== undefined) {
          gridVisible = bm.gridVisible;
          document.getElementById('gridBtn')?.classList.toggle('active', gridVisible);
        }
        if (bm.mapVisible !== undefined) {
          mapVisible = bm.mapVisible;
          const btn = document.getElementById('mapVisBtn');
          if (btn) {
            btn.classList.toggle('active', mapVisible);
            btn.textContent = mapVisible ? 'Hide' : 'Show';
          }
        }
        if (bm.map) {
          currentMap = bm.map;
          const mapPreview = document.getElementById('mapPreview');
          if (mapPreview && currentMap.mapImage) {
            mapPreview.src = currentMap.mapImage;
            mapPreview.style.display = 'block';
            document.getElementById('mapPlaceholder').style.display = 'none';
            mapPreview.onload = () => {
              setTimeout(() => {
                drawMapPreviewGrid();
                renderMapPreviewTokens();
              }, 50);
            };
          }
        }
        syncBattleMap();
      }
      // Restore battle queue
      if (state.battleQueue && Array.isArray(state.battleQueue)) {
        stagedBattles = state.battleQueue;
        renderQueueList();
      }
    };

    // ========== Reference Tab Sub-tabs ==========
    // ========== Loot Generator ==========
    const lootData = {
      loot: [
        { roll: 1, name: "Premium Bedroll", description: "During downtime, you automatically clear a Stress.", rarity: "common" },
        { roll: 2, name: "Piper Whistle", description: "This handcrafted whistle has a distinctive sound. When you blow this whistle, its piercing tone can be heard within a 1-mile radius.", rarity: "common" },
        { roll: 3, name: "Charging Quiver", description: "When you succeed on an attack with an arrow stored in this quiver, gain a bonus to the damage roll equal to your current tier.", rarity: "common" },
        { roll: 4, name: "Alistair's Torch", description: "You can light this magic torch at will. The flame's light fills a much larger space than it should, enough to illuminate a cave bright as day.", rarity: "common" },
        { roll: 5, name: "Speaking Orbs", description: "This pair of orbs allows any creatures holding them to communicate with each other across any distance.", rarity: "common" },
        { roll: 6, name: "Manacles", description: "This pair of locking cuffs comes with a key.", rarity: "common" },
        { roll: 7, name: "Arcane Cloak", description: "A creature with a Spellcast trait wearing this cloak can adjust its color, texture, and size at will.", rarity: "common" },
        { roll: 8, name: "Woven Net", description: "You can make a Finesse Roll using this net to trap a small creature. A trapped target can break free with a successful Attack Roll (16).", rarity: "common" },
        { roll: 9, name: "Fire Jar", description: "You can pour out the strange liquid contents of this jar to instantly produce fire. The contents regenerate when you take a long rest.", rarity: "common" },
        { roll: 10, name: "Suspended Rod", description: "This flat rod is inscribed with runes. When you activate the rod, it is immediately suspended in place. Until the rod is deactivated, it can't move, doesn't abide by the rules of gravity, and remains in place.", rarity: "common" },
        { roll: 11, name: "Glamour Stone", description: "Activate this pebble-sized stone to memorize the appearance of someone you can see. Spend a Hope to magically recreate this guise on yourself as an illusion.", rarity: "common" },
        { roll: 12, name: "Empty Chest", description: "This magical chest appears empty. When you speak a specific trigger word or action and open the chest, you can see the items stored within it.", rarity: "common" },
        { roll: 13, name: "Companion Case", description: "This case can fit a small animal companion. While the companion is inside, the animal and case are immune to all damage and harmful effects.", rarity: "common" },
        { roll: 14, name: "Piercing Arrows", description: "Three times per rest when you succeed on an attack with one of these arrows, you can add your Proficiency to the damage roll.", rarity: "common" },
        { roll: 15, name: "Valorstone", description: "You can attach this stone to armor that doesn't already have a feature. The armor gains the following feature. Resilient: Before you mark your last Armor Slot, roll a d6. On a result of 6, reduce the severity by one threshold without marking an Armor Slot.", rarity: "common" },
        { roll: 16, name: "Skeleton Key", description: "When you use this key to open a locked door, you gain advantage on the Finesse Roll.", rarity: "common" },
        { roll: 17, name: "Arcane Prism", description: "Position this prism in a location of your choosing and activate it. All allies within Close range of it gain a +1 bonus to their Spellcast Rolls. While activated, the prism can't be moved. Once the prism is deactivated, it can't be activated again until your next long rest.", rarity: "common" },
        { roll: 18, name: "Minor Stamina Potion Recipe", description: "As a downtime move, you can use the bone of a creature to craft a Minor Stamina Potion.", rarity: "common" },
        { roll: 19, name: "Minor Health Potion Recipe", description: "As a downtime move, you can use a vial of blood to craft a Minor Health Potion.", rarity: "common" },
        { roll: 20, name: "Homing Compasses", description: "These two compasses point toward each other no matter how far apart they are.", rarity: "common" },
        { roll: 21, name: "Corrector Sprite", description: "This tiny sprite sits in the curve of your ear canal and whispers helpful advice during combat. Once per short rest, you can gain advantage on an attack roll.", rarity: "common" },
        { roll: 22, name: "Gecko Gloves", description: "You can climb up vertical surfaces and across ceilings.", rarity: "common" },
        { roll: 23, name: "Lorekeeper", description: "You can store the name and details of up to three hostile creatures inside this book. You gain a +1 bonus to action rolls against those creatures.", rarity: "common" },
        { roll: 24, name: "Vial of Darksmoke Recipe", description: "As a downtime move, you can mark a Stress to craft a Vial of Darksmoke.", rarity: "common" },
        { roll: 25, name: "Bloodstone", description: "You can attach this stone to a weapon that doesn't already have a feature. The weapon gains the following feature. Brutal: When you roll the maximum value on a damage die, roll an additional damage die.", rarity: "uncommon" },
        { roll: 26, name: "Greatstone", description: "You can attach this stone to a weapon that doesn't already have a feature. The weapon gains the following feature. Powerful: On a successful attack, roll an additional damage die and discard the lowest result.", rarity: "uncommon" },
        { roll: 27, name: "Glider", description: "While falling, you can mark a Stress to deploy this small parachute and glide safely to the ground.", rarity: "uncommon" },
        { roll: 28, name: "Ring of Silence", description: "Spend a Hope to activate this ring. Your footsteps are silent until your next rest.", rarity: "uncommon" },
        { roll: 29, name: "Calming Pendant", description: "When you would mark your last Stress, roll a d6. On a result of 5 or higher, don't mark it.", rarity: "uncommon" },
        { roll: 30, name: "Dual Flask", description: "This flask can hold two different liquids. You can swap between them by flipping a small switch on the flask's side.", rarity: "uncommon" },
        { roll: 31, name: "Bag of Ficklesand", description: "You can convince this small bag of sand to be much heavier or lighter with a successful Presence Roll (10). Additionally, on a successful Finesse Roll (10), you can blow a bit of sand into a target's face to make them temporarily Vulnerable.", rarity: "uncommon" },
        { roll: 32, name: "Ring of Resistance", description: "Once per long rest, you can activate this ring after a successful attack against you to halve the damage.", rarity: "uncommon" },
        { roll: 33, name: "Phoenix Feather", description: "If you have at least one Phoenix Feather on you when you fall unconscious, you gain a +1 bonus to the roll you make to determine whether you gain a scar.", rarity: "uncommon" },
        { roll: 34, name: "Box of Many Goods", description: "Once per long rest, you can open this small box and roll a d12. On a result of 1-6, it's empty. On a result of 7-10, it contains one random common consumable. On a result of 11-12, it contains two random common consumables.", rarity: "uncommon" },
        { roll: 35, name: "Airblade Charm", description: "You can attach this charm to a weapon with a Melee range. Three times per rest, you can activate the charm and attack a target within Close range.", rarity: "uncommon" },
        { roll: 36, name: "Portal Seed", description: "You can plant this seed in the ground to grow a portal in that spot. The portal is ready to use in 24 hours. You can use this portal to travel to any other location where you planted a portal seed. A portal can be destroyed by dealing any amount of magic damage to it.", rarity: "uncommon" },
        { roll: 37, name: "Paragon's Chain", description: "As a downtime move, you can meditate on an ideal or principle you hold dear and focus your will into this chain. Once per long rest, you can spend a Hope to roll a d20 as your Hope Die for rolls that directly align with that principle.", rarity: "rare" },
        { roll: 38, name: "Elusive Amulet", description: "Once per long rest, you can activate this amulet to become Hidden until you move. While Hidden in this way, you remain unseen even if an adversary moves to where they would normally see you.", rarity: "rare" },
        { roll: 39, name: "Hopekeeper Locket", description: "During a long rest, if you have 6 Hope, you can spend a Hope to imbue this locket with your bountiful resolve. When you have 0 Hope, you can use the locket to immediately gain a Hope. The locket must be re-imbued before it can be used this way again.", rarity: "rare" },
        { roll: 40, name: "Infinite Bag", description: "When you store items in this bag, they are kept in a pocket dimension that never runs out of space. You can retrieve an item at any time.", rarity: "rare" },
        { roll: 41, name: "Stride Relic", description: "You gain a +1 bonus to your Agility. You can only carry one relic.", rarity: "rare" },
        { roll: 42, name: "Bolster Relic", description: "You gain a +1 bonus to your Strength. You can only carry one relic.", rarity: "rare" },
        { roll: 43, name: "Control Relic", description: "You gain a +1 bonus to your Finesse. You can only carry one relic.", rarity: "rare" },
        { roll: 44, name: "Attune Relic", description: "You gain a +1 bonus to your Instinct. You can only carry one relic.", rarity: "rare" },
        { roll: 45, name: "Charm Relic", description: "You gain a +1 bonus to your Presence. You can only carry one relic.", rarity: "rare" },
        { roll: 46, name: "Enlighten Relic", description: "You gain a +1 bonus to your Knowledge. You can only carry one relic.", rarity: "rare" },
        { roll: 47, name: "Honing Relic", description: "You gain a +1 bonus to an Experience of your choice. You can only carry one relic.", rarity: "rare" },
        { roll: 48, name: "Flickerfly Pendant", description: "While you carry this pendant, your weapons with a Melee range that deal physical damage have a gossamer sheen and can attack targets within Very Close range.", rarity: "rare" },
        { roll: 49, name: "Lakestrider Boots", description: "You can walk on the surface of water as if it were soft ground.", rarity: "legendary" },
        { roll: 50, name: "Clay Companion", description: "When you sculpt this ball of clay into a clay animal companion, it behaves as that animal. For example, a clay spider can spin clay webs, while a clay bird can fly. The clay companion retains memory and identity across different shapes, but they can adopt new mannerisms with each form.", rarity: "legendary" },
        { roll: 51, name: "Mythic Dust Recipe", description: "As a downtime move, you can use a handful of fine gold dust to craft Mythic Dust.", rarity: "legendary" },
        { roll: 52, name: "Shard of Memory", description: "Once per long rest, you can spend 2 Hope to recall a domain card from your vault instead of paying its Recall Cost.", rarity: "legendary" },
        { roll: 53, name: "Gem of Alacrity", description: "You can attach this gem to a weapon, allowing you to use your Agility when making an attack with that weapon.", rarity: "legendary" },
        { roll: 54, name: "Gem of Might", description: "You can attach this gem to a weapon, allowing you to use your Strength when making an attack with that weapon.", rarity: "legendary" },
        { roll: 55, name: "Gem of Precision", description: "You can attach this gem to a weapon, allowing you to use your Finesse when making an attack with that weapon.", rarity: "legendary" },
        { roll: 56, name: "Gem of Insight", description: "You can attach this gem to a weapon, allowing you to use your Instinct when making an attack with that weapon.", rarity: "legendary" },
        { roll: 57, name: "Gem of Audacity", description: "You can attach this gem to a weapon, allowing you to use your Presence when making an attack with that weapon.", rarity: "legendary" },
        { roll: 58, name: "Gem of Sagacity", description: "You can attach this gem to a weapon, allowing you to use your Knowledge when making an attack with that weapon.", rarity: "legendary" },
        { roll: 59, name: "Ring of Unbreakable Resolve", description: "Once per session, when the GM spends a Fear, you can spend 4 Hope to cancel the effects of that spent Fear.", rarity: "legendary" },
        { roll: 60, name: "Belt of Unity", description: "Once per session, you can spend 5 Hope to lead a Tag Team Roll with three PCs instead of two.", rarity: "legendary" }
      ],
      consumables: [
        { roll: 1, name: "Stride Potion", description: "You gain a +1 bonus to your next Agility Roll.", rarity: "common" },
        { roll: 2, name: "Bolster Potion", description: "You gain a +1 bonus to your next Strength Roll.", rarity: "common" },
        { roll: 3, name: "Control Potion", description: "You gain a +1 bonus to your next Finesse Roll.", rarity: "common" },
        { roll: 4, name: "Attune Potion", description: "You gain a +1 bonus to your next Instinct Roll.", rarity: "common" },
        { roll: 5, name: "Charm Potion", description: "You gain a +1 bonus to your next Presence Roll.", rarity: "common" },
        { roll: 6, name: "Enlighten Potion", description: "You gain a +1 bonus to your next Knowledge Roll.", rarity: "common" },
        { roll: 7, name: "Minor Health Potion", description: "Clear 1d4 HP.", rarity: "common" },
        { roll: 8, name: "Minor Stamina Potion", description: "Clear 1d4 Stress.", rarity: "common" },
        { roll: 9, name: "Grindletooth Venom", description: "You can apply this venom to a weapon that deals physical damage to add a d6 to your next damage roll with that weapon.", rarity: "common" },
        { roll: 10, name: "Varik Leaves", description: "You can eat these paired leaves to immediately gain 2 Hope.", rarity: "common" },
        { roll: 11, name: "Vial of Moondrip", description: "When you drink the contents of this vial, you can see in total darkness until your next rest.", rarity: "common" },
        { roll: 12, name: "Unstable Arcane Shard", description: "You can make a Finesse Roll to throw this shard at a group of adversaries within Far range. Targets you succeed against take 1d20 magic damage.", rarity: "common" },
        { roll: 13, name: "Potion of Stability", description: "You can drink this potion to choose one additional downtime move.", rarity: "common" },
        { roll: 14, name: "Improved Grindletooth Venom", description: "You can apply this venom to a weapon that deals physical damage to add a d8 to your next damage roll with that weapon.", rarity: "common" },
        { roll: 15, name: "Morphing Clay", description: "You can spend a Hope to use this clay, altering your face enough to make you unrecognizable until your next rest.", rarity: "common" },
        { roll: 16, name: "Vial of Darksmoke", description: "When an adversary attacks you, use this vial and roll a number of d6s equal to your Agility. Add the highest result to your Evasion against the attack.", rarity: "common" },
        { roll: 17, name: "Jumping Root", description: "Eat this root to leap up to Far range once without needing to roll.", rarity: "common" },
        { roll: 18, name: "Snap Powder", description: "Mark a Stress and clear a HP.", rarity: "common" },
        { roll: 19, name: "Health Potion", description: "Clear 1d4+1 HP.", rarity: "common" },
        { roll: 20, name: "Stamina Potion", description: "Clear 1d4+1 Stress.", rarity: "common" },
        { roll: 21, name: "Armor Stitcher", description: "You can use this stitcher to spend any number of Hope and clear that many Armor Slots.", rarity: "common" },
        { roll: 22, name: "Gill Salve", description: "You can apply this salve to your neck to breathe underwater for a number of minutes equal to your level.", rarity: "common" },
        { roll: 23, name: "Replication Parchment", description: "By touching this piece of parchment to another, you can perfectly copy the second parchment's contents. Once used, this parchment becomes mundane paper.", rarity: "common" },
        { roll: 24, name: "Improved Arcane Shard", description: "You can make a Finesse Roll to throw this shard at a group of adversaries within Far range. Targets you succeed against take 2d20 magic damage.", rarity: "common" },
        { roll: 25, name: "Major Stride Potion", description: "You gain a +1 bonus to your Agility until your next rest.", rarity: "uncommon" },
        { roll: 26, name: "Major Bolster Potion", description: "You gain a +1 bonus to your Strength until your next rest.", rarity: "uncommon" },
        { roll: 27, name: "Major Control Potion", description: "You gain a +1 bonus to your Finesse until your next rest.", rarity: "uncommon" },
        { roll: 28, name: "Major Attune Potion", description: "You gain a +1 bonus to your Instinct until your next rest.", rarity: "uncommon" },
        { roll: 29, name: "Major Charm Potion", description: "You gain a +1 bonus to your Presence until your next rest.", rarity: "uncommon" },
        { roll: 30, name: "Major Enlighten Potion", description: "You gain a +1 bonus to your Knowledge until your next rest.", rarity: "uncommon" },
        { roll: 31, name: "Blood of the Yorgi", description: "You can drink this blood to disappear from where you are and immediately reappear at a point you can see within Very Far range.", rarity: "uncommon" },
        { roll: 32, name: "Homet's Secret Potion", description: "After drinking this potion, the next successful attack you make critically succeeds.", rarity: "uncommon" },
        { roll: 33, name: "Redthorn Saliva", description: "You can apply this saliva to a weapon that deals physical damage to add a d12 to your next damage roll with that weapon.", rarity: "uncommon" },
        { roll: 34, name: "Channelstone", description: "You can use this stone to take a spell or grimoire from your vault, use it once, and return it to your vault.", rarity: "uncommon" },
        { roll: 35, name: "Mythic Dust", description: "You can apply this dust to a weapon that deals magic damage to add a d12 to your next damage roll with that weapon.", rarity: "uncommon" },
        { roll: 36, name: "Acidpaste", description: "This paste eats away walls and other surfaces in bright flashes.", rarity: "uncommon" },
        { roll: 37, name: "Hopehold Flare", description: "When you use this flare, allies within Close range roll a d6 when they spend a Hope. On a result of 6, they gain the effect of that Hope without spending it. The flare lasts until the end of the scene.", rarity: "rare" },
        { roll: 38, name: "Major Arcane Shard", description: "You can make a Finesse Roll to throw this shard at a group of adversaries within Far range. Targets you succeed against take 4d20 magic damage.", rarity: "rare" },
        { roll: 39, name: "Featherbone", description: "You can use this bone to control your falling speed for a number of minutes equal to your level.", rarity: "rare" },
        { roll: 40, name: "Circle of the Void", description: "Mark a Stress to create a void that extends up to Far range. No magic can be cast inside the void, and creatures within the void are immune to magic damage.", rarity: "rare" },
        { roll: 41, name: "Sun Tree Sap", description: "Consume this sap to roll a d6. On a result of 5-6, clear 2 HP. On a result of 2-4, clear 3 Stress. On a result of 1, see through the veil of death and return changed, gaining one scar.", rarity: "rare" },
        { roll: 42, name: "Dripfang Poison", description: "A creature who consumes this poison takes 8d10 direct magic damage.", rarity: "rare" },
        { roll: 43, name: "Major Health Potion", description: "Clear 1d4+2 HP.", rarity: "rare" },
        { roll: 44, name: "Major Stamina Potion", description: "Clear 1d4+2 Stress.", rarity: "rare" },
        { roll: 45, name: "Ogre Musk", description: "You can use this musk to prevent anyone from tracking you by mundane or magical means until your next rest.", rarity: "rare" },
        { roll: 46, name: "Wingsprout", description: "You gain magic wings that allow you to fly for a number of minutes equal to your level.", rarity: "rare" },
        { roll: 47, name: "Jar of Lost Voices", description: "You can open this jar to release a deafening echo of voices for a number of minutes equal to your Instinct. Creatures within Far range unprepared for the sound take 6d8 magic damage.", rarity: "rare" },
        { roll: 48, name: "Dragonbloom Tea", description: "You can drink this tea to unleash a fiery breath attack. Make an Instinct Roll against all adversaries in front of you within Close range. Targets you succeed against take d20 physical damage using your Proficiency.", rarity: "rare" },
        { roll: 49, name: "Bridge Seed", description: "Thick vines grow from your location to a point of your choice within Far range, allowing you to climb up or across them. The vines dissipate on your next short rest.", rarity: "legendary" },
        { roll: 50, name: "Sleeping Sap", description: "You can drink this potion to fall asleep for a full night's rest. You clear all Stress upon waking.", rarity: "legendary" },
        { roll: 51, name: "Feast of Xuria", description: "You can eat this meal to clear all HP and Stress and gain 1d4 Hope.", rarity: "legendary" },
        { roll: 52, name: "Bonding Honey", description: "This honey can be used to glue two objects together permanently.", rarity: "legendary" },
        { roll: 53, name: "Shrinking Potion", description: "You can drink this potion to halve your size until you choose to drop this form or your next rest. While in this form, you have a +2 bonus to Agility and a -1 penalty to your Proficiency.", rarity: "legendary" },
        { roll: 54, name: "Growing Potion", description: "You can drink this potion to double your size until you choose to drop this form or your next rest. While in this form, you have a +2 bonus to Strength and a +1 bonus to your Proficiency.", rarity: "legendary" },
        { roll: 55, name: "Knowledge Stone", description: "If you die while holding this stone, an ally can take a card from your loadout to place in their loadout or vault. After they take this knowledge, the stone crumbles.", rarity: "legendary" },
        { roll: 56, name: "Sweet Moss", description: "You can consume this moss during a rest to clear 1d4 HP or 1d4 Stress.", rarity: "legendary" },
        { roll: 57, name: "Blinding Orb", description: "You can activate this orb to create a flash of bright light. All targets within Close range become Vulnerable until they mark HP.", rarity: "legendary" },
        { roll: 58, name: "Death Tea", description: "After you drink this tea, you instantly kill your target when you critically succeed on an attack. If you don't critically succeed on an attack before your next long rest, you die.", rarity: "legendary" },
        { roll: 59, name: "Mirror of Marigold", description: "When you take damage, you can spend a Hope to negate that damage, after which the mirror shatters.", rarity: "legendary" },
        { roll: 60, name: "Stardrop", description: "You can use this stardrop to summon a hailstorm of comets that deals 8d20 physical damage to all targets within Very Far range.", rarity: "legendary" }
      ]
    };

    const rarityRanges = {
      common: { min: 1, max: 24 },
      uncommon: { min: 25, max: 36 },
      rare: { min: 37, max: 48 },
      legendary: { min: 49, max: 60 }
    };

    function generateLoot() {
      const lootType = document.getElementById('lootType').value;
      const rarity = document.getElementById('lootRarity').value;
      const count = parseInt(document.getElementById('lootCount').value);

      const results = [];

      for (let i = 0; i < count; i++) {
        const item = generateSingleItem(lootType, rarity);
        if (item) results.push(item);
      }

      renderLootResults(results);
    }

    function generateSingleItem(lootType, rarity) {
      // Determine which table to use
      let table;
      if (lootType === 'treasure') {
        table = lootData.loot;
      } else if (lootType === 'consumable') {
        table = lootData.consumables;
      } else {
        // Both - randomly choose
        table = Math.random() < 0.5 ? lootData.loot : lootData.consumables;
      }

      // Get roll range based on rarity
      let rollMin, rollMax;
      if (rarity === 'any') {
        rollMin = 1;
        rollMax = 60;
      } else {
        const range = rarityRanges[rarity];
        rollMin = range.min;
        rollMax = range.max;
      }

      // Generate random roll within range
      const roll = Math.floor(Math.random() * (rollMax - rollMin + 1)) + rollMin;

      // Find the item
      const item = table.find(i => i.roll === roll);

      if (item) {
        return {
          ...item,
          type: table === lootData.loot ? 'treasure' : 'consumable',
          rolledValue: roll
        };
      }

      return null;
    }

    function renderLootResults(results) {
      // Append generated results to existing loot (preserving manually added equipment)
      const existingEquipment = lastGeneratedLoot.filter(item => item.isEquipment);
      lastGeneratedLoot = [...results, ...existingEquipment];

      // Use the mixed rendering function
      renderMixedLootResults();
    }

    function clearLootResults() {
      lastGeneratedLoot = [];
      renderMixedLootResults();
    }

    function toggleLootReference() {
      const content = document.getElementById('lootReferenceContent');
      const toggle = document.getElementById('lootReferenceToggle');
      content.classList.toggle('open');
      toggle.classList.toggle('open');
    }

    function openPrintCardModal(itemIndex) {
      const item = lastGeneratedLoot[itemIndex];
      if (!item) return;

      // Redirect to equipment print modal for equipment items
      if (item.isEquipment) {
        openEquipmentPrintModal(itemIndex);
        return;
      }

      const typeIconSvg = item.type.toLowerCase() === 'consumable'
        ? '<svg viewBox="0 0 24 24"><path d="M5 19h14v2H5v-2zm7-18c-1.1 0-2 .9-2 2v7c0 1.64.81 3.09 2.04 3.98L11 17h2l-1.04-3.02C13.19 13.09 14 11.64 14 10V3c0-1.1-.9-2-2-2zm-1 2h2v5h-2V3zm-5.82 8.58l-.82.82L7 15.05l.82-.83c.55-.55.86-1.3.86-2.08 0-.78-.31-1.53-.86-2.08l-.82-.82-2.64 2.65.82.82c.55.55 1.3.86 2.08.86.78 0 1.53-.31 2.08-.86l.82-.82L7.51 9.24l-.82.82c-.55.55-.86 1.3-.86 2.08 0 .78.31 1.53.86 2.08l.82.82 2.65-2.65-.82-.82a2.925 2.925 0 00-2.08-.86c-.78 0-1.53.31-2.08.86z"/></svg>'
        : '<svg viewBox="0 0 24 24"><path d="M5 4h14c.55 0 1 .45 1 1v3c0 .55-.45 1-1 1H5c-.55 0-1-.45-1-1V5c0-.55.45-1 1-1zm-2 6h18v10c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V10zm4 3v2h10v-2H7z"/></svg>';

      const rarityInitial = item.rarity.charAt(0).toUpperCase();

      const cardHtml = `
        <div class="playing-card ${item.rarity}">
          <div class="playing-card-corner top-left">${rarityInitial}</div>
          <div class="playing-card-corner bottom-right">${rarityInitial}</div>
          <div class="playing-card-type-icon ${item.type.toLowerCase()}">
            ${typeIconSvg}
          </div>
          <div class="playing-card-name">${item.name}</div>
          <div class="playing-card-rarity ${item.rarity}">${item.rarity}</div>
          <div class="playing-card-divider"></div>
          <div class="playing-card-description">${item.description}</div>
          <div class="playing-card-footer">
            <span>${item.type}</span>
            <span>Roll: ${item.rolledValue}</span>
          </div>
        </div>
      `;

      document.getElementById('printCardContent').innerHTML = cardHtml;
      document.getElementById('printCardOverlay').classList.add('active');
    }

    function closePrintCardModal() {
      document.getElementById('printCardOverlay').classList.remove('active');
    }

    function printCurrentCard() {
      window.print();
    }

    // Close modal on overlay click
    document.getElementById('printCardOverlay').addEventListener('click', function(e) {
      if (e.target === this) {
        closePrintCardModal();
      }
    });

    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && document.getElementById('printCardOverlay').classList.contains('active')) {
        closePrintCardModal();
      }
    });

    function updateLootOptions() {
      // Placeholder for future enhancements
      // Could be used to adjust options based on loot type selection
    }

    // ========== Equipment Database ==========
    async function loadEquipmentDatabase() {
      try {
        const response = await fetch('daggerheart_equipment.json');
        const data = await response.json();

        // Flatten the equipment data into a searchable array
        equipmentDatabase = [];

        // Process primary weapons
        if (data.primary_weapons) {
          for (const [tierKey, tierData] of Object.entries(data.primary_weapons)) {
            const tierNum = tierKey.replace('tier_', '');

            // Process physical weapons
            if (tierData.physical) {
              tierData.physical.forEach(weapon => {
                equipmentDatabase.push({
                  ...weapon,
                  type: 'primary_weapon',
                  subtype: 'physical',
                  tier: parseInt(tierNum),
                  tierKey: tierKey,
                  levelRange: tierData.level_range
                });
              });
            }

            // Process magic weapons
            if (tierData.magic) {
              tierData.magic.forEach(weapon => {
                equipmentDatabase.push({
                  ...weapon,
                  type: 'primary_weapon',
                  subtype: 'magic',
                  tier: parseInt(tierNum),
                  tierKey: tierKey,
                  levelRange: tierData.level_range
                });
              });
            }
          }
        }

        // Process secondary weapons
        if (data.secondary_weapons) {
          for (const [tierKey, tierData] of Object.entries(data.secondary_weapons)) {
            const tierNum = tierKey.replace('tier_', '');
            if (tierData.weapons) {
              tierData.weapons.forEach(weapon => {
                equipmentDatabase.push({
                  ...weapon,
                  type: 'secondary_weapon',
                  tier: parseInt(tierNum),
                  tierKey: tierKey,
                  levelRange: tierData.level_range
                });
              });
            }
          }
        }

        // Process armor
        if (data.armor) {
          for (const [tierKey, tierData] of Object.entries(data.armor)) {
            const tierNum = tierKey.replace('tier_', '');
            if (tierData.armors) {
              tierData.armors.forEach(armor => {
                equipmentDatabase.push({
                  ...armor,
                  type: 'armor',
                  tier: parseInt(tierNum),
                  tierKey: tierKey,
                  levelRange: tierData.level_range
                });
              });
            }
          }
        }

        console.log(`Loaded ${equipmentDatabase.length} equipment items from database`);

        // Initialize equipment search
        initEquipmentSearch();
      } catch (error) {
        console.error('Error loading equipment database:', error);
        equipmentDatabase = [];
      }
    }

    function initEquipmentSearch() {
      const searchInput = document.getElementById('equipmentSearchInput');
      const dropdown = document.getElementById('equipmentDropdown');

      if (!searchInput || !dropdown) return;

      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.trim().toLowerCase();
        if (query.length < 2) {
          dropdown.classList.remove('visible');
          return;
        }

        filterEquipmentResults();
      });

      searchInput.addEventListener('keydown', (e) => {
        const items = dropdown.querySelectorAll('.equipment-item');

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          selectedEquipmentIndex = Math.min(selectedEquipmentIndex + 1, items.length - 1);
          updateEquipmentSelection();
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          selectedEquipmentIndex = Math.max(selectedEquipmentIndex - 1, -1);
          updateEquipmentSelection();
        } else if (e.key === 'Enter' && selectedEquipmentIndex >= 0) {
          e.preventDefault();
          const item = items[selectedEquipmentIndex];
          if (item) item.click();
        } else if (e.key === 'Escape') {
          dropdown.classList.remove('visible');
          selectedEquipmentIndex = -1;
        }
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.equipment-search-container')) {
          dropdown.classList.remove('visible');
          selectedEquipmentIndex = -1;
        }
      });
    }

    function filterEquipmentResults() {
      const searchInput = document.getElementById('equipmentSearchInput');
      const dropdown = document.getElementById('equipmentDropdown');
      const typeFilter = document.getElementById('equipmentTypeFilter').value;
      const tierFilter = document.getElementById('equipmentTierFilter').value;

      const query = searchInput.value.trim().toLowerCase();

      if (query.length < 2) {
        dropdown.classList.remove('visible');
        return;
      }

      let matches = equipmentDatabase.filter(item => {
        // Text search
        const matchesQuery = item.name.toLowerCase().includes(query) ||
          (item.trait && item.trait.toLowerCase().includes(query)) ||
          (item.damage_type && item.damage_type.toLowerCase().includes(query)) ||
          (item.feature && item.feature.name && item.feature.name.toLowerCase().includes(query));

        // Type filter
        const matchesType = typeFilter === 'all' || item.type === typeFilter;

        // Tier filter
        const matchesTier = tierFilter === 'all' || item.tierKey === tierFilter;

        return matchesQuery && matchesType && matchesTier;
      }).slice(0, 15);

      if (matches.length === 0) {
        dropdown.classList.remove('visible');
        return;
      }

      dropdown.innerHTML = matches.map((item, i) => {
        const typeLabel = getEquipmentTypeLabel(item.type);
        const meta = getEquipmentMeta(item);

        return `
          <div class="equipment-item ${i === selectedEquipmentIndex ? 'selected' : ''}"
               onclick="selectEquipmentItem('${item.name.replace(/'/g, "\\'")}', '${item.type}', ${item.tier})">
            <div class="equipment-item-name">
              <span class="equipment-item-type ${item.type}">${typeLabel}</span>
              ${item.name}
            </div>
            <div class="equipment-item-meta">${meta}</div>
          </div>
        `;
      }).join('');

      dropdown.classList.add('visible');
      selectedEquipmentIndex = -1;
    }

    function getEquipmentTypeLabel(type) {
      switch (type) {
        case 'primary_weapon': return 'Weapon';
        case 'secondary_weapon': return 'Secondary';
        case 'armor': return 'Armor';
        default: return 'Item';
      }
    }

    function getEquipmentMeta(item) {
      const parts = [`Tier ${item.tier}`];

      if (item.damage) {
        parts.push(`${item.damage} ${item.damage_type || ''}`);
      }
      if (item.trait) {
        parts.push(item.trait);
      }
      if (item.base_score !== undefined) {
        parts.push(`Score: ${item.base_score}`);
      }
      if (item.feature && item.feature.name) {
        parts.push(item.feature.name);
      }

      return parts.join(' | ');
    }

    function updateEquipmentSelection() {
      const items = document.querySelectorAll('#equipmentDropdown .equipment-item');
      items.forEach((item, i) => {
        item.classList.toggle('selected', i === selectedEquipmentIndex);
      });
    }

    function selectEquipmentItem(name, type, tier) {
      const item = equipmentDatabase.find(eq =>
        eq.name === name && eq.type === type && eq.tier === tier
      );

      if (!item) return;

      // Add to loot results
      addEquipmentToLoot(item);

      // Clear search
      const searchInput = document.getElementById('equipmentSearchInput');
      const dropdown = document.getElementById('equipmentDropdown');
      searchInput.value = '';
      dropdown.classList.remove('visible');
      selectedEquipmentIndex = -1;
    }

    function addEquipmentToLoot(equipment) {
      // Create a loot item from the equipment
      const lootItem = {
        name: equipment.name,
        type: equipment.type,
        tier: equipment.tier,
        isEquipment: true,
        // Weapon-specific fields
        trait: equipment.trait || null,
        range: equipment.range || null,
        damage: equipment.damage || null,
        damage_type: equipment.damage_type || null,
        burden: equipment.burden || null,
        requires_spellcast: equipment.requires_spellcast || false,
        // Armor-specific fields
        base_score: equipment.base_score || null,
        base_thresholds: equipment.base_thresholds || null,
        // Common fields
        feature: equipment.feature || null,
        // Display fields
        rarity: getTierRarity(equipment.tier),
        rolledValue: '-',
        description: generateEquipmentDescription(equipment)
      };

      // Add to lastGeneratedLoot
      lastGeneratedLoot.push(lootItem);

      // Re-render the loot results
      renderMixedLootResults();
    }

    function getTierRarity(tier) {
      switch (tier) {
        case 1: return 'common';
        case 2: return 'uncommon';
        case 3: return 'rare';
        case 4: return 'legendary';
        default: return 'common';
      }
    }

    function generateEquipmentDescription(item) {
      const parts = [];

      if (item.type === 'armor') {
        parts.push(`Armor Score: ${item.base_score}`);
        if (item.base_thresholds) {
          parts.push(`Major: ${item.base_thresholds.major}, Severe: ${item.base_thresholds.severe}`);
        }
      } else {
        // Weapon
        if (item.trait) parts.push(`Trait: ${item.trait}`);
        if (item.range) parts.push(`Range: ${item.range}`);
        if (item.damage) parts.push(`Damage: ${item.damage} ${item.damage_type || ''}`);
        if (item.burden) parts.push(`${item.burden}`);
        if (item.requires_spellcast) parts.push('Requires Spellcast');
      }

      if (item.feature && item.feature.name) {
        parts.push(`${item.feature.name}: ${item.feature.description}`);
      }

      return parts.join(' | ');
    }

    function renderMixedLootResults() {
      const container = document.getElementById('lootResults');

      if (lastGeneratedLoot.length === 0) {
        container.innerHTML = `
          <div class="loot-empty">
            <div class="loot-empty-icon">&#128176;</div>
            <div>No loot generated yet</div>
            <div class="loot-empty-hint">Select your options above and click "Generate Loot" to roll for treasure!</div>
          </div>
        `;
        return;
      }

      const html = `
        <div class="loot-items-grid">
          ${lastGeneratedLoot.map((item, index) => {
            if (item.isEquipment) {
              return renderEquipmentCard(item, index);
            } else {
              return renderLootCard(item, index);
            }
          }).join('')}
        </div>
      `;

      container.innerHTML = html;
    }

    function renderLootCard(item, index) {
      return `
        <div class="loot-card ${item.rarity}">
          <div class="loot-card-header">
            <div class="loot-card-name">${item.name}</div>
            <span class="loot-card-rarity ${item.rarity}">${item.rarity}</span>
          </div>
          <div class="loot-card-meta">
            <span class="loot-type-icon ${item.type.toLowerCase()}">
              ${item.type.toLowerCase() === 'consumable'
                ? '<svg viewBox="0 0 24 24"><path d="M5 19h14v2H5v-2zm7-18c-1.1 0-2 .9-2 2v7c0 1.64.81 3.09 2.04 3.98L11 17h2l-1.04-3.02C13.19 13.09 14 11.64 14 10V3c0-1.1-.9-2-2-2zm-1 2h2v5h-2V3z"/></svg>'
                : '<svg viewBox="0 0 24 24"><path d="M5 4h14c.55 0 1 .45 1 1v3c0 .55-.45 1-1 1H5c-.55 0-1-.45-1-1V5c0-.55.45-1 1-1zm-2 6h18v10c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V10zm4 3v2h10v-2H7z"/></svg>'
              }
              ${item.type}
            </span>
            <span class="loot-card-roll">Roll: ${item.rolledValue}</span>
          </div>
          <div class="loot-card-description">${item.description}</div>
          <div class="loot-card-actions">
            <button class="loot-print-btn" onclick="openPrintCardModal(${index})">
              <svg viewBox="0 0 24 24"><path d="M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z"/></svg>
              Print Card
            </button>
            <button class="loot-remove-btn" onclick="removeLootItem(${index})">
              Remove
            </button>
          </div>
        </div>
      `;
    }

    function renderEquipmentCard(item, index) {
      const typeIcon = getEquipmentTypeIcon(item.type);
      const typeLabel = getEquipmentTypeLabel(item.type);

      let statsHtml = '';
      if (item.type === 'armor') {
        statsHtml = `
          <div class="equipment-card-stats">
            <div class="equipment-stat">
              <span class="equipment-stat-label">Score</span>
              <span class="equipment-stat-value">${item.base_score}</span>
            </div>
            <div class="equipment-stat">
              <span class="equipment-stat-label">Major</span>
              <span class="equipment-stat-value">${item.base_thresholds?.major || '-'}</span>
            </div>
            <div class="equipment-stat">
              <span class="equipment-stat-label">Severe</span>
              <span class="equipment-stat-value">${item.base_thresholds?.severe || '-'}</span>
            </div>
            <div class="equipment-stat">
              <span class="equipment-stat-label">Tier</span>
              <span class="equipment-stat-value">${item.tier}</span>
            </div>
          </div>
        `;
      } else {
        // Weapon stats
        statsHtml = `
          <div class="equipment-card-stats">
            <div class="equipment-stat">
              <span class="equipment-stat-label">Damage</span>
              <span class="equipment-stat-value">${item.damage || '-'}</span>
            </div>
            <div class="equipment-stat">
              <span class="equipment-stat-label">Type</span>
              <span class="equipment-stat-value">${item.damage_type || '-'}</span>
            </div>
            <div class="equipment-stat">
              <span class="equipment-stat-label">Trait</span>
              <span class="equipment-stat-value">${item.trait || '-'}</span>
            </div>
            <div class="equipment-stat">
              <span class="equipment-stat-label">Range</span>
              <span class="equipment-stat-value">${item.range || '-'}</span>
            </div>
            <div class="equipment-stat">
              <span class="equipment-stat-label">Burden</span>
              <span class="equipment-stat-value">${item.burden || '-'}</span>
            </div>
            <div class="equipment-stat">
              <span class="equipment-stat-label">Tier</span>
              <span class="equipment-stat-value">${item.tier}</span>
            </div>
          </div>
        `;
      }

      let featureHtml = '';
      if (item.feature && item.feature.name) {
        featureHtml = `
          <div class="equipment-feature">
            <div class="equipment-feature-name">${item.feature.name}</div>
            <div class="equipment-feature-desc">${item.feature.description}</div>
          </div>
        `;
      }

      return `
        <div class="loot-card ${item.rarity} ${item.type}">
          <div class="loot-card-header">
            <div class="loot-card-name">${item.name}</div>
            <span class="loot-card-rarity ${item.rarity}">T${item.tier}</span>
          </div>
          <div class="loot-card-meta">
            <span class="loot-type-icon ${item.type}">
              ${typeIcon}
              ${typeLabel}
            </span>
            ${item.requires_spellcast ? '<span style="color: #b388ff; font-size: 0.7rem;">Spellcast</span>' : ''}
          </div>
          ${statsHtml}
          ${featureHtml}
          <div class="loot-card-actions">
            <button class="loot-print-btn" onclick="openEquipmentPrintModal(${index})">
              <svg viewBox="0 0 24 24"><path d="M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z"/></svg>
              Print Card
            </button>
            <button class="loot-remove-btn" onclick="removeLootItem(${index})">
              Remove
            </button>
          </div>
        </div>
      `;
    }

    function getEquipmentTypeIcon(type) {
      switch (type) {
        case 'primary_weapon':
          return '<svg viewBox="0 0 24 24"><path d="M14.5 3L12 5.5 18.5 12l2.5-2.5c.7-.7.7-1.8 0-2.5l-4-4c-.7-.7-1.8-.7-2.5 0zM3 18l3 3 11.5-11.5-3-3L3 18z"/></svg>';
        case 'secondary_weapon':
          return '<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>';
        case 'armor':
          return '<svg viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/></svg>';
        default:
          return '<svg viewBox="0 0 24 24"><path d="M5 4h14c.55 0 1 .45 1 1v3c0 .55-.45 1-1 1H5c-.55 0-1-.45-1-1V5c0-.55.45-1 1-1zm-2 6h18v10c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V10zm4 3v2h10v-2H7z"/></svg>';
      }
    }

    function removeLootItem(index) {
      lastGeneratedLoot.splice(index, 1);
      renderMixedLootResults();
    }

    function openEquipmentPrintModal(itemIndex) {
      const item = lastGeneratedLoot[itemIndex];
      if (!item) return;

      const typeIcon = getEquipmentTypeIcon(item.type);
      const tierInitial = `T${item.tier}`;

      let statsHtml = '';
      if (item.type === 'armor') {
        statsHtml = `
          <div style="font-size: 0.75rem; margin: 10px 0;">
            <div>Score: ${item.base_score}</div>
            <div>Major: ${item.base_thresholds?.major || '-'} | Severe: ${item.base_thresholds?.severe || '-'}</div>
          </div>
        `;
      } else {
        statsHtml = `
          <div style="font-size: 0.75rem; margin: 10px 0;">
            <div>${item.damage} ${item.damage_type || ''}</div>
            <div>${item.trait || ''} | ${item.range || ''}</div>
            <div>${item.burden || ''}</div>
          </div>
        `;
      }

      let featureHtml = '';
      if (item.feature && item.feature.name) {
        featureHtml = `
          <div style="font-size: 0.7rem; margin-top: 8px; padding: 6px; background: rgba(179,136,255,0.1); border-radius: 4px;">
            <strong>${item.feature.name}:</strong> ${item.feature.description}
          </div>
        `;
      }

      const cardHtml = `
        <div class="playing-card ${item.rarity}">
          <div class="playing-card-corner top-left">${tierInitial}</div>
          <div class="playing-card-corner bottom-right">${tierInitial}</div>
          <div class="playing-card-type-icon ${item.type}">
            ${typeIcon}
          </div>
          <div class="playing-card-name">${item.name}</div>
          <div class="playing-card-rarity ${item.rarity}">${getEquipmentTypeLabel(item.type)}</div>
          <div class="playing-card-divider"></div>
          ${statsHtml}
          ${featureHtml}
        </div>
      `;

      document.getElementById('printCardContent').innerHTML = cardHtml;
      document.getElementById('printCardOverlay').classList.add('active');
    }

    function switchReferenceSubtab(subtab) {
      document.querySelectorAll('.reference-subtab').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.reference-subpanel').forEach(panel => panel.classList.remove('active'));

      document.querySelector(`.reference-subtab[onclick="switchReferenceSubtab('${subtab}')"]`).classList.add('active');
      document.getElementById(subtab + 'Subpanel').classList.add('active');

      if (subtab === 'notes') {
        renderNotesList();
      }
    }

    // ========== Campaign Notes Management ==========
    function filterNotesByCategory(category) {
      currentNoteCategory = category;
      document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelector(`.category-btn[data-category="${category}"]`).classList.add('active');
      renderNotesList();
    }

    function renderNotesList() {
      const list = document.getElementById('notes-list');
      if (!list) return;

      const filteredNotes = currentNoteCategory === 'all'
        ? campaignNotes
        : campaignNotes.filter(n => n.category === currentNoteCategory);

      if (filteredNotes.length === 0) {
        list.innerHTML = '<div class="characters-empty">No notes yet</div>';
        return;
      }

      const categoryIcons = { session: 'S', npc: 'N', location: 'L', plot: 'P', rules: 'R' };

      list.innerHTML = filteredNotes.map(note => `
        <div class="note-item ${note.id === selectedNoteId ? 'selected' : ''}"
             data-note-id="${note.id}" onclick="selectNote('${note.id}')">
          <span class="note-category-icon">[${categoryIcons[note.category] || 'S'}]</span>
          <span class="note-title">${note.title || 'Untitled'}</span>
        </div>
      `).join('');
    }

    function selectNote(noteId) {
      selectedNoteId = noteId;
      const note = campaignNotes.find(n => n.id === noteId);

      if (note) {
        document.getElementById('notes-empty-state').style.display = 'none';
        document.getElementById('notes-editor-form').style.display = 'flex';
        document.getElementById('note-title').value = note.title || '';
        document.getElementById('note-category').value = note.category || 'session';
        document.getElementById('note-content').value = note.content || '';
      }

      renderNotesList();
    }

    function createNewNote() {
      const newNote = {
        id: 'note-' + Math.random().toString(36).substr(2, 9),
        title: 'New Note',
        category: currentNoteCategory === 'all' ? 'session' : currentNoteCategory,
        content: '',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      campaignNotes.push(newNote);
      selectNote(newNote.id);
      scheduleAutoSaveIfAvailable();
    }

    function saveCurrentNote() {
      if (!selectedNoteId) return;

      const noteIndex = campaignNotes.findIndex(n => n.id === selectedNoteId);
      if (noteIndex === -1) return;

      campaignNotes[noteIndex] = {
        ...campaignNotes[noteIndex],
        title: document.getElementById('note-title').value,
        category: document.getElementById('note-category').value,
        content: document.getElementById('note-content').value,
        updatedAt: new Date().toISOString()
      };

      renderNotesList();
      scheduleAutoSaveIfAvailable();
    }

    function deleteCurrentNote() {
      if (!selectedNoteId) return;
      if (!confirm('Delete this note?')) return;

      campaignNotes = campaignNotes.filter(n => n.id !== selectedNoteId);
      selectedNoteId = null;

      document.getElementById('notes-empty-state').style.display = 'flex';
      document.getElementById('notes-editor-form').style.display = 'none';

      renderNotesList();
      scheduleAutoSaveIfAvailable();
    }

    // ========== Character Management ==========
    function addNewCharacter() {
      // Check character limit for basic tier
      const entitlement = window.cloudFeatures?.getEntitlement?.();
      if (entitlement === 'basic' && playerCharacters.length >= 10) {
        alert('Basic tier is limited to 10 characters per campaign. Upgrade to premium for unlimited characters.');
        return;
      }

      const newChar = {
        id: 'char-' + Math.random().toString(36).substr(2, 9),
        name: 'New Character',
        level: 1,
        ancestry: '',
        characterClass: '',
        subclass: '',
        currentHp: 0,
        maxHp: 0,
        currentStress: 0,
        maxStress: 0,
        armor: 0,
        evasion: 10,
        minorThreshold: 0,
        majorThreshold: 0,
        severeThreshold: 0,
        domains: [],
        experiences: [],
        abilities: [],
        feats: [],
        notes: '',
        portrait: null,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      playerCharacters.push(newChar);
      selectCharacter(newChar.id);
      updateTabBadges();
      scheduleAutoSaveIfAvailable();
    }

    function renderCharactersList() {
      const list = document.getElementById('charactersList');
      if (!list) return;

      if (playerCharacters.length === 0) {
        list.innerHTML = `
          <div class="characters-empty">
            No characters yet. Click "+ Add PC" to create a player character.
          </div>
        `;
        return;
      }

      list.innerHTML = playerCharacters.map(char => `
        <div class="character-item ${char.id === selectedCharacterId ? 'selected' : ''}"
             data-character-id="${char.id}" onclick="selectCharacter('${char.id}')">
          <div class="character-item-portrait">
            ${char.portrait ? `<img src="${char.portrait}" alt="${char.name}">` : ''}
          </div>
          <div class="character-item-info">
            <div class="character-item-name">${char.name || 'Unnamed'}</div>
            <div class="character-item-meta">
              Level ${char.level} ${char.ancestry ? capitalizeFirst(char.ancestry) : ''} ${char.characterClass ? capitalizeFirst(char.characterClass) : ''}
            </div>
          </div>
        </div>
      `).join('');
    }

    function capitalizeFirst(str) {
      return str ? str.charAt(0).toUpperCase() + str.slice(1) : '';
    }

    function selectCharacter(charId) {
      selectedCharacterId = charId;
      const char = playerCharacters.find(c => c.id === charId);

      if (!char) {
        document.querySelector('.character-editor-empty').style.display = 'flex';
        document.getElementById('characterEditorForm').style.display = 'none';
        return;
      }

      document.querySelector('.character-editor-empty').style.display = 'none';
      document.getElementById('characterEditorForm').style.display = 'block';

      // Populate form fields
      document.getElementById('charName').value = char.name || '';
      document.getElementById('charLevel').value = char.level || 1;
      document.getElementById('charAncestry').value = char.ancestry || '';
      document.getElementById('charClass').value = char.characterClass || '';
      updateSubclassOptions();
      document.getElementById('charSubclass').value = char.subclass || '';

      document.getElementById('charCurrentHp').value = char.currentHp || '';
      document.getElementById('charMaxHp').value = char.maxHp || '';
      document.getElementById('charCurrentStress').value = char.currentStress || '';
      document.getElementById('charMaxStress').value = char.maxStress || '';
      document.getElementById('charArmor').value = char.armor || 0;
      document.getElementById('charEvasion').value = char.evasion || 10;

      document.getElementById('charMinorThreshold').value = char.minorThreshold || '';
      document.getElementById('charMajorThreshold').value = char.majorThreshold || '';
      document.getElementById('charSevereThreshold').value = char.severeThreshold || '';

      // Set domains
      const domains = ['blade', 'bone', 'codex', 'grace', 'midnight', 'sage', 'splendor', 'valor'];
      domains.forEach(d => {
        const checkbox = document.getElementById('domain' + capitalizeFirst(d));
        if (checkbox) checkbox.checked = (char.domains || []).includes(d);
      });

      // Set experiences, abilities, feats
      currentCharacterExperiences = char.experiences || [];
      currentCharacterAbilities = char.abilities || [];
      currentCharacterFeats = char.feats || [];
      renderExperiencesList();
      renderAbilitiesList();
      renderFeatsList();

      document.getElementById('charNotes').value = char.notes || '';

      // Portrait
      const portraitEl = document.getElementById('characterPortrait');
      if (char.portrait) {
        portraitEl.innerHTML = `<img src="${char.portrait}" alt="${char.name}">`;
      } else {
        portraitEl.innerHTML = '<span class="portrait-placeholder">No Image</span>';
      }

      renderCharactersList();
    }

    function updateSubclassOptions() {
      const classSelect = document.getElementById('charClass');
      const subclassSelect = document.getElementById('charSubclass');
      const selectedClass = classSelect.value;

      if (!selectedClass || !SUBCLASS_OPTIONS[selectedClass]) {
        subclassSelect.innerHTML = '<option value="">Select Class first...</option>';
        return;
      }

      subclassSelect.innerHTML = '<option value="">Select Subclass...</option>' +
        SUBCLASS_OPTIONS[selectedClass].map(sc => `<option value="${sc.toLowerCase().replace(/\s+/g, '-')}">${sc}</option>`).join('');
    }

    function renderExperiencesList() {
      const list = document.getElementById('experiencesList');
      if (!list) return;

      list.innerHTML = currentCharacterExperiences.map((exp, index) => `
        <div class="experience-item">
          <span>${exp}</span>
          <button class="remove-item-btn" onclick="removeExperience(${index})">√ó</button>
        </div>
      `).join('');
    }

    function addExperience() {
      const input = document.getElementById('newExperienceInput');
      const value = input.value.trim();
      if (!value) return;

      currentCharacterExperiences.push(value);
      input.value = '';
      renderExperiencesList();
    }

    function removeExperience(index) {
      currentCharacterExperiences.splice(index, 1);
      renderExperiencesList();
    }

    function renderFeatsList() {
      const list = document.getElementById('featsList');
      if (!list) return;

      list.innerHTML = currentCharacterFeats.map((feat, index) => `
        <div class="feat-item">
          <span>${feat}</span>
          <button class="remove-item-btn" onclick="removeFeat(${index})">√ó</button>
        </div>
      `).join('');
    }

    function addFeat() {
      const input = document.getElementById('newFeatInput');
      const value = input.value.trim();
      if (!value) return;

      currentCharacterFeats.push(value);
      input.value = '';
      renderFeatsList();
    }

    function removeFeat(index) {
      currentCharacterFeats.splice(index, 1);
      renderFeatsList();
    }

    function renderAbilitiesList() {
      const list = document.getElementById('abilitiesList');
      if (!list) return;

      if (currentCharacterAbilities.length === 0) {
        list.innerHTML = '';
        return;
      }

      list.innerHTML = currentCharacterAbilities.map((ability, index) => `
        <div class="ability-card">
          <div class="ability-card-header">
            <span class="ability-name">${ability.name}</span>
            <span class="ability-type">${ability.type}</span>
          </div>
          <div class="ability-description">${ability.description}</div>
          <div class="ability-actions">
            <button class="remove-item-btn" onclick="removeAbility(${index})">√ó</button>
          </div>
        </div>
      `).join('');
    }

    function addAbility() {
      document.getElementById('addAbilityModal').classList.add('visible');
      document.getElementById('abilityName').value = '';
      document.getElementById('abilityType').value = 'passive';
      document.getElementById('abilityDescription').value = '';
    }

    function closeAbilityModal(e) {
      if (e && e.target !== e.currentTarget) return;
      document.getElementById('addAbilityModal').classList.remove('visible');
    }

    function saveAbility() {
      const name = document.getElementById('abilityName').value.trim();
      const type = document.getElementById('abilityType').value;
      const description = document.getElementById('abilityDescription').value.trim();

      if (!name) {
        alert('Please enter an ability name');
        return;
      }

      currentCharacterAbilities.push({ name, type, description });
      renderAbilitiesList();
      closeAbilityModal();
    }

    function removeAbility(index) {
      currentCharacterAbilities.splice(index, 1);
      renderAbilitiesList();
    }

    function getSelectedDomains() {
      const domains = [];
      const domainNames = ['blade', 'bone', 'codex', 'grace', 'midnight', 'sage', 'splendor', 'valor'];
      domainNames.forEach(d => {
        const checkbox = document.getElementById('domain' + capitalizeFirst(d));
        if (checkbox && checkbox.checked) domains.push(d);
      });
      return domains;
    }

    function saveCurrentCharacter() {
      if (!selectedCharacterId) return;

      const charIndex = playerCharacters.findIndex(c => c.id === selectedCharacterId);
      if (charIndex === -1) return;

      const existingChar = playerCharacters[charIndex];

      playerCharacters[charIndex] = {
        ...existingChar,
        name: document.getElementById('charName').value,
        level: parseInt(document.getElementById('charLevel').value) || 1,
        ancestry: document.getElementById('charAncestry').value,
        characterClass: document.getElementById('charClass').value,
        subclass: document.getElementById('charSubclass').value,
        currentHp: parseInt(document.getElementById('charCurrentHp').value) || 0,
        maxHp: parseInt(document.getElementById('charMaxHp').value) || 0,
        currentStress: parseInt(document.getElementById('charCurrentStress').value) || 0,
        maxStress: parseInt(document.getElementById('charMaxStress').value) || 0,
        armor: parseInt(document.getElementById('charArmor').value) || 0,
        evasion: parseInt(document.getElementById('charEvasion').value) || 10,
        minorThreshold: parseInt(document.getElementById('charMinorThreshold').value) || 0,
        majorThreshold: parseInt(document.getElementById('charMajorThreshold').value) || 0,
        severeThreshold: parseInt(document.getElementById('charSevereThreshold').value) || 0,
        domains: getSelectedDomains(),
        experiences: currentCharacterExperiences,
        abilities: currentCharacterAbilities,
        feats: currentCharacterFeats,
        notes: document.getElementById('charNotes').value,
        updatedAt: new Date().toISOString()
      };

      renderCharactersList();
      updateTabBadges();
      scheduleAutoSaveIfAvailable();
      alert('Character saved!');
    }

    function deleteCurrentCharacter() {
      if (!selectedCharacterId) return;
      if (!confirm('Delete this character? This cannot be undone.')) return;

      playerCharacters = playerCharacters.filter(c => c.id !== selectedCharacterId);
      selectedCharacterId = null;

      document.querySelector('.character-editor-empty').style.display = 'flex';
      document.getElementById('characterEditorForm').style.display = 'none';

      renderCharactersList();
      updateTabBadges();
      scheduleAutoSaveIfAvailable();
    }

    // Character Image Upload
    function showCharacterImageDialog() {
      document.getElementById('characterImageSourceDialog').style.display = 'flex';
      document.getElementById('characterUrlInputSection').style.display = 'none';
    }

    function closeCharacterImageDialog(e) {
      if (e && e.target !== e.currentTarget) return;
      document.getElementById('characterImageSourceDialog').style.display = 'none';
    }

    function chooseCharacterFileUpload() {
      closeCharacterImageDialog();
      document.getElementById('characterImageInput').click();
    }

    function showCharacterUrlInput() {
      document.getElementById('characterUrlInputSection').style.display = 'block';
    }

    function browseCharacterImages() {
      document.getElementById('characterImageSourceDialog').style.display = 'none';
      openImageGallery((url) => {
        setCharacterPortrait(url);
      });
    }

    async function handleCharacterImageUpload(event) {
      const file = event.target.files[0];
      if (!file || !selectedCharacterId) return;

      const imageUrl = await uploadImageToCloud(file);
      setCharacterPortrait(imageUrl);
    }

    function handleCharacterUrlKeyup(event) {
      if (event.key === 'Enter') {
        addCharacterUrl();
      }
    }

    function previewCharacterUrlImage() {
      const url = document.getElementById('characterImageUrlInput').value.trim();
      const preview = document.getElementById('characterUrlPreview');
      const addBtn = document.getElementById('characterUrlAddBtn');

      if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
        preview.innerHTML = `<img src="${url}" alt="Preview" style="max-width: 100px; max-height: 100px; border-radius: 4px;">`;
        addBtn.disabled = false;
      } else {
        preview.innerHTML = '';
        addBtn.disabled = true;
      }
    }

    function addCharacterUrl() {
      const url = document.getElementById('characterImageUrlInput').value.trim();
      if (!url) return;

      setCharacterPortrait(url);
      closeCharacterImageDialog();
      document.getElementById('characterImageUrlInput').value = '';
      document.getElementById('characterUrlPreview').innerHTML = '';
    }

    function setCharacterPortrait(imageUrl) {
      if (!selectedCharacterId) return;

      const charIndex = playerCharacters.findIndex(c => c.id === selectedCharacterId);
      if (charIndex === -1) return;

      playerCharacters[charIndex].portrait = imageUrl;

      const portraitEl = document.getElementById('characterPortrait');
      portraitEl.innerHTML = `<img src="${imageUrl}" alt="Character portrait">`;

      renderCharactersList();
    }

    // Helper to trigger auto-save if cloud features are available
    function scheduleAutoSaveIfAvailable() {
      if (window.cloudFeatures?.scheduleAutoSave) {
        window.cloudFeatures.scheduleAutoSave();
      }
    }

    // Expose character and note functions for cloud save/load integration
    window.getCharactersState = function() {
      return playerCharacters;
    };

    window.setCharactersState = function(chars) {
      playerCharacters = chars || [];
      renderCharactersList();
      updateTabBadges();
    };

    window.getNotesState = function() {
      return campaignNotes;
    };

    window.setNotesState = function(notes) {
      campaignNotes = notes || [];
      renderNotesList();
    };
  </script>

  <!-- Print Card Modal -->
  <div class="print-card-overlay" id="printCardOverlay">
    <div class="print-card-modal">
      <div class="print-card-header">
        <span class="print-card-title">Print Item Card</span>
        <button class="print-card-close" onclick="closePrintCardModal()">&times;</button>
      </div>
      <div id="printCardContent"></div>
      <div class="print-card-actions">
        <button class="print-card-btn secondary" onclick="closePrintCardModal()">Cancel</button>
        <button class="print-card-btn primary" onclick="printCurrentCard()">Print</button>
      </div>
    </div>
  </div>

  <!-- Cloud Features Module (optional - graceful degradation if unavailable) -->
  <script type="module">
    import { initCloudFeatures } from './js/app.js';
    initCloudFeatures().catch(err => {
      console.log('Cloud features not available, running in demo mode');
    });
  </script>
</body>
</html>
