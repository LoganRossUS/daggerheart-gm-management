<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daggerheart - Battle Map</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #1a0d24;
      font-family: 'Cinzel', serif;
      cursor: none;
    }

    /* Connection Status */
    #connectionStatus {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid rgba(179, 136, 255, 0.4);
      border-radius: 12px;
      padding: 16px 20px;
      z-index: 1000;
      font-family: 'Cinzel', serif;
      cursor: default;
      transition: all 0.3s ease;
    }

    #connectionStatus.connected {
      border-color: rgba(76, 175, 80, 0.6);
      background: rgba(0, 30, 0, 0.85);
    }

    #connectionStatus.minimized {
      padding: 8px 12px;
    }

    #connectionStatus.minimized .connection-details {
      display: none;
    }

    .connection-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    #connectionStatus.minimized .connection-header {
      margin-bottom: 0;
    }

    .connection-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff9800;
      animation: pulse 2s infinite;
    }

    #connectionStatus.connected .connection-indicator {
      background: #4caf50;
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .connection-title {
      font-size: 0.85rem;
      color: #b388ff;
    }

    #connectionStatus.connected .connection-title {
      color: #81c784;
    }

    .connection-details {
      margin-top: 8px;
    }

    .room-code-input {
      width: 100%;
      padding: 10px;
      margin: 8px 0;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.4);
      color: #ffd700;
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      font-weight: 700;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .room-code-input:focus {
      outline: none;
      border-color: #b388ff;
    }

    .room-code-input::placeholder {
      color: #555;
      font-weight: 400;
    }

    .connect-btn {
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #7c4dff, #4a0e4e);
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .connect-btn:hover:not(:disabled) {
      transform: scale(1.02);
      filter: brightness(1.1);
    }

    .connect-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .connect-btn.connecting {
      background: linear-gradient(135deg, #ff9800, #e65100);
    }

    .room-code-label {
      font-size: 0.7rem;
      color: #888;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }

    .connected-info {
      font-size: 0.8rem;
      color: #81c784;
      text-align: center;
      padding: 10px 0;
    }

    .minimize-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      color: #888;
      cursor: pointer;
      font-size: 1rem;
      padding: 4px;
      line-height: 1;
    }

    .minimize-btn:hover {
      color: #b388ff;
    }

    /* Map Display */
    #mapContainer {
      position: fixed;
      inset: 0;
      display: none;
      overflow: hidden;
      background: #1a0d24;
    }

    #mapContainer.visible {
      display: block;
    }

    /* Viewport transform layer for synced zoom/pan */
    #mapTransformLayer {
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      will-change: transform;
      transition: transform 0.15s ease-out;
    }

    #mapImage {
      display: block;
      max-width: none;
      max-height: none;
    }

    /* Token Layer */
    #tokenLayer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 100;
    }

    .token {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 3px solid;
      background-size: cover;
      background-position: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .token.player {
      border-color: #4CAF50;
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.6), 0 4px 12px rgba(0, 0, 0, 0.6);
    }

    .token.adversary {
      border-color: #f44336;
      box-shadow: 0 0 15px rgba(244, 67, 54, 0.6), 0 4px 12px rgba(0, 0, 0, 0.6);
    }

    .token-name {
      position: absolute;
      bottom: -22px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.7rem;
      white-space: nowrap;
      pointer-events: none;
    }

    .token-conditions {
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      gap: 2px;
    }

    .condition-badge {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      font-weight: bold;
      border: 2px solid rgba(0, 0, 0, 0.8);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }

    .condition-badge.hidden {
      background: linear-gradient(135deg, #424242 0%, #616161 100%);
      color: white;
    }

    .condition-badge.restrained {
      background: linear-gradient(135deg, #1976D2 0%, #42A5F5 100%);
      color: white;
    }

    .condition-badge.vulnerable {
      background: linear-gradient(135deg, #D32F2F 0%, #F44336 100%);
      color: white;
    }

    /* Grid Overlay */
    #gridOverlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 50;
      display: none;
    }

    #gridOverlay.visible {
      display: block;
    }

  </style>
</head>
<body>
  <!-- Connection Status -->
  <div id="connectionStatus">
    <button class="minimize-btn" onclick="toggleConnectionMinimize()">−</button>
    <div class="connection-header">
      <div class="connection-indicator"></div>
      <div class="connection-title">Enter GM Room Code</div>
    </div>
    <div class="connection-details">
      <div class="room-code-label">Room Code from GM Panel</div>
      <input type="text" id="roomCodeInput" class="room-code-input" placeholder="FIRE-DRAGON-00" maxlength="20" onkeyup="handleRoomCodeKeyup(event)">
      <button class="connect-btn" id="connectBtn" onclick="connectToGM()">Connect</button>
    </div>
  </div>

  <!-- Map Container -->
  <div id="mapContainer">
    <div id="mapTransformLayer">
      <img id="mapImage" src="" alt="Battle Map">
    </div>
  </div>

  <!-- Grid Overlay -->
  <canvas id="gridOverlay"></canvas>

  <!-- Token Layer -->
  <div id="tokenLayer"></div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <script>
    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyA6GYyYWlW1ybQ07-K13u4YUaNFcV66Zj0",
      authDomain: "daggerheart-8bdc1.firebaseapp.com",
      databaseURL: "https://daggerheart-8bdc1-default-rtdb.firebaseio.com",
      projectId: "daggerheart-8bdc1",
      storageBucket: "daggerheart-8bdc1.firebasestorage.app",
      messagingSenderId: "885297626381",
      appId: "1:885297626381:web:9caf2af85fb793f819c444"
    };

    // Initialize Firebase
    let firebaseApp = null;
    let database = null;

    try {
      firebaseApp = firebase.initializeApp(firebaseConfig);
      database = firebase.database();
      console.log('Firebase initialized successfully');
    } catch (e) {
      console.error('Firebase initialization error:', e);
    }

    let roomRef = null;
    let clientId = 'battlemap-' + Math.random().toString(36).substr(2, 9);
    let currentMap = null;
    let tokens = [];
    let gridSize = 50;
    let firebaseConnected = false;

    // Viewport state (synced from GM)
    let viewportZoom = 1;
    let viewportPanX = 0;
    let viewportPanY = 0;
    let tokenScale = 1;

    // Heartbeat and reconnection configuration
    const HEARTBEAT_TIMEOUT = 45000; // Consider connection dead after 45 seconds without heartbeat
    const RECONNECT_BASE_DELAY = 2000; // Base delay for exponential backoff (2 seconds)
    const MAX_RECONNECT_DELAY = 30000; // Max delay between reconnection attempts (30 seconds)
    let lastHeartbeatReceived = Date.now();
    let heartbeatCheckIntervalId = null;
    let reconnectAttempts = 0;
    let reconnectTimeoutId = null;
    let savedRoomCode = null; // Store room code for reconnection

    // Session management - clear stale data when connecting to a new room
    function clearSessionData(newRoomCode) {
      const lastRoom = localStorage.getItem('daggerheart-battlemap-last-room');

      // If connecting to a different room, clear old data
      if (lastRoom !== newRoomCode) {
        console.log('New session detected, clearing stale battle map localStorage data');

        // Clear battle map specific data
        localStorage.removeItem('daggerheart-battle-grid');
        localStorage.removeItem('daggerheart-battle-tokens');
        localStorage.removeItem('daggerheart-battle-map-state');

        // Reset local state
        tokens = [];
        currentMap = null;

        // Store the new room code
        localStorage.setItem('daggerheart-battlemap-last-room', newRoomCode);
      }
    }

    // Handle Enter key in room code input
    function handleRoomCodeKeyup(event) {
      if (event.key === 'Enter') {
        connectToGM();
      }
    }

    // Toggle connection status minimize
    function toggleConnectionMinimize() {
      const statusEl = document.getElementById('connectionStatus');
      statusEl.classList.toggle('minimized');
      const btn = statusEl.querySelector('.minimize-btn');
      btn.textContent = statusEl.classList.contains('minimized') ? '+' : '−';
    }

    // Connect to GM via Firebase
    function connectToGM() {
      const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
      if (!roomCode) {
        return;
      }

      // Clear stale session data if connecting to a different room
      clearSessionData(roomCode);

      // Save room code for automatic reconnection
      savedRoomCode = roomCode;
      reconnectAttempts = 0;

      const statusEl = document.getElementById('connectionStatus');
      const connectBtn = document.getElementById('connectBtn');
      const title = statusEl.querySelector('.connection-title');

      // Update UI to show connecting
      connectBtn.disabled = true;
      connectBtn.textContent = 'Connecting...';
      connectBtn.classList.add('connecting');
      title.textContent = 'Connecting to GM...';

      // Check if Firebase is loaded
      if (!database) {
        console.error('Firebase not initialized');
        title.textContent = 'Firebase not configured';
        connectBtn.disabled = false;
        connectBtn.textContent = 'Retry';
        connectBtn.classList.remove('connecting');
        return;
      }

      try {
        // Connect to the GM's room in Firebase
        roomRef = database.ref('rooms/' + roomCode);

        // Check if GM is active
        roomRef.child('gm').on('value', (snapshot) => {
          const gmData = snapshot.val();
          if (gmData && gmData.active && (Date.now() - gmData.timestamp) < 30000) {
            console.log('GM is active in room:', roomCode);
            lastHeartbeatReceived = Date.now();
            firebaseConnected = true;

            // Update UI to show connected
            statusEl.classList.add('connected');
            title.textContent = 'Connected to GM';
            connectBtn.disabled = true;
            connectBtn.classList.remove('connecting');
            connectBtn.textContent = 'Connected';
            statusEl.querySelector('.connection-details').innerHTML = '<div class="connected-info">Battle Map Connected</div>';

            // Register as connected client
            roomRef.child('clients').child(clientId).set({
              connected: true,
              timestamp: Date.now(),
              type: 'battleMap'
            });

            // Remove client on disconnect
            roomRef.child('clients').child(clientId).onDisconnect().remove();

            // Request battle map sync
            roomRef.child('battleMapRequest').set({
              clientId: clientId,
              timestamp: Date.now()
            });

            // Start heartbeat monitoring
            startHeartbeatMonitoring();
          }
        });

        // Subscribe to all battle map data updates from GM
        subscribeToGmData();

        // Timeout if GM not found within 8 seconds
        setTimeout(() => {
          if (!statusEl.classList.contains('connected')) {
            console.log('Connection timeout - GM not found or inactive');
            title.textContent = 'GM not found. Check code?';
            connectBtn.disabled = false;
            connectBtn.textContent = 'Retry';
            connectBtn.classList.remove('connecting');
          }
        }, 8000);

      } catch (e) {
        console.error('Firebase connection error:', e);
        title.textContent = 'Connection error';
        connectBtn.disabled = false;
        connectBtn.textContent = 'Retry';
        connectBtn.classList.remove('connecting');
      }
    }

    // Subscribe to GM data updates via Firebase
    function subscribeToGmData() {
      if (!roomRef) return;

      // Subscribe to map updates
      roomRef.child('map').on('value', (snapshot) => {
        const data = snapshot.val();
        if (data && data.timestamp) {
          lastHeartbeatReceived = Date.now();
          console.log('Received map update:', data);
          updateMap(data);
        }
      });

      // Subscribe to tokens updates
      roomRef.child('tokens').on('value', (snapshot) => {
        const data = snapshot.val();
        if (data && data.timestamp) {
          lastHeartbeatReceived = Date.now();
          console.log('Received tokens update:', data);
          updateTokens({ tokens: data.tokens || [] });
        }
      });

      // Subscribe to grid updates
      roomRef.child('grid').on('value', (snapshot) => {
        const data = snapshot.val();
        if (data && data.timestamp) {
          lastHeartbeatReceived = Date.now();
          console.log('Received grid update:', data);
          updateGrid(data);
        }
      });

      // Subscribe to full map sync updates
      roomRef.child('mapSync').on('value', (snapshot) => {
        const data = snapshot.val();
        if (data && data.timestamp) {
          lastHeartbeatReceived = Date.now();
          console.log('Received mapSync update:', data);

          if (data.map) {
            updateMap(data.map);
          }
          if (data.tokens) {
            updateTokens({ tokens: data.tokens.tokens || data.tokens });
          }
          if (data.grid) {
            updateGrid(data.grid);
          }
          if (data.viewport) {
            updateViewport(data.viewport);
          }
        }
      });
    }

    function handleGMData(data) {
      console.log('Received data from GM:', data);

      if (!data || !data.type) return;

      switch (data.type) {
        case 'map':
          updateMap(data);
          break;
        case 'tokens':
          updateTokens(data);
          break;
        case 'grid':
          updateGrid(data);
          break;
        case 'mapSync':
          // Full sync
          if (data.map) updateMap(data.map);
          if (data.tokens) updateTokens(data.tokens);
          if (data.grid) updateGrid(data.grid);
          break;
      }
    }

    function updateMap(data) {
      const mapContainer = document.getElementById('mapContainer');
      const mapImage = document.getElementById('mapImage');

      if (data.visible && data.mapImage) {
        currentMap = data;
        mapImage.src = data.mapImage;
        mapContainer.classList.add('visible');

        if (data.gridSize) {
          gridSize = data.gridSize;
        }
      } else {
        mapContainer.classList.remove('visible');
        currentMap = null;
      }
    }

    function updateTokens(data) {
      tokens = data.tokens || [];
      renderTokens();
    }

    function renderTokens() {
      const tokenLayer = document.getElementById('tokenLayer');
      tokenLayer.innerHTML = '';

      if (!currentMap || !tokens.length) return;

      const mapImage = document.getElementById('mapImage');
      const mapRect = mapImage.getBoundingClientRect();

      // Calculate base token size (matching GM panel) and apply scale
      const baseTokenSize = 60; // Base size in pixels
      const scaledTokenSize = baseTokenSize * tokenScale;

      tokens.forEach(token => {
        const tokenEl = document.createElement('div');
        tokenEl.className = `token ${token.type}`;
        tokenEl.id = `token-${token.id}`;

        // Calculate position based on grid coordinates
        // The mapRect already reflects the viewport transform (pan and zoom)
        // gridSize needs to be scaled by viewportZoom
        const scaledGridSize = gridSize * viewportZoom;
        const pixelX = mapRect.left + (token.x * scaledGridSize) + (scaledGridSize / 2);
        const pixelY = mapRect.top + (token.y * scaledGridSize) + (scaledGridSize / 2);

        tokenEl.style.left = `${pixelX}px`;
        tokenEl.style.top = `${pixelY}px`;
        tokenEl.style.transform = 'translate(-50%, -50%)';

        // Apply token scale
        tokenEl.style.width = `${scaledTokenSize}px`;
        tokenEl.style.height = `${scaledTokenSize}px`;

        // Set token image
        if (token.image) {
          tokenEl.style.backgroundImage = `url(${token.image})`;
        } else {
          // Default colored circle if no image
          tokenEl.style.backgroundColor = token.type === 'player' ? '#4CAF50' : '#f44336';
        }

        // Add token name
        const nameEl = document.createElement('div');
        nameEl.className = 'token-name';
        nameEl.textContent = token.name;
        tokenEl.appendChild(nameEl);

        // Add condition badges
        if (token.conditions && Object.keys(token.conditions).length > 0) {
          const conditionsEl = document.createElement('div');
          conditionsEl.className = 'token-conditions';

          if (token.conditions.hidden) {
            const badge = document.createElement('div');
            badge.className = 'condition-badge hidden';
            badge.textContent = 'H';
            badge.title = 'Hidden';
            conditionsEl.appendChild(badge);
          }

          if (token.conditions.restrained) {
            const badge = document.createElement('div');
            badge.className = 'condition-badge restrained';
            badge.textContent = 'R';
            badge.title = 'Restrained';
            conditionsEl.appendChild(badge);
          }

          if (token.conditions.vulnerable) {
            const badge = document.createElement('div');
            badge.className = 'condition-badge vulnerable';
            badge.textContent = 'V';
            badge.title = 'Vulnerable';
            conditionsEl.appendChild(badge);
          }

          tokenEl.appendChild(conditionsEl);
        }

        tokenLayer.appendChild(tokenEl);
      });
    }

    function updateGrid(data) {
      const gridOverlay = document.getElementById('gridOverlay');

      if (data.visible) {
        gridOverlay.classList.add('visible');
        drawGrid();
      } else {
        gridOverlay.classList.remove('visible');
      }
    }

    function updateViewport(data) {
      if (!data) return;

      // Update viewport state
      viewportZoom = data.zoom || 1;
      viewportPanX = data.panX || 0;
      viewportPanY = data.panY || 0;
      tokenScale = data.tokenScale || 1;

      console.log('Updating viewport:', { viewportZoom, viewportPanX, viewportPanY, tokenScale });

      // Apply transform to the map
      const transformLayer = document.getElementById('mapTransformLayer');
      if (transformLayer) {
        transformLayer.style.transform = `translate(${viewportPanX}px, ${viewportPanY}px) scale(${viewportZoom})`;
      }

      // Re-render tokens with new scale and redraw grid
      renderTokens();
      if (document.getElementById('gridOverlay').classList.contains('visible')) {
        drawGrid();
      }
    }

    function drawGrid() {
      const canvas = document.getElementById('gridOverlay');
      const ctx = canvas.getContext('2d');

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      if (!currentMap) return;

      const mapImage = document.getElementById('mapImage');
      const mapRect = mapImage.getBoundingClientRect();

      // Scale grid size based on viewport zoom
      const scaledGridSize = gridSize * viewportZoom;

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 1;

      // Draw vertical lines
      for (let x = mapRect.left; x < mapRect.right; x += scaledGridSize) {
        ctx.beginPath();
        ctx.moveTo(x, mapRect.top);
        ctx.lineTo(x, mapRect.bottom);
        ctx.stroke();
      }

      // Draw horizontal lines
      for (let y = mapRect.top; y < mapRect.bottom; y += scaledGridSize) {
        ctx.beginPath();
        ctx.moveTo(mapRect.left, y);
        ctx.lineTo(mapRect.right, y);
        ctx.stroke();
      }
    }

    // Redraw grid and tokens on window resize
    window.addEventListener('resize', () => {
      if (currentMap) {
        renderTokens();
        if (document.getElementById('gridOverlay').classList.contains('visible')) {
          drawGrid();
        }
      }
    });

    // localStorage fallback for same-machine setup (grid and tokens only, not map images)
    function checkLocalStorage() {
      // Skip if connected via Firebase
      if (firebaseConnected) {
        return;
      }

      // Check for grid data
      try {
        const gridData = localStorage.getItem('daggerheart-battle-grid');
        if (gridData) {
          const parsed = JSON.parse(gridData);
          updateGrid(parsed);
        }
      } catch (err) {
        console.error('Error parsing grid data:', err);
      }

      // Check for token data
      try {
        const tokenData = localStorage.getItem('daggerheart-battle-tokens');
        if (tokenData) {
          const parsed = JSON.parse(tokenData);
          updateTokens(parsed);
        }
      } catch (err) {
        console.error('Error parsing token data:', err);
      }
    }

    // Poll localStorage every 100ms as fallback (when not connected via Gun.js)
    setInterval(checkLocalStorage, 100);

    // ========== Heartbeat Monitoring and Automatic Reconnection ==========

    function startHeartbeatMonitoring() {
      if (heartbeatCheckIntervalId) {
        clearInterval(heartbeatCheckIntervalId);
      }

      lastHeartbeatReceived = Date.now();
      heartbeatCheckIntervalId = setInterval(() => {
        checkHeartbeat();
      }, 10000); // Check every 10 seconds

      // Also send periodic client heartbeats to GM
      setInterval(() => {
        if (roomRef) {
          roomRef.child('clients').child(clientId).update({
            connected: true,
            timestamp: Date.now(),
            type: 'battleMap'
          });
        }
      }, 15000);

      console.log('Heartbeat monitoring started');
    }

    function stopHeartbeatMonitoring() {
      if (heartbeatCheckIntervalId) {
        clearInterval(heartbeatCheckIntervalId);
        heartbeatCheckIntervalId = null;
      }
      console.log('Heartbeat monitoring stopped');
    }

    function checkHeartbeat() {
      if (!roomRef) {
        return; // Not connected, nothing to check
      }

      const now = Date.now();
      const timeSinceLastHeartbeat = now - lastHeartbeatReceived;

      if (timeSinceLastHeartbeat > HEARTBEAT_TIMEOUT) {
        console.warn('No data received for', Math.round(timeSinceLastHeartbeat / 1000), 'seconds. Connection may be stale.');
        // Trigger reconnection
        handleDisconnection();
      }
    }

    function scheduleReconnect() {
      if (reconnectTimeoutId) {
        clearTimeout(reconnectTimeoutId);
      }

      if (!savedRoomCode) {
        console.log('No room code saved, cannot reconnect');
        return;
      }

      // Exponential backoff: 2s, 4s, 8s, 16s, 30s (max)
      const delay = Math.min(RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts), MAX_RECONNECT_DELAY);
      reconnectAttempts++;

      console.log(`Scheduling reconnect attempt ${reconnectAttempts} in ${delay / 1000} seconds...`);

      const statusEl = document.getElementById('connectionStatus');
      const title = statusEl.querySelector('.connection-title');
      title.textContent = `Reconnecting in ${Math.round(delay / 1000)}s...`;

      reconnectTimeoutId = setTimeout(() => {
        console.log('Attempting to reconnect...');
        attemptReconnect();
      }, delay);
    }

    function attemptReconnect() {
      if (!savedRoomCode) {
        console.log('No room code saved, cannot reconnect');
        return;
      }

      const statusEl = document.getElementById('connectionStatus');
      const title = statusEl.querySelector('.connection-title');
      title.textContent = 'Reconnecting to GM...';

      try {
        // Reconnect to the room via Firebase
        roomRef = database.ref('rooms/' + savedRoomCode);

        // Check if GM is still active
        roomRef.child('gm').once('value', (snapshot) => {
          const gmData = snapshot.val();
          if (gmData && gmData.active && (Date.now() - gmData.timestamp) < 30000) {
            console.log('Reconnected to GM!');
            reconnectAttempts = 0;
            lastHeartbeatReceived = Date.now();
            firebaseConnected = true;

            statusEl.classList.add('connected');
            title.textContent = 'Connected to GM';
            statusEl.querySelector('.connection-details').innerHTML = '<div class="connected-info">Battle Map Connected</div>';

            // Re-register as connected client and request sync
            roomRef.child('clients').child(clientId).set({
              connected: true,
              timestamp: Date.now(),
              type: 'battleMap'
            });

            // Request battle map sync
            roomRef.child('battleMapRequest').set({
              clientId: clientId,
              timestamp: Date.now()
            });

            subscribeToGmData();
            startHeartbeatMonitoring();
          } else {
            console.log('GM not active, scheduling reconnect...');
            scheduleReconnect();
          }
        });

      } catch (e) {
        console.error('Reconnection error:', e);
        scheduleReconnect();
      }
    }

    function handleDisconnection() {
      roomRef = null;
      firebaseConnected = false;
      stopHeartbeatMonitoring();

      const statusEl = document.getElementById('connectionStatus');
      const title = statusEl.querySelector('.connection-title');
      statusEl.classList.remove('connected');
      title.textContent = 'Disconnected - Reconnecting...';

      // Automatically attempt to reconnect
      scheduleReconnect();
    }

    // Listen for storage events (cross-tab) for same-machine setup
    // Skip if connected via Firebase to avoid overwriting correct data (with images)
    window.addEventListener('storage', (e) => {
      if (firebaseConnected) {
        return; // Firebase is connected, use that instead of localStorage
      }
      if (e.key === 'daggerheart-battle-grid' && e.newValue) {
        try {
          updateGrid(JSON.parse(e.newValue));
        } catch (err) {
          console.error('Error parsing grid event:', err);
        }
      } else if (e.key === 'daggerheart-battle-tokens' && e.newValue) {
        try {
          updateTokens(JSON.parse(e.newValue));
        } catch (err) {
          console.error('Error parsing tokens event:', err);
        }
      }
    });
  </script>
</body>
</html>
